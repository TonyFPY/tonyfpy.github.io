[{"content":" Authored by Tony Feng\nCreated on April 21st, 2022\nLast Modified on April 21st, 2022\n Task 1 - Q48. 最长不含重复字符的子字符串 Question 请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。 e.g.  输入: \u0026ldquo;abcabcbb\u0026rdquo;, 输出: 3  解释: 因为无重复字符的最长子串是 \u0026ldquo;abc\u0026rdquo;，所以其长度为 3。\nSolution 1 2 3 4 5 6 7 8 9 10  class Solution: def lengthOfLongestSubstring(self, s: str) -\u0026gt; int: dict = {} res = tmp = 0 for j in range(0, len(s)): i = dict.get(s[j], -1) # get index i, the position where s[j] exists dict[s[j]] = j # update the hash map tmp = tmp + 1 if tmp \u0026lt; j - i else j - i # dp[j - 1] -\u0026gt; dp[j] res = max(res, tmp) # max(dp[j - 1], dp[j]) return res   Explanation  tmp records the length of the unrepeated substring ending with s[j]. ```dict`` records the last position where each key exists. Time Complexity: O(N) Space Complexity: O(1)   Task 2 - Q46. 把数字翻译成字符串 Question 给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。 e.g.  输入: 12258, 输出: 5  解释: 12258有5种不同的翻译，分别是\u0026quot;bccfi\u0026quot;, \u0026ldquo;bwfi\u0026rdquo;, \u0026ldquo;bczi\u0026rdquo;, \u0026ldquo;mcfi\u0026quot;和\u0026quot;mzi\u0026rdquo; \nSolution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  class Solution2: # dp def translateNum(self, num: int) -\u0026gt; int: num = list(str(num)) dp = [1 for _ in range(0, len(num)+1)] # dp[0] == dp[1] == 1 for i in range(2, len(num)+1): # dp[i] means the sum of the approaches before num[i] (i.e., num[0] ... num[i-1]) # Be careful with the index here if int(num[i-2] + num[i-1]) \u0026lt; 26 and int(num[i-2]) != 0: dp[i] = dp[i-1] + dp[i-2] else: dp[i] = dp[i-1] return dp[-1] class Solution2: # Recursion def translateNum(self, num: int) -\u0026gt; int: def recur(arr): if len(arr) \u0026lt;= 1: # base case return 1 # no need to count on \u0026#34;01\u0026#34;, \u0026#34;02\u0026#34;, ..., \u0026#34;09\u0026#34;  # no need to count on num \u0026gt;= 26 if int(arr[0] + arr[1]) \u0026lt; 26 and int(arr[0]) != 0: return recur(arr[1:]) + recur(arr[2:]) else: return recur(arr[1:]) return recur(str(num))   Explanation  Solution 1  Time Complexity: O(N) Space Complexity: O(N)   Solution 2  Time Complexity: O(2N) Space Complexity: O(N)     ","date":"2022-04-21T20:31:37+08:00","permalink":"https://tonyfpy.github.io/p/%E5%89%91%E6%8C%87offer-day10-dynamic-programming/","title":"[剑指Offer] Day10: Dynamic Programming"},{"content":" Authored by Tony Feng\nCreated on April 10th, 2022\nLast Modified on April 10th, 2022\n Understanding Trie Main Concepts  A trie is a special tree that can compactly store strings. Tries are based on the prefix of a string. They are used to represent the \u0026ldquo;Retrieval\u0026rdquo; of data and thus the name Trie.  Charateristics  Strengths  Sometimes Space-Efficient. If you\u0026rsquo;re storing lots of words that start with similar patterns, tries may reduce the overall storage cost by storing shared prefixes once. Efficient Prefix Queries. Tries can quickly answer queries about words with shared prefixes   Weakness  Usually Space-Inefficient. Tries rarely save space when compared to storing strings in a set. Not Standard. Most languages don\u0026rsquo;t come with a built-in trie implementation.     Example Leetcode 208 Implement Trie (Prefix Tree) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41  class TrieNode: def __init__(self, char = \u0026#34;\u0026#34;): self.char = char self.children = {} self.is_end = False # self.counter = 0 class Trie: def __init__(self): self.root = TrieNode() def insert(self, word: str) -\u0026gt; None: node = self.root for char in word: if char in node.children: node = node.children[char] else: new_node = TrieNode(char) node.children[char] = new_node node = new_node node.is_end = True # node.counter += 1 def search(self, word: str) -\u0026gt; bool: node = self.root for char in word: if char not in node.children: return False node = node.children[char] # Reached at the end of word # return True if word is present, i.e is_end = True else False return node.is_end def startsWith(self, prefix: str) -\u0026gt; bool: node = self.root for char in prefix: if char not in node.children: return False node = node.children[char] return True   Leetcode 720 Longest Word in Dictionary 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  class TrieNode: def __init__(self, val): self.children = {} self.value = val self.endOfWord = False class Solution: def longestWord(self, words: List[str]) -\u0026gt; str: root = TrieNode(0) maxLen = 0 res = \u0026#34;\u0026#34; for word in sorted(words): cur = root count = 0 for letter in word: if letter not in cur.children: cur.children[letter] = TrieNode(count) cur = cur.children[letter] if cur.endOfWord: count += 1 cur.endOfWord = True cur.value += 1 if cur.value == len(word) and cur.value \u0026gt; maxLen: maxLen = cur.value res = word return res    Reference  Trie (Keyword Tree) InterviewCake - Trie 手把手带你刷Leetcode力扣 - 前缀树 Trie 手把手带你刷Leetcode力扣 - Leetcode 720   ","date":"2022-04-10T22:38:44+08:00","permalink":"https://tonyfpy.github.io/p/data-structure-topic-11-trie/","title":"[Data Structure] Topic 11: Trie"},{"content":" Authored by Tony Feng\nCreated on April 10th, 2022\nLast Modified on April 10th, 2022\n Understanding Dynamic Programming Intro  Dynamic Programming helps to efficiently solve a class of problems that have overlapping subproblems and optimal substructure property. Key elements  Initialization State-transition Equation Termination    Characteristics  Overlapping Subproblems  Any problem has overlapping sub-problems if finding its solution involves solving the same subproblem multiple times.   Optimal Substructure Property  Any problem has optimal substructure property if its overall optimal solution can be constructed from the optimal solutions of its subproblems.    Dynamic Programming Methods  Top-down with Memoization  In this approach, we try to solve the bigger problem by recursively finding the solution to smaller sub-problems. Whenever we solve a sub-problem, we cache its result so that we can just return the saved result if it’s called multiple times.   Bottom-up with Tabulation  Tabulation is the opposite of the top-down approach and avoids recursion. In this approach, we solve the problem “bottom-up” (i.e. by solving all the related sub-problems first). This is typically done by filling up an n-dimensional table. Based on the results in the table, the solution to the top/original problem is then computed.     Examples Leetcode 509 Fibonacci Number 1 2 3 4 5 6 7 8 9 10 11 12  class Solution: def fib(self, n: int) -\u0026gt; int: if n == 0: return 0 if n == 1: return 1 dp = [0] * (n + 1) dp[0], dp[1] = 0, 1 for i in range(2, n+1): dp[i] = dp[i-1] + dp[i-2] # State-transition Equation return dp[n]   Leetcode 62 Unique Paths 1 2 3 4 5 6 7 8 9 10 11 12 13 14  class Solution: def uniquePaths(self, m: int, n: int) -\u0026gt; int: dp = [[1 for _ in range(n)] for _ in range(m)] for i in range(0, m): for j in range(0, n): if i - 1 \u0026lt; 0: dp[i][j] = dp[i][j-1] elif j - 1 \u0026lt; 0: dp[i][j] = dp[i-1][j] else: dp[i][j] = dp[i-1][j] + dp[i][j-1] return dp[m - 1][n - 1]    Reference  手把手带你刷Leetcode力扣 - 动态规划 Dynamic Programming 手把手带你刷Leetcode力扣 - Leetcode 509 手把手带你刷Leetcode力扣 - Leetcode 62 What is Dynamic Programming? Programiz - Dynamic Programming   ","date":"2022-04-10T22:37:31+08:00","permalink":"https://tonyfpy.github.io/p/algorithm-topic-10-dynamic-programming/","title":"[Algorithm] Topic 10: Dynamic Programming"},{"content":" Authored by Tony Feng\nCreated on April 9th, 2022\nLast Modified on April 9th, 2022\n Understanding Greedy Search Intro  A greedy algorithm is an approach for solving a problem by selecting the best option available at the moment. It works in a top-down approach. It doesn\u0026rsquo;t guarantee whether the current best result will bring the overall optimal result. We can determine if the algorithm can be used with any problem if the problem has the following properties:  Greedy Choice Property Optimal Substructure    Characteristics  Advantages of Greedy Approach  The algorithm is easier to describe.   Drawback of Greedy Approach  The greedy algorithm doesn\u0026rsquo;t always produce the optimal solution. The difficult part is that for greedy algorithms you have to work much harder to understand correctness issues. Optimization problems (Dijkstra’s Algorithm) with negative graph edges cannot be solved using a greedy algorithm.    Steps  To begin with, the solution set (containing answers) is empty. At each step, an item is added to the solution set until a solution is reached. If the solution set is feasible, the current item is kept. Else, the item is rejected and never considered again.   Template 1 2 3 4 5 6 7 8 9 10  # Pseudocode Greedy(input I): begin while (solution is not complete) do Select the best element x in the remaining input I; Put x next in the output; Remove x from the remaining input; endwhile end    Examples Leetcode 55 Jump Game 1 2 3 4 5 6 7 8 9 10 11 12  class Solution: def canJump(self, nums): \u0026#34;\u0026#34;\u0026#34; :type nums: List[int] :rtype: bool \u0026#34;\u0026#34;\u0026#34; reach = 0 for i, num in enumerate(nums): if i \u0026gt; reach: return False reach = max(reach, i + num) return True    Reference  手把手带你刷Leetcode力扣 - 贪心算法 Greedy Search Greedy Algorithms Explained with Examples   ","date":"2022-04-09T22:37:19+08:00","permalink":"https://tonyfpy.github.io/p/algorithm-topic-9-greedy-search/","title":"[Algorithm] Topic 9: Greedy Search"},{"content":" Authored by Tony Feng\nCreated on April 7th, 2022\nLast Modified on April 9th, 2022\n Understanding Union Find Intro  A disjoint-set data structure keeps track of a set of elements partitioned into a number of disjoint (non-overlapping) subsets. A union-find algorithm performs union and find operation on those subsets. Union-Find Algorithm can be used to check whether an undirected graph contains cycle or not.  Union \u0026amp; Find  Find  It determines in which subset a particular element is in and returns the representative of that particular set.   Union  It merges two different subsets into a single subset, and the representative of one set becomes representative of another.     Template Common Union Find 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  class UnionFind: def __init__(self, n): # Initialization.  # The parent of each node is itself. self.root = list(range(0,n)) def find(self, x): if x == self.root[x]: return self.root[x] else: return self.find(self.root[x]) def union(self, x, y): rootX = self.root[x] rootY = self.root[y] if rootX != rootY: self.root[rootX] = rootY   Union Find Improvement 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  class UnionFind: def __init__(self, n): # Initialization.  # The parent of each node is itself. self.root = list(range(0,n)) self.rank = [0] * n def find(self, x): if x != self.root[x]: # Use recursion to assign the root value self.root[x] = self.find(self.root[x]) return self.root[x] # Avoid the tree to be too high def union(self, x, y): rootX = self.root[x] rootY = self.root[y] if rootX != rootY: if self.rank[rootX] \u0026gt; self.rank[rootY]: self.root[rootY] = rootX elif self.rank[rootX] \u0026lt; self.rank[rootY]: self.root[rootX] = rootY else: self.root[rootY] = rootX self.rank[rootX] += 1    Examples Leetcode 200 Number of Islands 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48  # Time Complexity: O(MN) # Space Complexity: O(MN) class Solution: def numIslands(self, grid: List[List[str]]) -\u0026gt; int: if grid is None or len(grid) == 0: return 0 row = len(grid) col = len(grid[0]) waters = 0 uf = UnionFind(grid) for i in range(0, row): for j in range(0, col): if grid[i][j] == \u0026#39;0\u0026#39;: waters += 1 else: directions = [(0,1), (0,-1), (-1,0), (1,0)] for x, y in directions: x = x + i y = y + j if x\u0026gt;=0 and y\u0026gt;=0 and x\u0026lt;row and y\u0026lt;col and grid[x][y] == \u0026#39;1\u0026#39;: uf.union(x*col+y, i*col+j) return uf.getCount() - waters class UnionFind: def __init__(self, grid): row = len(grid) col = len(grid[0]) self.root = [-1]*(row*col) self.count = row*col for i in range(0, row*col): self.root[i] = i def find(self, x): if x == self.root[x]: return self.root[x] else: self.root[x] = self.find(self.root[x]) return self.root[x] def union(self, x, y): rootX = self.find(x) rootY = self.find(y) if rootX != rootY: self.root[rootX] = rootY self.count -= 1 def getCount(self): return self.count    Reference  手把手带你刷Leetcode力扣 - 并查集 Union Find 手把手带你刷Leetcode力扣 - 并查集优化 Union Find Optimization 手把手带你刷Leetcode力扣 - Leetcode 200 Disjoint Set (Or Union-Find) Disjoint–Set Data Structure (Union–Find Algorithm)   ","date":"2022-04-07T22:37:04+08:00","permalink":"https://tonyfpy.github.io/p/algorithm-topic-8-union-find/","title":"[Algorithm] Topic 8: Union Find"},{"content":" Authored by Tony Feng\nCreated on April 6th, 2022\nLast Modified on April 6th, 2022\n Understanding BFS Intro  Breadth-First Search (BFS) is an algorithm used for traversing graphs or trees. Breadth-First Search is a recursive algorithm to search all the vertices of a graph or a tree. BFS starts from a node, then it checks all the nodes at distance I from the beginning node, then it checks all the nodes at distance II, and so on. In order to re-collect the nodes to be visited, BFS uses a queue. The time complexity of DFS if the entire tree is traversed is O(V), where V is the number of nodes. In the case of a graph, the time complexity is O(V + E), where V is the number of vertexes and E is the number of edges.  Please note that O(E) may vary between O(1) and O(V2), depending on how dense the graph is.    Steps of BFS  Add the root/start node to the Queue. For every node, set that they don\u0026rsquo;t have a defined parent node. Until the Queue is empty:  Extract the node from the beginning of the Queue. Perform output processing. For every neighbor of the current node that doesn\u0026rsquo;t have a defined parent (is not visited), add it to the Queue, and set the current node as their parent.     Template 1 2 3 4 5 6 7 8 9 10 11 12  def bfs(visited, graph, node): #function for BFS visited.append(node) queue.append(node) while queue: # Creating loop to visit each node m = queue.pop(0) print (m, end = \u0026#34; \u0026#34;) for neighbour in graph[m]: if neighbour not in visited: visited.append(neighbour) queue.append(neighbour)    Examples Leetcode 102 Binary Tree Level Order Traversal 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  from collections import deque class Solution: def levelOrder(self, root: Optional[TreeNode]) -\u0026gt; List[List[int]]: if not root: return [] ans = [] q = deque() # Store nodes q.append(root) while len(q) \u0026gt; 0: size = len(q) # Get how many nodes are in current level tmp = [] # Store nodes in the current level while size \u0026gt; 0: node = q.popleft() tmp.append(node.val) if node.left: q.append(node.left) if node.right: q.append(node.right) size -= 1 ans.append(tmp[:]) return ans   Leetcode 200 Number of Islands 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  class Solution: def numIslands(self, grid: List[List[str]]) -\u0026gt; int: if not grid or len(grid) == 0: return 0 res = 0 q = deque() for i in range(0, len(grid)): for j in range(0, len(grid[0])): if grid[i][j] == \u0026#34;1\u0026#34;: res += 1 q.append([i,j]) grid[i][j] = \u0026#34;2\u0026#34; while len(q) \u0026gt; 0: cur = q.popleft() [x,y] = cur if x-1 \u0026gt;= 0 and grid[x-1][y] == \u0026#34;1\u0026#34;: q.append([x-1,y]) grid[x-1][y] = \u0026#34;2\u0026#34; if x+1 \u0026lt; len(grid) and grid[x+1][y] == \u0026#34;1\u0026#34;: q.append([x+1,y]) grid[x+1][y] = \u0026#34;2\u0026#34; if y-1 \u0026gt;= 0 and grid[x][y-1] == \u0026#34;1\u0026#34;: q.append([x, y-1]) grid[x][y-1] = \u0026#34;2\u0026#34; if y+1 \u0026lt; len(grid[0]) and grid[x][y+1] == \u0026#34;1\u0026#34;: q.append([x, y+1]) grid[x][y+1] = \u0026#34;2\u0026#34; return res    Reference  手把手带你刷Leetcode力扣 - 广度优先搜索 BFS 手把手带你刷Leetcode力扣 - Leetcode 102 手把手带你刷Leetcode力扣 - Leetcode 107 手把手带你刷Leetcode力扣 - Leetcode 200 Breadth First Search in Python (with Code) | BFS Algorithm Graphs in Python: Breadth-First Search (BFS) Algorithm What is Breadth First Search?   ","date":"2022-04-06T22:36:48+08:00","permalink":"https://tonyfpy.github.io/p/algorithm-topic-7-breadth-first-search/","title":"[Algorithm] Topic 7: Breadth-First Search"},{"content":" Authored by Tony Feng\nCreated on April 5th, 2022\nLast Modified on April 5th, 2022\n Understanding DFS Intro  Depth-first search is an algorithm for traversing or searching tree or graph data structures. The algorithm starts at the root node (selecting some arbitrary node as the root node in the case of a graph) and explores as far as possible along each branch before backtracking. The time complexity of DFS if the entire tree is traversed is O(V), where V is the number of nodes; In the case of a graph, the time complexity is O(V + E), where V is the number of vertexes and E is the number of edges.  Steps of DFS  Create a recursive function that takes the index of the node and a visited array. Mark the current node as visited and print the node. Traverse all the adjacent and unmarked nodes and call the recursive function with the index of the adjacent node.   Template 1 2 3 4 5 6  def dfs(visited, graph, node): if node not in visited: print (node) visited.add(node) for neighbour in graph[node]: dfs(visited, graph, neighbour)    Examples Leetcode 78 Subsets 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  class Solution: def subsets(self, nums: List[int]) -\u0026gt; List[List[int]]: ans = [] def dfs(nums, res, index, subset): res.append(subset[:]) if index == len(nums): return for id in range(index, len(nums)): subset.append(nums[id]) dfs(nums, res, id+1, subset) subset.pop() dfs(nums, ans, 0, []) return ans   Leetcode 200 Number of Islands 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  class Solution: def numIslands(self, grid: List[List[str]]) -\u0026gt; int: def dfs(grid, i, j): if i \u0026lt; 0 or j \u0026lt; 0 or i \u0026gt;= len(grid) or j \u0026gt;= len(grid[0]) or grid[i][j] != \u0026#39;1\u0026#39;: return grid[i][j] = \u0026#39;2\u0026#39; dfs(grid, i+1, j) dfs(grid, i-1, j) dfs(grid, i, j+1) dfs(grid, i, j-1) if not grid or len(grid) == 0: return 0 count = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == \u0026#39;1\u0026#39;: dfs(grid, i, j) count += 1 return count   Leetcode 102 Binary Tree Level Order Traversal 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  class Solution: def levelOrder(self, root: Optional[TreeNode]) -\u0026gt; List[List[int]]: def dfs(node, ans, level): if not node: return if level \u0026gt; len(ans) - 1: ans.append([]) ans[level].append(node.val) if node.left: dfs(node.left, ans, level + 1) if node.right: dfs(node.right, ans, level + 1) if not root: return root ans = [] dfs(root, ans, 0) return ans    Reference  手把手带你刷Leetcode力扣 - 深度优先搜索 DFS 手把手带你刷Leetcode力扣 - Leetcode 938 手把手带你刷Leetcode力扣 - Leetcode 200 Depth First Search or DFS for a Graph Depth First Search (DFS) What is Depth First Search?   ","date":"2022-04-05T22:36:36+08:00","permalink":"https://tonyfpy.github.io/p/algorithm-topic-6-depth-first-search/","title":"[Algorithm] Topic 6: Depth-First Search"},{"content":" Authored by Tony Feng\nCreated on April 4th, 2022\nLast Modified on April 4th, 2022\n Understanding Backtracking Intro  A backtracking algorithm is a problem-solving algorithm that uses a brute-force approach for finding the desired output. The term backtracking suggests that if the current solution is not suitable, then go back and try other solutions. Backtracking uses recursion to discover all of the possibilities until we get the best end result for the problem. State Space Tree  A space state tree is a tree representing all the possible states (solution or nonsolution) of the problem from the root as an initial state to the leaf as a terminal state. In combinatorial search problems, search space is in the shape of a tree.    Types of Problems  Decision Problem: Search for a feasible solution Optimization Problem: Search for the best solution Enumeration Problem: Find all feasible soutions   Template 1 2 3 4 5 6 7 8 9 10 11  # Pseudocode function backtracking(node, state): if state is a solution: report(state) # e.g. add state to final result list return for child in children: if child is a part of a potential solution: state.add(child) # make move backtracking(child, state) state.remove(child) # backtrack    Examples Leetcode 46 Permutations 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  class Solution: def permute(self, nums: List[int]) -\u0026gt; List[List[int]]: ans = [] def backtrack(path, cnt): if cnt == 0: ans.append(path[:]) # Copy the content instead of the reference return for item in nums: if not item in path: path.append(item) backtrack(path, cnt-1) path.pop() backtrack([],len(nums)) return ans   Leetcode 77 Combinations 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  class Solution: def combine(self, n: int, k: int) -\u0026gt; List[List[int]]: ans = [] nums = list(range(1, n+1)) def backtrack(path, m): if len(path)==k: ans.append(path[:]) return for i in range(m, len(nums)): path.append(nums[i]) backtrack(path, i+1) path.pop() backtrack([],0) return ans   Leetcode 78 Subsets 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  class Solution: def subsets(self, nums: List[int]) -\u0026gt; List[List[int]]: ans = [[]] def backtrack(path, lmt, index): if len(path) == lmt: ans.append(path[:]) return for id in range(index, len(nums)): path.append(nums[id]) backtrack(path, lmt, id+1) path.pop() for i in range(1, len(nums)+1): backtrack([], i, 0) return ans   Leetcode 22 Generate Parentheses 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  class Solution: def generateParenthesis(self, n: int) -\u0026gt; List[str]: left, right = 0, 0 ans = [] def backtrack(path, l, r): if l == n and r == n: path = (\u0026#34;\u0026#34;).join(path) ans.append(path[:]) return # The number of right bracket cannot exceed that of left bracket. if l \u0026lt; r: return if l \u0026lt;= n: path.append(\u0026#34;(\u0026#34;) backtrack(path, l+1, r) path.pop() if l \u0026gt; r: path.append(\u0026#34;)\u0026#34;) backtrack(path, l, r+1) path.pop() backtrack([], left, right) return ans    Reference  手把手带你刷Leetcode力扣 - 回溯法 Backtracking 手把手带你刷Leetcode力扣 - Leetcode 22 手把手带你刷Leetcode力扣 - Leetcode 78 Backtracking in Python Backtracking Template   ","date":"2022-04-04T22:36:22+08:00","permalink":"https://tonyfpy.github.io/p/algorithm-topic-5-backtracking/","title":"[Algorithm] Topic 5: Backtracking"},{"content":" Authored by Tony Feng\nCreated on April 3rd, 2022\nLast Modified on April 3rd, 2022\n Understanding Divide \u0026amp; Conquer Intro  In computer science, divide and conquer is an algorithm design paradigm. A divide-and-conquer algorithm recursively breaks down a problem into two or more sub-problems of the same or related type, until these become simple enough to be solved directly.  Components  Divide/Break  This involves dividing the problem into smaller sub-problems.   Conquer/Solve  Solve sub-problems by calling recursively until solved.   Combine/Merge  Combine the sub-problems to get the final solution of the whole problem.    Applications  Merge Sort Quick Sort Binary Search Strassen\u0026rsquo;s Matrix Multiplication Closest pair (points)   Examples Tower of Hanoi 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  def TowerOfHanoi(n , source, destination, auxiliary): if n==1: print (\u0026#34;Move disk 1 from source\u0026#34;,source,\u0026#34;to destination\u0026#34;,destination) return TowerOfHanoi(n-1, source, auxiliary, destination) print (\u0026#34;Move disk\u0026#34;,n,\u0026#34;from source\u0026#34;,source,\u0026#34;to destination\u0026#34;,destination) TowerOfHanoi(n-1, auxiliary, destination, source) # Driver code n = 4 TowerOfHanoi(n,\u0026#39;A\u0026#39;,\u0026#39;B\u0026#39;,\u0026#39;C\u0026#39;) # A, C, B are the name of rods \u0026#39;\u0026#39;\u0026#39; Move disk 1 from source A to destination C Move disk 2 from source A to destination B Move disk 1 from source C to destination B Move disk 3 from source A to destination C Move disk 1 from source B to destination A Move disk 2 from source B to destination C Move disk 1 from source A to destination C Move disk 4 from source A to destination B Move disk 1 from source C to destination B Move disk 2 from source C to destination A Move disk 1 from source B to destination A Move disk 3 from source C to destination B Move disk 1 from source A to destination C Move disk 2 from source A to destination B Move disk 1 from source C to destination B \u0026#39;\u0026#39;\u0026#39;   Merge Sort 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49  def mergeSort(arr): if len(arr) \u0026gt; 1: # Finding the mid of the array mid = len(arr)//2 # Dividing the array elements into 2 halves L = arr[:mid] R = arr[mid:] # Sort mergeSort(L) mergeSort(R) i = j = k = 0 # Copy data to temp arrays L[] and R[] while i \u0026lt; len(L) and j \u0026lt; len(R): if L[i] \u0026lt; R[j]: arr[k] = L[i] i += 1 else: arr[k] = R[j] j += 1 k += 1 # Checking if any element was left while i \u0026lt; len(L): arr[k] = L[i] i += 1 k += 1 while j \u0026lt; len(R): arr[k] = R[j] j += 1 k += 1 # Code to print the list def printList(arr): for i in range(len(arr)): print(arr[i], end=\u0026#34; \u0026#34;) print() # Driver Code if __name__ == \u0026#39;__main__\u0026#39;: arr = [12, 11, 13, 5, 6, 7] print(\u0026#34;Given array is\u0026#34;, end=\u0026#34;\\n\u0026#34;) printList(arr) mergeSort(arr) print(\u0026#34;Sorted array is: \u0026#34;, end=\u0026#34;\\n\u0026#34;) printList(arr)    Reference  手把手带你刷Leetcode力扣 - 分治法 Divide \u0026amp; Conquer Programiz - Divide \u0026amp; Conquer GreekforGreek - Merge Sort GreekforGreek - Python Program for Tower of Hanoi   ","date":"2022-04-03T22:30:30+08:00","permalink":"https://tonyfpy.github.io/p/algorithm-topic-4-divide-conquer/","title":"[Algorithm] Topic 4: Divide \u0026 Conquer"},{"content":" Authored by Tony Feng\nCreated on April 2nd, 2022\nLast Modified on April 2nd, 2022\n Understanding Recursion Intro  Recursion is the process of defining a problem (or the solution to a problem) in terms of (a simpler version of) itself. Memoization could be used to save computational time.  Components of Recursion  Base Case  The point where you stop applying the recursive case   Recursive Steps  Divide the problem into one or more simpler or smaller parts of the problem; Call the function (recursively) on each part; Combine the solutions of the parts into a solution for the problem.    Characteristics  Advantages of Recursion  Recursive functions make the code look clean and elegant. A complex task can be broken down into simpler sub-problems using recursion. Sequence generation is easier with recursion than using some nested iteration.   Disadvantages of Recursion  Sometimes the logic behind recursion is hard to follow through. Recursive calls are expensive (inefficient) as they take up a lot of memory and time. Recursive functions are hard to debug.     Examples The Factorial of an Integer 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  term = [0 for i in range(10)] # Memoization # Fibonacci Series using memoized Recursion def fib(n): # base case if n \u0026lt;= 1: return n # if fib(n) has already been computed we do not do further  # recursive calls and hence reduce the number of repeated work; # else store the computed value of fib(n) in an array term at # index n if term[n] != 0: return term[n] else: term[n] = fib(n - 1) + fib(n - 2) return term[n]   Leetcode 509 Fibonacci Number 1 2 3 4 5 6 7 8  # Time: O(N) # Space: O(N) i.e. Recursive Stack class Solution: def fib(self, n: int) -\u0026gt; int: if n \u0026lt;= 1: return n return self.fib(n - 1) + self.fib(n - 2)   Leetcode 206 Reverse Linked List 1 2 3 4 5 6 7 8 9 10  class Solution: def reverseList(self, head: Optional[ListNode]) -\u0026gt; Optional[ListNode]: if not head or not head.next: return head node = self.reverseList(head.next) head.next.next = head head.next = None return node    Reference  手把手带你刷Leetcode力扣 - 递归 Recursion 手把手带你刷Leetcode力扣 - 力扣509 手把手带你刷Leetcode力扣 - 力扣206 Programiz - Python Recursion WTF is Memoization   ","date":"2022-04-02T23:49:58+08:00","permalink":"https://tonyfpy.github.io/p/algorithm-topic-3-recursion/","title":"[Algorithm] Topic 3: Recursion"},{"content":" Authored by Tony Feng\nCreated on April 1st, 2022\nLast Modified on April 1st, 2022\n Understanding Binary Search Intro  Binary search is often used to efficiently locate an item in a sorted sequence of items. It divides the search space in 2 after every comparison. Compared to linear search which requires O(N) running time, binary search only takes O(log N) where n is the size of the sequence.  Main Steps of the Algorithm  Pre-processing  Sort if collection is unsorted.   Binary Search  Using a loop or recursion to divide search space in half after each comparison.   Post-processing  Determine viable candidates in the remaining space    When Do We Use Binary Search?  The array is partially or fully sorted. The upper bound of time complexity is O(N) or O(log N).   Templates  There are many variants of binary search, such as [l, r), [l, r], (l, r], etc. We should be careful of loop condition, mid/left/right update and return value.\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  # The most common case class Solution: def binarySearch(self, nums, target): \u0026#34;\u0026#34;\u0026#34; :type nums: List[int] :type target: int :rtype: int \u0026#34;\u0026#34;\u0026#34; if len(nums) == 0: return -1 left, right = 0, len(nums) - 1 while left \u0026lt;= right: mid = left + (right - left) // 2 # Avoid overflow if nums[mid] \u0026lt; target: left = mid + 1 elif nums[mid] \u0026gt; target: right = mid - 1 else: return mid # End Condition: left \u0026gt; right return -1    Examples Leetcode 704 Binary Search 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  class Solution: def search(self, nums: List[int], target: int) -\u0026gt; int: if not nums or len(nums) == 0: return -1 l, r = 0, len(nums)-1 while l \u0026lt;= r: m = l + (r - l) // 2 if nums[m] \u0026gt; target: r = m - 1 elif nums[m] \u0026lt; target: l = m + 1 else: return m return -1   Leetcode 35 Search Insert Position 1 2 3 4 5 6 7 8 9 10 11 12  class Solution: def searchInsert(self, nums: List[int], target: int) -\u0026gt; int: l, r = 0, len(nums)-1 while l \u0026lt; r: # break if l == r mid = l + (r - l) // 2 if nums[mid] \u0026lt; target: l = mid + 1 elif nums[mid] \u0026gt; target: r = mid - 1 else: return mid return l if target \u0026lt;= nums[l] else l + 1   Leetcode 162 Find Peak Element 1 2 3 4 5 6 7 8 9 10  class Solution: def findPeakElement(self, nums: List[int]) -\u0026gt; int: l, r = 0, len(nums)-1 while l \u0026lt; r: m = l + (r - l) // 2 if nums[m] \u0026gt; nums[m+1]: r = m else: l = m + 1 return l   Leetcode 74 Search a 2D Matrix 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  class Solution: def searchMatrix(self, matrix: List[List[int]], target: int) -\u0026gt; bool: nums = [] for nums in matrix: if nums[-1] \u0026gt;= target: # Find which row the target is in l, r = 0, len(nums)-1 while l \u0026lt;= r: mid = l + (r - l) // 2 if nums[mid] \u0026lt; target: l = mid + 1 elif nums[mid] \u0026gt; target: r = mid - 1 else: return True return False    Reference  手把手带你刷Leetcode力扣 - 二分查找 Binary Search 手把手带你刷Leetcode力扣 - 力扣705 手把手带你刷Leetcode力扣 - 力扣35 手把手带你刷Leetcode力扣 - 力扣162 手把手带你刷Leetcode力扣 - 力扣74 Collection of Binary Search Templates   ","date":"2022-04-01T22:36:50+08:00","permalink":"https://tonyfpy.github.io/p/algorithm-topic-2-binary-search/","title":"[Algorithm] Topic 2: Binary Search"},{"content":" Authored by Tony Feng\nCreated on March 30th, 2022\nLast Modified on March 30th, 2022\n Understanding Two-pointer Algorithm Intro  The approach optimizes the runtime by utilizing some order (not necessarily sorting) of the data. It is generally applied on lists (arrays) and linked lists. Here, pointers represent either index or an iteration attribute like node’s Next.  Main Steps of the Algorithm  Pointer Initialization Pointer Movement Stop Condition  Categories  Old \u0026amp; New State Pointers Slow \u0026amp; Fast Pointers Left \u0026amp; Right Pointers Pointers from Two Sequences Sliding Window   Old \u0026amp; New State Pointers Template 1 2 3 4 5 6 7  class Solution: def old_new_state(self, arr): # initialize states old, new = default_val1, default_val2 for item in arr: # process current element with old state old, new = new, self.some_func(item, old)   Examples Leetcode 509 Fibonacci Number 1 2 3 4 5 6 7  # Each number is the sum of the two preceding ones, starting from 0 and 1. class Solution: def fibonacci(self, n: int) -\u0026gt; int: a, b = 0, 1 for i in range(n + 1): a, b = b, a + b return a   Leetcode 198 House Robber 1 2 3 4 5 6 7 8  # Determine the maximum amount of money you can steal tonight  # without robbing adjacent houses. class Solution: def rob(self, nums: \u0026#39;List[int]\u0026#39;) -\u0026gt; int: last, now = 0, 0 for i in nums: last, now = now, max(last + i, now) return now    Slow \u0026amp; Fast Pointers Template 1 2 3 4 5 6 7 8 9 10 11 12 13  class Solution: def slow_fast_runner(self, arr): # initialize slow runner slow = arr[0] # fast-runner grows each iteration generally for fast in range(arr): #slow-runner grows with some restrictions if self.slow_condition(slow): slow = slow.next # slow += 1 # process logic before or after pointers movement self.some_func(slow, fast)   Examples Leetcode 141 Linked List Cycle 1 2 3 4 5 6 7 8 9 10 11 12  class Solution: def hasCycle(self, head: Optional[ListNode]) -\u0026gt; bool: if not head or not head.next: return False slow, fast = head, head while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: return True return False   Leetcode 881 Boats to Save People 1 2 3 4 5 6 7 8 9 10 11  class Solution: def numRescueBoats(self, people: List[int], limit: int) -\u0026gt; int: people = sorted(people) i, j, res = 0, len(people)-1, 0 while i \u0026lt;= j: if people[i] + people[j] \u0026lt;= limit: i = i + 1 j = j - 1 res += 1 return res   Leetcode 26 Remove Duplicates from Sorted Array 1 2 3 4 5 6 7 8 9 10 11 12 13  # Given a sorted array nums, remove the duplicates in place such that  # each element appear only once and return the new length. class Solution: def removeDuplicates(self, nums: \u0026#39;List[int]\u0026#39;) -\u0026gt; int: if not nums: return 0 slow = 0 for fast in range(1, len(nums)): # if current element is not duplicate,  # slow runner grows one step and copys the current value if nums[slow] != nums[fast]: slow += 1 nums[slow] = nums[fast] return slow + 1    Left \u0026amp; Right Pointers Template 1 2 3 4 5 6 7 8 9 10 11 12  class Solution: def left_right_boundary(self, arr): left, right = 0, len(arr) - 1 while left \u0026lt; right: # left index moves when satisfy the condition if self.left_condition(left): left += 1 # right index move when satisfy the condition if self.right_condition(right): right -= 1 # process logic before or after pointers movement self.some_func(left, right)   Examples Leetcode 167 Two Sum II - Input Array Is Sorted 1 2 3 4 5 6 7 8 9 10 11 12 13  # Given an array of integers that is already sorted in ascending  # order, find two numbers such that they add up to a specific target number. class Solution: def twoSum(self, numbers: \u0026#39;List[int]\u0026#39;, target: \u0026#39;int\u0026#39;) -\u0026gt; \u0026#39;List[int]\u0026#39;: left, right = 0, len(numbers) - 1 while left \u0026lt; right: if numbers[left] + numbers[right] == target: return [left + 1, right + 1] if numbers[left] + numbers[right] \u0026lt; target: left += 1 else: right -= 1 return [0, 0]    Pointers from Two Sequences Template 1 2 3 4 5 6 7 8 9 10 11 12 13 14  class Solution: def pointers_from_two_seq(self, arr1, arr2): # init pointers p1, p2 = 0, 0 # or seq1[0], seq2[0] while p1 \u0026lt; len(arr1) and p2 \u0026lt; len(arr2): # or other condition # p1 index moves when satisfy the condition if self.p1_condition(p1): p1 += 1 # or p1 = next(seq1) # p2 index move when satisfy the condition if self.p2_condition(p2): p2 += 1 # or p2 = next(seq2) # process logic before or after pointers movement self.some_func(p1, p2)   Examples Leetcode 244 Shortest Word Distance II 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  # Design a class which receives a list of words in the constructor  # and implements a method that takes two words, word1 and word2, and  # returns the shortest distance between these two words in the list. class WordDistance: def __init__(self, words: \u0026#39;List[str]\u0026#39;): self.locations = defaultdict(list) # Prepare a mapping from a word to all it\u0026#39;s locations (indices). for i, w in enumerate(words): self.locations[w].append(i) def shortest(self, word1: str, word2: str) -\u0026gt; int: loc1, loc2 = self.locations[word1], self.locations[word2] l1, l2 = 0, 0 min_diff = float(\u0026#34;inf\u0026#34;) # Until the shorter of the two lists is processed while l1 \u0026lt; len(loc1) and l2 \u0026lt; len(loc2): min_diff = min(min_diff, abs(loc1[l1] - loc2[l2])) if loc1[l1] \u0026lt; loc2[l2]: l1 += 1 else: l2 += 1 return min_diff    Sliding Window  There are two types of window\n  The fixed size window can be used for problem where you want to determine whether given string contain a specific substring.\n  The dynamic one can be used to find the longest or shortest substring of the given string.\n   Template 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  class Solution: def sliding_window(self, arr): start, end = 0, 0 while end \u0026lt; len(arr): # end pointer grows in the outer loop end += 1 # start pointer grows with some restrict while self.start_condition(start): # process logic before pointers movement self.some_func(start, end) # start grows in the inner loop start += 1 # or process logic after pointers movement self.some_func(start, end)   Examples Leetcode 209 Minimum Size Subarray Sum 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  # Given an array of positive integers nums and a positive integer  # target, return the minimal length of a contiguous subarray of  # which the sum is greater than or equal to target. class Solution: def minSubArrayLen(self, target: int, nums: List[int]) -\u0026gt; int: if not nums or len(nums) == 0: return 0 l, r = 0, 0 res = len(nums) + 1 add = 0 while r \u0026lt; len(nums): add += nums[r] r += 1 # Upsizing the window while add \u0026gt;= target: # Downsizing the window iteratively res = min(res, r - l) add -= nums[l] l += 1 return res if res != len(nums) + 1 else 0   Leetcode 1456 Maximum Number of Vowels in a Substring of Given Length 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  # Given a string s and an integer k, return the maximum number of vowel  # letters in any substring of s with length k. class Solution: def maxVowels(self, s: str, k: int) -\u0026gt; int: if not s or len(s) == 0 or len(s) \u0026lt; k: return 0 vl = set([\u0026#39;a\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;i\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;u\u0026#39;]) # Quick for search i, j = 0, 0 res, tmp = 0, 0 while j \u0026lt; len(s): if j - i \u0026lt; k: # Get the number of vowel letters in the first sliding window if s[j] in vl: tmp += 1 res = tmp j += 1 else: # Pop the first item if s[i] in vl: tmp -= 1 i += 1 # Add the next item if s[j] in vl: tmp += 1 res = max(tmp, res) j += 1 return res    Reference  手把手带你刷Leetcode力扣 - 双指针 Two Pointers 手把手带你刷Leetcode力扣 - 力扣141 手把手带你刷Leetcode力扣 - 力扣881 手把手带你刷Leetcode力扣 - 滑动窗口 Sliding Window 手把手带你刷Leetcode力扣 - 力扣209 手把手带你刷Leetcode力扣 - 力扣1456 Two Pointers Approach — Python Code Algorithm Templates: Two Pointers - Part 1 Algorithm Templates: Two Pointers - Part 2 Algorithm Templates: Two Pointers - Part 3 Effective LeetCode: Understanding the Sliding Window Pattern   ","date":"2022-03-30T22:59:15+08:00","permalink":"https://tonyfpy.github.io/p/algorithm-topic-1-two-pointers/","title":"[Algorithm] Topic 1: Two Pointers"},{"content":" Authored by Tony Feng\nCreated on March 29th, 2022\nLast Modified on March 29th, 2022\n Understanding Graphs Main Concepts  A Graph is a non-linear data structure consisting of nodes and edges. The nodes are sometimes also referred to as vertices. The edges are lines or arcs that connect any two nodes in the graph. Representations of Graphs G(V,E)  A collection of vertices V A collection of edges E, represented as ordered pairs of vertices (p,q)    Graph Classifications  Directed Graphs Undirected Graphs Weighted Graphs  Graph Terminology  Adjacency  A vertex is said to be adjacent to another vertex if there is an edge connecting them.   Path  A sequence of edges that allows you to go from vertex A to vertex B is called a path.    Operations  Check if the element is present in the graph Graph Traversal Add elements(vertex, edges) to graph Finding the path from one vertex to another   Implementations  This part will be dicussed when solving the problem.\n  Reference  GreeksforGreeks - Graph Data Structure And Algorithms Graph Data Stucture 手把手带你刷Leetcode力扣 - 图 Graph   ","date":"2022-03-29T22:38:32+08:00","permalink":"https://tonyfpy.github.io/p/data-structure-topic-10-graph/","title":"[Data Structure] Topic 10: Graph"},{"content":" Authored by Tony Feng\nCreated on March 28th, 2022\nLast Modified on March 28th, 2022\n Understanding Heaps Main Concepts  Heaps are complete binary trees. Complete binary trees satisfy the following conditions:  All levels are filled, except the last. All the nodes are as far left as possible.   The root of every subtree should be the greatest or smallest element in the subtree, recursively.  Minheap: The root of every subtree is the smallest element. Maxheap: The root of every subtree is the largest element.   Heapify: From an array to a heap, the solution is unique and the time complexity is O(N). (Formal Proof)  Applications of Heaps  Priority Queues  The root of a heap always contains the maximum or the minimum value, based on the heap type. The element with the highest/lowest priority can be retrieved in O(1) time.   Statistics  If we want the kth smallest or largest element, we can pop the heap k times to retrieve them.   Graph Algorithms  e.g. Dijkstra’s algorithm, Prim’s algorithm.    Operations  Search  For the top of heap, it\u0026rsquo;s O(1) The rest are O(N)   Insert - O(log(N)) Delete - O(log(N))  Explanations     Set Implementation in Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  import heapq # Create a minheap minheap = [] heapq.heapify(minheap) # In Python, there is no maxheap. If maxheap is required,  # try to multiply each element with -1 and then heapify it. # In the operations, the value should be converted back. # Add elements heapq.heappush(minheap, 10) heapq.heappush(minheap, 8) heapq.heappush(minheap, 9) heapq.heappush(minheap, 2) heapq.heappush(minheap, 1) heapq.heappush(minheap, 11) # [1,2,9,10,8,11] # Peek print(minheap[0]) # Delete heapq.heappop(minheap) # Size len(minheap) # Iteration while len(minheap) != 0: print(heapq.heappop(minheap))    Set Implementation in Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  // Create PriorityQueue\u0026lt;Integer\u0026gt; minheap = new PriorityQueue\u0026lt;\u0026gt;(); PriorityQueue\u0026lt;Integer\u0026gt; maxheap = new PriorityQueue\u0026lt;\u0026gt;(Collections.reverseOrder()); // Add minheap.add(2); maxheap.add(3); // Peek int mi = minheap.peek(); int ma = maxheap.peek(); // Remove the top element int mi = minheap.poll(); int ma = maxheap.poll(); // Get the size of the heap int lenMin = minheap.size(); int lenMax = maxheap.size(); // Iteration while (!minheap.isEmpty()) { System.out.println(minheap.poll()); }    Reference  Using the Heap Data Structure in Python 堆删除操作逻辑 GreeksforGreeks - Time Complexity of building a heap 手把手带你刷Leetcode力扣 - 集合 Set 手把手带你刷Leetcode力扣 - Python3集合常用操作 手把手带你刷Leetcode力扣 - Java集合常用操作   ","date":"2022-03-28T22:38:21+08:00","permalink":"https://tonyfpy.github.io/p/data-structure-topic-9-heap/","title":"[Data Structure] Topic 9: Heap"},{"content":" Authored by Tony Feng\nCreated on March 27th, 2022\nLast Modified on March 28th, 2022\n Understanding Trees Main Concepts  A tree is non-linear and a hierarchical data structure. It consists of a collection of nodes such that each node of the tree stores a value and a list of references to their children. Different tree data structures allow quicker and easier access to the data as it is a non-linear data structure.  Tree Terminologies    Term Explanation     Node 1. A node is an entity that contains a key or value and pointers to its child nodes.  2. Root is the topmost node of a tree.  3. The last nodes of each path are called leaf nodes or external nodes that do not contain a link/pointer to child nodes.  4. The node having at least a child node is called an internal node.  5. The node which is a predecessor of a node is called the parent node of that node.  6. The node which is the immediate successor of a node is called the child node of that node.  7. Any predecessor nodes on the path of the root to that node are called Ancestors of that node.  8. Any successor node on the path from the leaf node to that node are the descendants of the node.  9. Children of the same parent node are called siblings.   Edge It is the link between any two nodes.   Depth of a Node The depth of a node is the number of edges from the node to the tree\u0026rsquo;s root node (from bottom to top).   Height of a Node 1. The number of edges on the longest path from that node to a leaf (from top to bottom).  2. The height of a Tree is the height of the root node or the depth of the deepest node.   Level of a node 1. The level of a node is defined by 1 + the number of connections between the node and the root.  2. The level of the root is 1.   Degree of a Node It is the total count of subtrees attached to that node.    Binary Trees  Classifications  Full/ proper/ strict Binary tree  It can be defined as the tree in which each node must contain 2 children except the leaf nodes.   Complete Binary tree  It is a tree in which all the nodes are completely filled except the last level. In the last level, all the nodes must be as left as possible.   Perfect Binary tree  A tree is a perfect binary tree if all the internal nodes have 2 children. All the leaf nodes are at the same level.   Degenerate Binary tree  It is a tree in which all the internal nodes have only one children.   Balanced Binary tree  The tree, also referred to as a height-balanced binary tree, is defined as a binary tree in which the height of the left and right subtree of any node differ by not more than 1.     Traverse  Preorder traverse  Visit root node Visit all the nodes in the left subtree Visit all the nodes in the right subtree   Inorder traverse  First, visit all the nodes in the left subtree Then the root node Visit all the nodes in the right subtree   Postorder traverse  Visit all the nodes in the left subtree Visit all the nodes in the right subtree Visit the root node       Set Implementation in Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179  # Binary search tree class binarySearchTree: def __init__(self,val=None): self.val = val self.left = None self.right = None def insert(self,val): # check if there is no root if (self.val == None): self.val = val # check where to insert else: # check for duplicate then stop and return if val == self.val: return \u0026#39;no duplicates allowed in binary search tree\u0026#39; # check if value to be inserted \u0026lt; currentNode\u0026#39;s value if (val \u0026lt; self.val): # check if there is a left node to currentNode if true then recurse if(self.left): self.left.insert(val) # insert where left of currentNode when currentNode.left=None else: self.left = binarySearchTree(val) # same steps as above here the condition we check is value to be inserted \u0026gt; currentNode\u0026#39;s value else: if(self.right): self.right.insert(val) else: self.right = binarySearchTree(val) def breadthFirstSearch(self): currentNode = self bfs_list = [] queue = [] queue.insert(0,currentNode) while(len(queue) \u0026gt; 0): currentNode = queue.pop() bfs_list.append(currentNode.val) if(currentNode.left): queue.insert(0,currentNode.left) if(currentNode.right): queue.insert(0,currentNode.right) return bfs_list # In order means first left child, then parent, at last right child def depthFirstSearch_INorder(self): return self.traverseInOrder([]) # Pre order means first parent, then left child, at last right child def depthFirstSearch_PREorder(self): return self.traversePreOrder([]) # Post order means first left child, then right child , at last parent def depthFirstSearch_POSTorder(self): return self.traversePostOrder([]) def traverseInOrder(self, lst): if (self.left): self.left.traverseInOrder(lst) lst.append(self.val) if (self.right): self.right.traverseInOrder(lst) return lst def traversePreOrder(self, lst): lst.append(self.val) if (self.left): self.left.traversePreOrder(lst) if (self.right): self.right.traversePreOrder(lst) return lst def traversePostOrder(self, lst): if (self.left): self.left.traversePostOrder(lst) if (self.right): self.right.traversePostOrder(lst) lst.append(self.val) return lst def findNodeAndItsParent(self,val, parent = None): # returning the node and its parent so we can delete the node and reconstruct the tree from its parent if val == self.val: return self, parent if (val \u0026lt; self.val): if (self.left): return self.left.findNodeAndItsParent(val, self) else: return \u0026#39;Not found\u0026#39; else: if (self.right): return self.right.findNodeAndItsParent(val, self) else: return \u0026#39;Not found\u0026#39; # deleteing a node means we have to rearrange some part of the tree def delete(self,val): # check if the value we want to delete is in the tree if(self.findNodeAndItsParent(val)==\u0026#39;Not found\u0026#39;): return \u0026#39;Node is not in tree\u0026#39; # we get the node we want to delete and its parent-node from findNodeAndItsParent method deleteing_node, parent_node = self.findNodeAndItsParent(val) # check how many children nodes does the node we are going to delete have by traversePreOrder from the deleteing_node nodes_effected = deleteing_node.traversePreOrder([]) # if len(nodes_effected)==1 means, the node to be deleted doesn\u0026#39;t have any children # so we can just check from its parent node the position(left or right) of node we want to delete # and point the position to \u0026#39;None\u0026#39; i.e node is deleted if (len(nodes_effected)==1): if (parent_node.left.val == deleteing_node.val) : parent_node.left = None else: parent_node.right = None return \u0026#39;Succesfully deleted\u0026#39; # if len(nodes_effected) \u0026gt; 1 which means the node we are going to delete has \u0026#39;children\u0026#39;, # so the tree must be rearranged from the deleteing_node else: # if the node we want to delete doesn\u0026#39;t have any parent means the node to be deleted is \u0026#39;root\u0026#39; node if (parent_node == None): nodes_effected.remove(deleteing_node.val) # make the \u0026#39;root\u0026#39; nodee i.e self value,left,right to None, # this means we need to implement a new tree again without the delted node self.left = None self.right = None self.val = None # construction of new tree for node in nodes_effected: self.insert(node) return \u0026#39;Succesfully deleted\u0026#39; # if the node we want to delete has a parent # traverse from parent_node nodes_effected = parent_node.traversePreOrder([]) # deleting the node if (parent_node.left == deleteing_node) : parent_node.left = None else: parent_node.right = None # removeing the parent_node, deleteing_node and inserting the nodes_effected in the tree nodes_effected.remove(deleteing_node.val) nodes_effected.remove(parent_node.val) for node in nodes_effected: self.insert(node) return \u0026#39;Successfully deleted\u0026#39; bst = binarySearchTree() bst.insert(7) bst.insert(4) bst.insert(9) bst.insert(0) bst.insert(5) bst.insert(8) bst.insert(13) # 7 # / \\ # / \\ # 4 9 # / \\ / \\ # 0 5 8 13 print(\u0026#39;IN order: \u0026#39;,bst.depthFirstSearch_INorder()) # useful in sorting the tree in ascending order print(\u0026#39;PRE order:\u0026#39; ,bst.depthFirstSearch_PREorder()) # pre order is useful in reconstructing a tree print(\u0026#39;POST order:\u0026#39;, bst.depthFirstSearch_POSTorder()) # useful in finding the leaf nodes print(bst.delete(5)) print(bst.delete(9)) print(bst.delete(7)) # after deleting print(\u0026#39;IN order: \u0026#39;,bst.depthFirstSearch_INorder()) \u0026#39;\u0026#39;\u0026#39; Output IN order: [0, 4, 5, 7, 8, 9, 13] PRE order: [7, 4, 0, 5, 9, 8, 13] POST order: [0, 5, 4, 8, 13, 9, 7] Successfully deleted Successfully deleted Successfully deleted IN order: [0, 4, 8, 13] \u0026#39;\u0026#39;\u0026#39;    Reference  GreeksforGreeks - Intro to Tree Data Structure Height, Depth and Level of a Tree Programiz - Balanced Binary Tree Binary tree and BinarySearch tree implementation in Python 手把手带你刷Leetcode力扣 - 树 Tree 手把手带你刷Leetcode力扣 - 树 Tree 补充   ","date":"2022-03-27T22:38:11+08:00","permalink":"https://tonyfpy.github.io/p/data-structure-topic-8-tree/","title":"[Data Structure] Topic 8: Tree"},{"content":" Authored by Tony Feng\nCreated on March 27th, 2022\nLast Modified on March 27th, 2022\n Understanding Sets Main Concepts  A Set is an unordered collection data type that is iterable, mutable and has no duplicate elements. The major advantage of using a set, as opposed to a list, is that it has a highly optimized method for checking whether a specific element is contained in the set or whether some elements are repeated. This is based on a data structure known as hash table. Since sets are unordered, we cannot access items using indexes.  Main Characteristics  Unordered Unchangeable Unindexed  Operations  Search  Collision - O(K) No Collision - O(1)   Insert - O(1)  Collision - O(K) No Collision - O(1)   Delete - O(1)  Collision - O(K) No Collision - O(1)     Set Implementation in Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  # Create a set s = set() # Add an element - O(1) s.add(2) s.add(3) s.add(1) # Remove an element - O(1) s.remove(2) # Check if the value exists - O(1) 1 in s # Get the length of the set len(s)    Set Implementation in Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  // Create HashSet\u0026lt;Integer, String\u0026gt; s = new HashSet\u0026lt;\u0026gt;(); // Add - O(1) s.add(2); s.add(3); s.add(1); // Remove an element - O(1) s.remove(1); // arg is the value  // Check if the value exists - O(1) Boolean check = s.contains(2); // Get the length of the hash table - O(1) int len = s.size()    Reference  GreeksforGreeks - Sets in Python 手把手带你刷Leetcode力扣 - 集合 Set 手把手带你刷Leetcode力扣 - Python3集合常用操作 手把手带你刷Leetcode力扣 - Java集合常用操作   ","date":"2022-03-27T22:38:02+08:00","permalink":"https://tonyfpy.github.io/p/data-structure-topic-7-set/","title":"[Data Structure] Topic 7: Set"},{"content":" Authored by Tony Feng\nCreated on March 26th, 2022\nLast Modified on March 26th, 2022\n Understanding Hash Tables Main Concepts  Hash Table stores data in an associative manner. In programming languages, each key is assigned to a memory address by a hash function. The key-value pair is stored in this memory address. Hashing is a technique to convert a range of key values into a range of indexes of an array. Collision occur when two pieces of data in a hash table share the same hash value. Collisions are pretty difficult to avoid and are bound to happen, so the key to a good hash function is collision resolution. (Linked list could be a good solution.)  Main Characteristics  In a hash table, data is stored using a key-value storage method. Access of data becomes very fast if we know the index of the desired data.  Operations  Search - O(1)  If hash collision happens, O(K), where K is number of collisions.   Insert - O(1) Delete - O(1)   Hash Table Implementation in Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  # Create a hash table by Dictionary D = {} # Add an element - O(1) D[1], D[2], D[3] = \u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;d\u0026#34; # Update an element - O(1) D[3] = \u0026#34;c\u0026#34; # Remove an element - O(1) D.pop(1) # arg is the key # del D[1] # Get the value - O(1) D[2] # Check if the key exists - O(1) b in D # Get the length of the hash table len(D) # Traverse my_dict={\u0026#39;Dave\u0026#39; : \u0026#39;001\u0026#39; , \u0026#39;Ava\u0026#39;: \u0026#39;002\u0026#39; , \u0026#39;Joe\u0026#39;: \u0026#39;003\u0026#39;} for k in my_dict: print(k) #prints the keys for v in my_dict.values(): print(v) #prints values for k,v in my_dict.items(): print(k, \u0026#34;:\u0026#34; , v) #prints keys and values    Hash Table Implementation in Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  // Create HashMap\u0026lt;Integer, String\u0026gt; m = new HashMap\u0026lt;\u0026gt;(); // Add - O(1) m.put(1, \u0026#34;alpha\u0026#34;); m.put(2, \u0026#34;b\u0026#34;); m.put(3, \u0026#34;c\u0026#34;); // Update an element - O(1) m.put(1, \u0026#34;a\u0026#34;); // Remove an element - O(1) m.remove(1); // arg is the key  // Get the value - O(1) String tmp = m.get(2); // arg is the key  // Check if the key exists - O(1) Boolean check = m.containsKey(2); // Get the length of the hash table int s = m.size()    Reference  手把手带你刷Leetcode力扣 - 哈希表 Hash Table 手把手带你刷Leetcode力扣 - Python3哈希表常用操作 手把手带你刷Leetcode力扣 - Java哈希表常用操作   ","date":"2022-03-26T22:37:51+08:00","permalink":"https://tonyfpy.github.io/p/data-structure-topic-6-hash-table/","title":"[Data Structure] Topic 6: Hash Table"},{"content":" Authored by Tony Feng\nCreated on March 24th, 2022\nLast Modified on March 25th, 2022\n Understanding Stacks Main Concepts  Stack is an abstract data structure that is similar to queue. Unlike queues, a stack is open at one end. First In Last Out (FILO) e.g. Back functionanlity of browsers  Operations  Access - O(1)  Access the top of the stack   Search - O(N) Insert - O(1)  A stack can only be inserted from the top.   Delete - O(1)  A stack can only be removed from the top.     Stack Implementation in Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  # Create stack = [] # Add an element - O(1) stack.append(1) stack.append(2) stack.append(3) # [1,2,3] # Get the top of the stack - O(1) top = stack[-1] # Remove the head of the stack - O(1) top = stack.pop() # Get the size of the stack - O(1) length = len(stack) # Traverse the stack - O(N) while len(stack) != 0: tmp = stack.pop() print(tmp)    Stack Implementation in Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  // Create Stack\u0026lt;Integer\u0026gt; s = new Stack\u0026lt;\u0026gt;(); // Add - O(1) s.push(1); s.push(2); s.push(3); // Get the head of the stack - O(1) int elem = s.peek(); // 1  // Remove the head of the stack - O(1) int id = s.pop(); // 1  // Get the size of the stack - O(1) int len = s.size() // Traverse the stack - O(N) while (!s.isEmpty()) { int tmp = s.pop() System.out.println(tmp) }    Reference  手把手带你刷Leetcode力扣 - 栈 Stack 手把手带你刷Leetcode力扣 - Python3栈常用操作 手把手带你刷Leetcode力扣 - Java栈常用操作   ","date":"2022-03-24T22:37:38+08:00","permalink":"https://tonyfpy.github.io/p/data-structure-topic-5-stack/","title":"[Data Structure] Topic 5: Stack"},{"content":" Authored by Tony Feng\nCreated on March 22nd, 2022\nLast Modified on March 23rd, 2022\n Understanding Queues Main Concepts  Queue is an abstract data structure that is similar to stacks. Unlike stacks, a queue is open at both ends. First In First Out (FIFO)  Different Types  Singly-ended Queue (All queues mentioned in this file are this type.) Doubly-ended Queue  Operations  Access - O(N) Search - O(N) Insert - O(1)  A queue can only be inserted from the rear.   Delete - O(1)  A queue can only be removed from the front.     Queue Implementation in Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  # Create queue = deque() # Add an element - O(1) queue.append(1) queue.append(2) queue.append(3) # [1,2,3] # Get the head of the queue - O(1) head = queue[0] # Remove the head of the queue - O(1) head = queue.popleft() # Get the size of the queue - O(1) length = len(queue) # Traverse the queue - O(N) while len(queue) != 0: tmp = queue.popleft() print(tmp)    Queue Implementation in Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  // Create Queue\u0026lt;Integer\u0026gt; q = new LinkedList\u0026lt;\u0026gt;(); // Add - O(1) q.add(1); q.add(2); q.add(3); // Get the head of the queue - O(1) int elem = q.peek(); // 1  // Remove the head of the queue - O(1) int id = q.poll(); // 1  // Get the size of the queue - O(1) int len = q.size() // Traverse the queue - O(N) while (!q.isEmpty()) { int tmp = q.poll() System.out.println(tmp) }    Reference  手把手带你刷Leetcode力扣 - 队列 Queue 手把手带你刷Leetcode力扣 - Python3队列常用操作 手把手带你刷Leetcode力扣 - Java队列常用操作   ","date":"2022-03-22T22:37:28+08:00","permalink":"https://tonyfpy.github.io/p/data-structure-topic-4-queue/","title":"[Data Structure] Topic 4: Queue"},{"content":" Authored by Tony Feng\nCreated on March 20th, 2022\nLast Modified on March 21st, 2022\n Understanding Linked Lists Main Concepts  Linked lists are an ordered collection of objects. While other lists use a contiguous memory block to store references to their data, linked lists store references as part of their elements. Node = Data + Next  A value A reference to the next node   The first node of a linked list is called Head. The last node must have its Next pointing to None.  Different Types  Singly Linked Lists (All linked lists mentioned in this file are this type.) Doubly Linked Lists Circular Linked Lists  Operations  Access - O(N) Search - O(N) Insert - O(1)  Commonly, a function of insertion contains traverse and add, which is O(N).   Delete - O(1)  Applications  Queues - FIFO Stacks - LIFO Graphs  Linked List V.S. Array     Linked List Arrays     Pros 1. Dynamic Size  2. Ease of insertion/deletion 1. Fast access to elements  2. Linear data of similar types could be stored   Cons 1. More memory needed  2. Random access is not allowed  3. Not cache friendly 1. Fixed size  2. Slow insertion/deletion  3. Waste of memory     Linked List Implementation in Python Using collections.deque in Python 1 2 3 4 5 6 7 8 9 10 11  from collections import deque queue = deque() queue.append(\u0026#34;Mary\u0026#34;) # O(1) queue.append(\u0026#34;John\u0026#34;) queue.append(\u0026#34;Susan\u0026#34;) # deque([\u0026#39;Mary\u0026#39;, \u0026#39;John\u0026#39;, \u0026#39;Susan\u0026#39;]) queue.popleft() # deque([\u0026#39;John\u0026#39;, \u0026#39;Susan\u0026#39;]) history = deque() history.appendleft(1) history.appendleft(2) history.appendleft(3) # deque([3,2,1])   Creating a linked list from scratch in Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89  \u0026#39;\u0026#39;\u0026#39; def __init__(self, nodes=None): self.head = None if nodes is not None: node = Node(data=nodes.pop(0)) self.head = node for elem in nodes: node.next = Node(data=elem) node = node.next \u0026#39;\u0026#39;\u0026#39; class Node: def __init__(self, data): self.data = data self.next = None def __repr__(self): return self.data class LinkedList: def __init__(self): self.head = None def __repr__(self): # representation node = self.head nodes = [] while node is not None: nodes.append(node.data) node = node.next nodes.append(\u0026#34;None\u0026#34;) return \u0026#34; -\u0026gt; \u0026#34;.join(nodes) def add_first(self, node): # insert at the front node.next = self.head self.head = node def add_last(self, node): # append at the end if self.head is None: self.head = node return for current_node in self: pass current_node.next = node def add_after(self, target_node_data, new_node): # insert after an existing node if self.head is None: raise Exception(\u0026#34;List is empty\u0026#34;) for node in self: if node.data == target_node_data: new_node.next = node.next node.next = new_node return raise Exception(\u0026#34;Node with data \u0026#39;%s\u0026#39; not found\u0026#34; % target_node_data) def add_before(self, target_node_data, new_node): # insert before an existing node if self.head is None: raise Exception(\u0026#34;List is empty\u0026#34;) if self.head.data == target_node_data: return self.add_first(new_node) prev_node = self.head for node in self: if node.data == target_node_data: prev_node.next = new_node new_node.next = node return prev_node = node raise Exception(\u0026#34;Node with data \u0026#39;%s\u0026#39; not found\u0026#34; % target_node_data) def remove_node(self, target_node_data): # remove if self.head is None: raise Exception(\u0026#34;List is empty\u0026#34;) if self.head.data == target_node_data: self.head = self.head.next return previous_node = self.head for node in self: if node.data == target_node_data: previous_node.next = node.next return previous_node = node raise Exception(\u0026#34;Node with data \u0026#39;%s\u0026#39; not found\u0026#34; % target_node_data)    Linked List Implementation in Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  // Create LinkedList\u0026lt;Integer\u0026gt; ll = new LinkedList\u0026lt;\u0026gt;(); // Add - O(1) ll.add(1); ll.add(2); ll.add(3); // Access - O(N) int elem = ll.get(0); // 1  // Search - O(N) int id = ll.indexOf(3); // 2  // Update - O(N) ll.set(2,100); // [1,2,100]  // Remove - O(N) ll.remove(1); // [1,100]  // size int length = ll.size();    Reference  Linked Lists in Python: An Introduction 手把手带你刷Leetcode力扣 - 链表Linked List 手把手带你刷Leetcode力扣 - Python3链表常用操作 手把手带你刷Leetcode力扣 - Java链表常用操作   ","date":"2022-03-20T22:36:59+08:00","permalink":"https://tonyfpy.github.io/p/data-structure-topic-3-linked-list/","title":"[Data Structure] Topic 3: Linked List"},{"content":" Authored by Tony Feng\nCreated on March 18th, 2022\nLast Modified on March 19th, 2022\n Understanding Arrays Def  An array is a collection of data elements with the same type stored at contiguous memory locations. Index \u0026amp; Elements Note: This is different from the List type in Python  Common Operations  Access - O(1) Search - O(n) Insert - O(n) Delete - O(n)  Characteristics  Easy to read Hard to write   Array Implementation in Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  # Create an array arr = [] # Add an element - O(1) if the position is empty;  # O(N) if the length of the array changes. arr.append(1) arr.append(2) arr.append(3) # [1,2,3] # Insert an element - O(N) arr.insert(2, 100) # [1,2,100,3] # Remove an element arr.remove(100) # case 1: [1,2,3] - O(N), where arg is an element arr.pop(1) # case 2: [1,3] - O(N), where arg is an index arr.pop() # case 3: [1] - O(1), where the last element is removed # Traverse an array - O(N) for item in arr: print(item) for id, item in enumerate(arr): print(\u0026#34;Index at \u0026#34;, id, \u0026#34; is: \u0026#34;, item) for id in range(0, len(arr)): print(arr[id]) # Find an element - O(N) arr[1,2,3] id = arr.index(3) # 2, where arg is an element # Sort an array - O(N*log(N)) arr = [3,1,2] arr.sort() # [1,2,3] a.sort(reverse=True) # [3,2,1]    Array Implementation in Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46  // Create an array int[] a = {1,2,3}; int[] b = new int[]{1,2,3}; int[] c = new int[3]; // The initilization is [0,0,0] for (int i=0, i \u0026lt; c.length; i++){ c[i] = i + 1; } ArrayList\u0026lt;Integer\u0026gt; d = new ArrayList\u0026lt;\u0026gt;(); // Integer is an object for (int i = 0; i \u0026lt; 3; i++){ d.add(i+1) } // Add an element // An addiotnal empty array should be declared for a, b, c. // For ArrayList, the length of the array could be ignored in declaration. d.add(100); // [1,2,3,100] - O(1) d.add(3, 99); // [1,2,3,99,100] - O(N), i.e. 100 should be moved backwards for 99.  // Access an element - O(1) int item1 = a[1]; int item2 = d.get(1); // Update an element - O(1) a[1] = 0; // [1,0,3,100] d.set(1, 0); // [1,0,3,99,100], where the 1st arg is the index; the 2nd arg is the new value.  // Remove an element for ArrayList - O(N) d.remove(99) // [1,2,3,100]  // Get the length of array - O(1), i.e. there is a cnt var inside int aLen = a.length; // String.length(), Array.length int dLen = d.size(); // Traverse an array - O(N) for (int i = 0; i \u0026lt; a.length; i++) { ... } for (int i = 0; i \u0026lt; d.size(); i++) { ... } // Find an element - O(N) // Loop should be adopted for a, b, c; // For ArrayList, use .contains() boolean is100 = d.contains(100) // Sort an array - O(N*log(N)) Array.sort(a) // Read from the last to reverse the array Collections.sort(d) Collections.sort(d, Collections.reverseOrder())    Reference  手把手带你刷Leetcode力扣 - 数组Array 手把手带你刷Leetcode力扣 - Python3数组常用操作 手把手带你刷Leetcode力扣 - Java数组常用操作   ","date":"2022-03-18T22:36:44+08:00","permalink":"https://tonyfpy.github.io/p/data-structure-topic-2-array/","title":"[Data Structure] Topic 2: Array"},{"content":" Authored by Tony Feng\nCreated on March 17th, 2022\nLast Modified on March 18th, 2022\n Time Complexity Def  The efficiency of the algorithm The relationship between the algorithm\u0026rsquo;s input and its execution time  Common Cases  O(1)  1 2 3 4  def O1(num): i = num j = num * 2 return i + j    O(n)  1 2 3 4 5  def ON(num): total = 0 for i in range(0, num): total += i return total    O(m+n)  1 2 3 4 5 6 7  def OMN(num1, num2): total = 0 for i in range(0, num1): total += 1 for j in range(0, num2): total += 1 return total    O(log(n))  1 2 3 4 5  def OlogN(num): i = 1 while i \u0026lt; num: i = i * 2 return i    O(n*log(n))  1 2 3 4 5 6 7 8  def ONlogN(num1, num2): total = 0 tmp = 1 for i in range(0, num1): while tmp \u0026lt; num2: total = i + tmp tmp = tmp * 2 return total    O(n2)  1 2 3 4 5 6  def ON2(num): total = 0 for i in range(0, num): for j in range(0, num): total += 1 return total   Comparison  O(1) \u0026lt; O(log(n)) \u0026lt; O(n) \u0026lt; O(n*log(n)) \u0026lt; O(n2) \u0026lt; O(2n) \u0026lt; O(n!)   Space Complexity Def  The relationship between the algorithm\u0026rsquo;s input and its memory space needed  Common Cases  O(1)  1 2 3 4 5 6  # total is a int variable with a 4-bytes memory def O1(num): total = 0 for i in range(0, num): total += i return total    O(n)  1 2 3 4 5 6  # nodes is a list whose memory depends on the input def On(nums): nodes = [] for num in nums: nodes.append(num) return nodes   Analysis Approches   Check the variable\n  If the variable varies in response to the input, e.g. array, linked list, hash map, etc., the space complexity may be O(n), O(n2) \u0026hellip;\n  If not, it is O(1)\n  Determine the space complexity case-by-case.\n  Be careful with the recursion. Info in each level are stored on a recursive stack.\n   Summary  There is a trade-off between time and space. Time should be considered in the first place.   Reference  手把手带你刷Leetcode力扣 - 算法的时间复杂度 手把手带你刷Leetcode力扣 - 算法的空间复杂度   ","date":"2022-03-17T22:26:52+08:00","permalink":"https://tonyfpy.github.io/p/data-structure-topic-1-time-and-space-complexity/","title":"[Data Structure] Topic 1: Time and Space Complexity"}]