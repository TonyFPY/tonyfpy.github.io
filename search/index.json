[{"content":" Authored by Tony Feng\nCreated on Feb 14th, 2022\nLast Modified on Aug 30th, 2022\n Content          Reference  树莓派教程第一课 树莓派简介 十分钟玩转系列入门篇 Mac 电脑安装putty PuTTY SSH client for Mac OSX - download and tutorial 树莓派 40Pin 引脚对照表   ","date":"2022-08-30T20:11:53-04:00","permalink":"https://tonyfpy.github.io/p/raspberry-pi-tutorial-for-beginners/","title":"[Raspberry Pi] Tutorial for Beginners"},{"content":" Authored by Tony Feng\nCreated on Feb 14th, 2022\nLast Modified on Aug 29th, 2022\n Content         Reference  Learn Swift For iOS Development    ","date":"2022-08-29T22:51:41-04:00","permalink":"https://tonyfpy.github.io/p/ios-dev-tutorial-for-beginners/","title":"[iOS Dev] Tutorial for Beginners"},{"content":" Authored by Tony Feng\nCreated on Feb 23th, 2022\nLast Modified on Aug 28th, 2022\n Content     Reference  Online Kalmman Filter Tutorial 目标追踪—计算机博士精讲卡尔曼滤波算法教程卡尔曼滤波   ","date":"2022-08-28T22:57:10-04:00","permalink":"https://tonyfpy.github.io/p/an-intro-to-kalman-filter/","title":"An Intro to Kalman Filter"},{"content":" Authored by Tony Feng\nCreated on Aug 26th, 2022\nLast Modified on Aug 27th, 2022\n Intro Today is my BIRTHDAY!!! Everything has been set up since I arrived in the US. From now on, I am going to spend more time on seeking the 2023 summer internship opportunities. Leetcode provides an official curated list of Top classic interview questions to help us practice, so I decide to focus on it in the following days. Let\u0026rsquo;s GO GO GO!\nTable of Questions    ID Question Level Update Date Count     001 Two Sum Easy 08-26-2022 1   002 Add Two Numbers Medium 08-26-2022 1   003 Longest Substring W/O Repeating Characters Medium 08-27-2022 1   004 Median of Two Sorted Arrays Hard 08-28-2022 1   005 Longest Palindromic Substring Medium 08-29-2022 1   007 Reverse Integer Medium 08-30-2022 1   008 String to Integer (atoi) Medium 08-30-2022 1   010 Regular Expression Matching Hard 08-30-2022 1   011 Container With Most Water Medium 08-30-2022 1   013 Roman to Integer Easy 08-30-2022 1   014 Longest Common Prefix Easy 08-30-2022 1   015 3Sum Medium 08-31-2022 1   017 Letter Combinations of a Phone # Medium 08-31-2022 1     ","date":"2022-08-26T16:47:17-04:00","permalink":"https://tonyfpy.github.io/p/leetcode-top-interview-questions/","title":"[Leetcode] Top Interview Questions"},{"content":" Authored by Tony Feng\nCreated on May 18th, 2022\nLast Modified on May 19th, 2022\n Intro K-nearest neighbors (KNN) is a simple, easy to understand machine learning algorithms. It examines the labels of a chosen number of data points surrounding a target data point, in order to make a prediction about the class that the data point falls into.\nIt is a type of supervised learning algorithm used for both regression and classification. 1) In classification, it tries to predict the class for the test data by a majority vote from K amount of neighbours. 2) In the case of regression, the prediction is the mean of the K selected training points.\n Characteristics Non-parametic KNN is non-parametric, which means there is no assumption for underlying data distribution (i.e. the model structure is determined from the dataset).\nLazy It is called Lazy algorithm because it does not need any training data points for model generation. All training data is used in the testing phase. This makes training faster, but making the testing phase slower and costlier.\nSimilarity Measure KNN stores all the available cases and predicts the new data based on a similarity measure.\n KNN Details Steps  Choosing a K and a distance metric Calculating the distance between a test example and each training examples Sorting the calculated distances Returning a prediction  Classification: Assigning the most frequent label of the top K neighbors Regression: Outputing the mean (average) of K-nearest neighbours    K Selection There are no pre-defined statistical methods to find the most favorable value of K. Sometimes, we may apply a domain knowledge to select a K. Additionally, we can derive a plot between error rate and K denoting values in a defined range.\nA smaller K will lead to overfitting, while a larger K results in smooth decision boundaries or underfitting.\nIn some cases, the algorithm faces a dilemma in majority vote. One solution, which will be discussed later, is to change to another decision rule. Besides, we can consider the parity of the number of classes and the value of K.\n If the number of classes is even, then K should be odd; If the number of classed is odd, then K should be even.  Distance Metric There are various methods for calculating this distance, of which the most commonly known methods are Euclidian, Manhattan (for continuous variables) and Hamming distance (for categorical variables).\nEuclidean Distance\n$$ ED = \\sqrt{\\sum_{i=1}^{k}(x_{i}-y_{i})^{2}} $$\nManhattan Distance\n$$ MD = \\sum_{i=1}^{k}|x_{i}-y_{i}| $$\nHamming Distance\n$$ HD = \\sum_{i=1}^{k} M_i $$\n, where $ M_i = 0 $ if $ x_i = y_i $, else $ M_i = 1 $.\nDecision Rules When combining the class labels, the simplest method is to take the majority vote, but this can be a problem if the nearest neighbors vary widely in their distance and the closest neighbors more reliably indicate the class of the object.\nTo overcome the issue, we can assign weights to the nearest k points . The intuition behind weighted KNN is to give more weight to the points which are nearby and less weight to the points which are farther away.\n Evaluation Pros  KNN is straightforward and easy to implement. No \u0026ldquo;training\u0026rdquo; process are needed in the traditional sense. KNN doesn’t function with emphasis on assumptions. KNN can quickly adapt to new data. This algorithm can be used for both regression and classification.  Cons  KNN algorithm is computationally expensive and slow. It needs a large memory storage. The efficiency of KNN is inversely proportional to the number of features. It is highly susceptible to the curse of dimensionality It cannot function properly with missing values. Outliers are especially impactful for KNN.   Referrence  K-Nearest Neighbor - Medium K-Nearest Neighbor(KNN) Algorithm for Machine Learning Intro to K-Nearest Neighbours (KNN) — Machine Learning 101 K-Nearest Neighbors (KNN) Algorithm What is a KNN (K-Nearest Neighbors)? What is distance weighted KNN?   ","date":"2022-05-18T22:45:07+08:00","permalink":"https://tonyfpy.github.io/p/machine-learning-topic-4-k-nearest-neighbours/","title":"[Machine Learning] Topic 4: K-Nearest Neighbours"},{"content":" Authored by Tony Feng\nCreated on May 16th, 2022\nLast Modified on June 8th, 2022\n Intro It\u0026rsquo;s been a month since I started to practice coding on Leetcode. I selected \u0026ldquo;剑指Offer\u0026rdquo; from the question libarary and followed the given daily plan to practice, hoping to gain familiarity with the problem-solving patterns. After the first-round coding, it is still hard for me to digest all the knowledge points, and I found it necessary to review them to consolidate my coding skills. Therefore, I\u0026rsquo;ve created a table to record my daily review routine.\nTable of Questions  There are 38 easy-level, 31 medium-level, 6 hard-level problems in the book.\n    ID Question Level Tags Review Date Count     01 用两个栈实现队列 Easy Stack \u0026amp; Queue 05-16-2022 1   02 包含min函数的栈 Easy Stack \u0026amp; Queue 05-16-2022 2   03 从尾到头打印链表 Easy Linked List 05-16-2022 1   04 反转链表 Easy Linked List 05-17-2022 2   05 复杂链表的复制 Medium Linked List 05-17-2022 2   06 替换空格 Easy String 05-17-2022 1   07 左旋转字符串 II Easy String 05-18-2022 1   08 数组中重复的数字 Easy Search 05-18-2022 1   09 在排序数组中查找数字 I Easy Search 05-18-2022 2   10 0～n-1中缺失的数字 Easy Search 05-18-2022 2   11 二维数组中的查找 Medium Search 05-19-2022 1   12 旋转数组的最小数字 Easy Search 05-19-2022 1   13 第一个只出现一次的字符 Easy Search 05-19-2022 1   14 从上到下打印二叉树 I Medium Tree/BFS 05-20-2022 1   15 从上到下打印二叉树 II Easy Tree/BFS 05-20-2022 1   16 从上到下打印二叉树 III Medium Tree/BFS 05-20-2022 1   17 树的子结构 Medium Tree 05-20-2022 2   18 二叉树的镜像 Easy Tree 05-20-2022 1   19 对称的二叉树 Easy Tree 05-20-2022 2   20 斐波那契数列 Easy DP 05-21-2022 1   21 青蛙跳台阶问题 Easy DP 05-21-2022 1   22 股票的最大利润 Medium DP 05-21-2022 1   23 连续子数组的最大和 Easy DP 05-21-2022 1   24 礼物的最大价值 Medium DP 05-21-2022 1   25 最长不含重复字符的子串 Medium DP 05-23-2022 2   26 把数字翻译成字符串 Medium DP 05-23-2022 2   27 删除链表的节点 Easy Linked List 05-22-2022 1   28 链表中倒数第k个节点 Easy Linked List 05-23-2022 1   29 合并两个排序的链表 Easy Linked List 05-23-2022 1   30 两个链表的第一个公共节点 Easy Linked List 05-23-2022 2   31 根据奇偶性调整数组顺序 Easy Two Pointers 05-23-2022 2   32 和为s的两个数字 Easy Two Pointers 05-23-2022 2   33 翻转单词顺序 Easy String 05-23-2022 1   34 机器人的运动范围 Medium BFS/DFS 05-24-2022 1   35 矩阵中的路径 Medium DFS 05-24-2022 2   36 二叉搜索树的第k大节点 Easy Tree 05-24-2022 1   37 二叉树中和为某一值的路径 Medium Backtracking 05-25-2022 1   38 二叉搜索树与双向链表 Medium Backtracking 05-25-2022 2   39 扑克牌中的顺子 Easy Sort 05-25-2022 1   40 把数组排成最小的数 Medium Sort 05-25-2022 2   41 数据流中的中位数 Hard Heap 05-26-2022 2   42 最小的k个数 Easy Sort 05-26-2022 2   43 二叉树的深度 Easy Tree/Recursion 05-26-2022 1   44 平衡二叉树 Easy Tree/Recursion 05-26-2022 2   45 求1+2+…+n Medium Bit Operation 05-27-2022 2   46 二叉搜索树的最近公共祖先 Easy Tree/Recursion 05-27-2022 1   47 二叉树的最近公共祖先 Easy Tree/Recursion 05-27-2022 1   48 重建二叉树 Medium Tree/Recursion 05-28-2022 1   49 数值的整数次方 Medium Recursion 05-28-2022 2   50 二叉搜索树的后序遍历序列 Medium Tree/Recursion 05-28-2022 2   51 二进制中1的个数 Easy Bit Operation 05-28-2022 2   52 不用加减乘除做加法 Easy Bit Operation 05-28-2022 2   53 数组中数字出现的次数 I Medium Bit Operation 05-29-2022 2   54 数组中数字出现的次数 II Medium Bit Operation 05-29-2022 2   55 构建乘积数组 Medium Mathematics 05-29-2022 1   56 数组中的众数 Easy Mathematics 05-29-2022 2   57 剪绳子 I Medium Mathematics 05-29-2022 2   58 和为s的连续正数序列 II Easy Mathematics 05-30-2022 2   59 圆圈中最后剩下的数字 Easy Mathematics 05-30-2022 2   60 顺时针打印矩阵 Easy Simulation 05-30-2022 2   61 栈的压入、弹出序列 Medium Simulation 05-30-2022 2   62 把字符串转换成整数 Medium String 05-31-2022 2   63 表示数值的字符串 Medium String 06-02-2022 2   64 滑动窗口的最大值 I Hard Stack \u0026amp; Queue 06-03-2022 2   65 队列的最大值 II Medium Stack \u0026amp; Queue 06-04-2022 2   66 序列化二叉树 Hard Backtracking 06-05-2022 2   67 字符串的排列 Medium Backtracking 06-05-2022 2   68 丑数 Medium DP 06-06-2022 2   69 正则表达式匹配 Hard DP 06-07-2022 2   70 n个骰子的点数 Medium DP 06-07-2022 2   71 打印从1到最大的n位数 Easy DFS 06-07-2022 2   72 数组中的逆序对 Hard Recursion 06-08-2022 2   73 剪绳子 II Medium Mathematics 06-08-2022 2   74 1～n 整数中 1 出现的次数 Hard Mathematics 06-08-2022 2   75 数字序列中某一位的数字 Medium Mathematics 06-08-2022 2     ","date":"2022-05-16T10:45:51+08:00","permalink":"https://tonyfpy.github.io/p/%E5%89%91%E6%8C%87offer-review/","title":"[剑指Offer] Review"},{"content":" Authored by Tony Feng\nCreated on May 11th, 2022\nLast Modified on May 11th, 2022\n Task 1 - Q14,II. 剪绳子 II Question 给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n\u0026gt;1并且m\u0026gt;1），每段绳子的长度记为 k[0],k[1]...k[m-1] 。请问 k[0]*k[1]*...*k[m-1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。其中，2 \u0026lt;= n \u0026lt;= 58。 答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。\nSolution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  class Solution: # Quick Power def cuttingRope(self, n: int) -\u0026gt; int: if n \u0026lt;= 3: return n - 1 a, b = n // 3 - 1, n % 3 x, p, rem = 3, 1000000007, 1 while a \u0026gt; 0: if a % 2 == 1: rem = (rem * x) % p x = (x ** 2) % p a = a // 2 if b == 0: rem = (rem * 3) % p # 3^(a+1) % p elif b == 1: rem = (rem * 2 * 2) % p # 3^a * 4 % p else: rem = (rem * 3 * 2) % p # 3^(a+1) * 2 % p return rem   Explanation  Mathematical Theory  When the length sub-line is 3, the product reaches maximum. (Q14,I. 剪绳子 I) Remainder Operation (x \u0026lt; p, according to the question) $$ x^{a} \\odot p = [(x^{a-1} \\odot p)(x \\odot p)] \\odot p=[(x^{a-1} \\odot p) x] \\odot p $$ Exponentiation by Squaring  a is even: $ x^{a} \\odot p = (x^{2} \\odot p)^{a // 2} \\odot p$ a is odd : $ x^{a} \\odot p= {[(x \\odot p)(x^{a-1} \\odot p)] \\odot p=[x(x^{2} \\odot p)^{a // 2}] \\odot p} $     Time Complexity: O(log(N)) Space Complexity: O(1)   Task 2 - Q43. 1～n 整数中 1 出现的次数 Question 输入一个整数 n ，求1～n这n个整数的十进制表示中1出现的次数。例如，输入12，1～12这些整数中包含1 的数字有1、10、11和12，1一共出现了5次。\nSolution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  class Solution: def countDigitOne(self, n: int) -\u0026gt; int: digit, res = 1, 0 high, cur, low = n // 10, n % 10, 0 while high != 0 or cur != 0: # Check if digit is over the highest place if cur == 0: res += high * digit elif cur == 1: res += high * digit + low + 1 else: res += (high + 1) * digit low += cur * digit # low for the next round cur = high % 10 # cur for the next round high //= 10 # high for the next round digit *= 10 # digit for the next round return res   Explanation  Time Complexity: O(log(N)) Space Complexity: O(1)   Task 3 - Q44. 数字序列中某一位的数字 Question 数字以0123456789101112131415…的格式序列化到一个字符序列中。在这个序列中，第5位（从下标0开始计数）是5，第13位是1，第19位是4，等等。请写一个函数，求任意第n位对应的数字。\nSolution 1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  class Solution: def findNthDigit(self, n: int) -\u0026gt; int: if n \u0026lt; 10: return n \u0026#39;\u0026#39;\u0026#39; The index begins from 0 and the first number is 0, so we can start from 1. 1 ~ 9: 9 numbers 10 ~ 99: 9 * 10 numbers 100 ~ 999: 9 * 100 numbers 1000 ~ 9999: 9 * 1000 numbers \u0026#39;\u0026#39;\u0026#39; digit, start, cnt = 1, 1, 9 while n \u0026gt; cnt: start *= 10 digit += 1 cnt += 9 * start * digit cnt -= 9 * start * digit # Find the lower bound rem = (n - cnt) % digit # Find which place the single number is in num = start - 1 + (n - cnt) // digit if rem == 0 else start + (n - cnt) // digit # Ceiling 向上取整 return int(str(num)[rem-1])   Solution 2 1 2 3 4 5 6 7 8 9 10 11  class Solution: def findNthDigit(self, n: int) -\u0026gt; int: digit, start, count = 1, 1, 9 while n \u0026gt; count: n -= count start *= 10 digit += 1 count = 9 * start * digit num = start + (n - 1) // digit return int(str(num)[(n - 1) % digit])   Explanation  Time Complexity: O(log(N)) Space Complexity: O(log(N))   ","date":"2022-05-12T16:22:20+08:00","permalink":"https://tonyfpy.github.io/p/%E5%89%91%E6%8C%87offer-day-31-mathematics/","title":"[剑指Offer] Day 31: Mathematics"},{"content":" Authored by Tony Feng\nCreated on May 11th, 2022\nLast Modified on May 14th, 2022\n Intro A decision tree is one of the supervised machine learning algorithms. Decision Tree algorithm belongs to the family of supervised learning algorithms. The goal is to create a model that predicts the value of a target variable by learning if-else conditions(decision rules) inferred from the data features.\nTypes of Decision Tree Decision Tree (DT) can be used for both regression and classification problems, but it is mostly used for classification problems. Based on the types of target variable, we have 1) categorical-variable DT, and 2) continuous-variable DT.\nNon-linearity Formally, a method is linear if, for an input $ x \\isin {\\R}^n $ (with interecept term $ x_0=1 $), it only produces hypothesis functions $ h $ of the form:\n$$ h(x) = \\theta^{T}x, \\theta \\isin {\\R}^n $$\nOtherwise, it is non-linear. Decision trees, on the other hand, can directly produce non-linear hypothesis functions without the need for first coming up with an appropriate feature mapping.\nRegion Selection In general, selecting optimal regions is intractable. Decision trees generate an approximate solution via greedy, top-down, recursive partitioning. Each node in the tree acts as a test case for some attribute, and each edge descending from that node corresponds to one of the possible answers to the test case.\nFormally, given a input space $ X $, a parent region $ R_p $, a feature index $ j $, and a threshold $ t \\isin {\\R}$, we obtain two child regions $R_1$ and $R_2$ as follows:\n$$ R_{1} = \\{X \\mid X_{j}\u0026lt;t, X \\in R_{p} \\} $$ $$ R_{2} = \\{X \\mid X_{j} \\geq t, X \\in R_{p} \\} $$\nWe can continue in such a manner until we a meet a pre-defined stop criterion, and then predict the majority class at each leaf node.\n Attribute Selective Measures An attribute selection measure (AMS) is a technique used in the data mining process for data reduction. It is a heuristic for choosing the splitting test that “best” separates a given data partition. The three main ASM techniques are 1) Information Gain, 2) Gain Ratio, and 3) Gini Index.\nInformation Gain Entropy is used to measure the level of impurity in a group of examples. This concept comes from informatin theory. The higher the entropy, the more the information content. Now, consider a dataset with $n$ classes, then\n$$ E = -\\sum_{i=1}^{n} p_{i} \\log_{2} (p_{i}) $$\n, where $ p_i $ is the probability of randomly selecting an example in class $i$.\nWe can define information gain (IG) as a measure of how much information a feature provides about a class. It is the expected reduction in entropy caused by partitioning the examples according to a given attribute. Given a collection of dataset $ S $, we can calculate the $IG(S, A)$ of an attribute $A$ as:\n$$ IG(S, A) = E(S) - \\sum_{v \\in V} \\frac{|S_{v}|}{|S|} E(S_{v}) $$\n, where $V$ is all possible values for attribute $A$ and $S_{v}$ is the subset of $S$ for which attribute $A$ has value $v$.\nGain Ratio Gain Ratio or Uncertainty Coefficient is used to normalize the information gain of an attribute against how much entropy that attribute has. It attempts to lessen the bias of Information Gain on highly branched predictors by introducing a normalizing term called the Intrinsic Information (II).\n$$ II(S, A) = - \\sum_{v \\in V(A)} \\frac{|S_{v}|}{|S|} \\log_2 \\frac{|s_{v}|}{|S|} $$\nFormula of Gain Ration is given by\n$$ GR(S, A) = \\frac{IG(S, A)}{II(S, A)} $$\nFrom this formula, we can see that, with less value in attribute $ A $, $ II(S, A)$ is smaller and thus purity is higher. Informally, the formula of Intrinsic Information is the same as that of Entropy, both of which means the purity of attribute $ A $.\nGini Index Gini Index, also called Gini Impurity, measures the degree or probability of a particular variable being wrongly classified when it is randomly chosen. If we have $C$ total classes and $p_i$ is the probability of picking a datapoint with class $i$, then the Gini Impurity is calculated as\n$$ GI=\\sum_{i=1}^{C} p_i(1-p_i) = 1 - \\sum_{i=1}^{C} p_i^{2}$$\nFor a data sample $ S $, we have an attribute $ A $ with a group of values $V$. Therefore,\n$$ GI(S, A) = \\sum_{v \\in V} \\frac{|S_{v}|}{|S|} GI(S_{v}) $$\nThe Gini Index varies between $0$ and $1$, where $0$ represents purity of the classification and $1$ denotes random distribution of elements among various classes. A Gini Index of $0.5$ shows that there is equal distribution of elements across some classes.\n Feature Selection Algorithms ID3 The ID3 algorithm builds decision trees using a top-down greedy search approach through the space of possible branches with no backtracking.\nSteps of ID3\n Begin with the original datset as the root node and calculte its entropy. For each attribute/feature:  Calculate entropy for all its categorical values. Calculate information gain for the feature.   Find the feature with maximum information gain and split to produce subsets. Continues to recur on each subset until we get the desired tree.  Disadvantages\n ID3 has no pruning strategy and is easy to overfit. The IG criterion has a preference for features with a number of possible values. It can only be used to deal with discretely distributed features; It does not consider missing values.  C4.5 Compared with the shortcomings of ID3, C4.5 has the following improvements:\n C4.5 overcomes is the shortcoming of ID3\u0026rsquo;s emphasis on the number of feature by using the Gain Ratio as the goodness function to split the dataset. C4.5 is able to handle both continuous and discrete attributes. C4.5 has a pruning strategy, which replaces the helpless branches with leaf nodes after the tree is created. C4.5 takes missing values into account.  Disadvantages\n C4.5 uses a polytree which is less efficient than a binary tree. C4.5 can only be used for classification. C4.5 is computaionally expensive both in time and space.  CART Classification And Regression Trees (CART) is a recursive partitioning method, builds classification and regression trees for predicting continuous dependent variables (regression) and categorical predictor variables (classification).\nThe classification algorithm for building a decision tree is based on Gini impurity as splitting criterion, while the regression tree uses square error.\n Tricks in Decision Tree Construction Pruning Pre-pruning:\n The size of nodes is smaller than the threshold. The depth of the tree is deeper than the threshold. All the attributes have been checked. Accuracy on the validation set becomes lower after splitting.  Post-pruning (Readings):\n Reduced-Error Pruning Pessimistic Error Pruning  Continuous Variables Since some attributes has a continuous property, we dealt with the continuous values according to the following manner. Suppose the attribute $ A $ has $ a_1, a_2, \u0026hellip; , a_n $, then $ v $ equals $ n − 1 $. The values are sorted in an ascending order to calculate each threshold.\n$$ threshold(k)=\\frac{a_{k}+a_{k+1}}{2} $$\n, where $ a_{k}\u0026lt;a_{k+1} $ and $ 1 \\leq k \\leq n-1 $. The optimal split will be found when it achieves the maximum purity.\nMissing Values Case 1: When an attribute has missing values, we calulate the ASM without considering the data with missing values. Then, we normalize the ASM based on the proportion of data with missing values.\nCase 2: We find a split criterion, but some data samples don\u0026rsquo;t have the value of that attribute. We distribute those data into sub-nodes based on the ratio of the size of those sub-nodes created by normal data.\nCase 3: When the testing data has missing values, let each abnormal data go through every branch and see which branch results in the highest probability.\n Reference  Decision Tree Algorithm, Explained Stanford CS229 ML Notes Decision Trees for Classification: A Machine Learning Algorithm Hack Earth = Decision Tree Decision Trees Explained With a Practical Example What is Attribute Selection Measures? Entropy and Information Gain to Build Decision Trees in Machine Learning   ","date":"2022-05-11T20:51:10+08:00","permalink":"https://tonyfpy.github.io/p/machine-learning-topic-3-decisoin-tree/","title":"[Machine Learning] Topic 3: Decisoin Tree"},{"content":"Task 1 - Q17. 打印从1到最大的n位数 Question 输入数字 n，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。\nSolution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  class Solution: def printNumbers(self, n: int) -\u0026gt; List[int]: if not n or n == 0: return None ans = [] def dfs(pos, nums, numOfDigit): if pos == numOfDigit: ans.append(int(\u0026#39;\u0026#39;.join(nums))) return for i in range(0, 10): nums.append(str(i)) dfs(pos+1, nums, numOfDigit) # Move to the next position nums.pop() for numOfDigit in range(1, n+1): for head in range(1, 10): # Add the first place ranging from 1 ~ 9 nums = [str(head)] dfs(1, nums, numOfDigit) return ans   Explanation  If the num is very large till long type cannot handle it, we can only use String. Time Complexity: O(10N) Space Complexity: O(N)   Task 2 - Q51. 数组中的逆序对 Question 在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。\nSolution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48  \u0026#39;\u0026#39;\u0026#39; This solution exceeds the time limit class Solution: def reversePairs(self, nums: List[int]) -\u0026gt; int: def dfs(head, id): if id == len(nums): return 0 cnt = 0 for i in range(id, len(nums)): if head \u0026gt; nums[i]: cnt += 1 return cnt + dfs(nums[id], id+1) return dfs(nums[0], 1) if len(nums) \u0026gt; 1 else 0 \u0026#39;\u0026#39;\u0026#39; class Solution: def reversePairs(self, nums: List[int]) -\u0026gt; int: def mergeSort(nums, low, high): if low \u0026gt;= high: return 0 # Don\u0026#39;t need to check if only one element in the partition mid = 0, low + (high - low) // 2 ans = mergeSort(nums, low, mid) + mergeSort(nums, mid + 1, high) l, r = low, mid + 1 tmp = [] while l \u0026lt;= mid and r \u0026lt;= high: if nums[l] \u0026lt;= nums[r]: tmp.append(nums[l]) l += 1 else: tmp.append(nums[r]) ans += mid - l + 1 # nums[l] ... nums[mid] \u0026gt; num[r] r += 1 while l \u0026lt;= mid: # Append the rest elements if needed tmp.append(nums[l]) l += 1 while r \u0026lt;= high: tmp.append(nums[r]) # Append the rest elements if needed r += 1 nums[low: high+1] = tmp return ans return mergeSort(nums, 0, len(nums)-1)   Explanation  When we merge the partitions, we can count the number of reversed pairs.    Time Complexity: O(N * log(N)) Space Complexity: O(N), i.e., recursion O(log(N)) + tmp O(N)   ","date":"2022-05-11T16:23:22+08:00","permalink":"https://tonyfpy.github.io/p/%E5%89%91%E6%8C%87offer-day-30-divide-and-conquer/","title":"[剑指Offer] Day 30: Divide and Conquer"},{"content":" Authored by Tony Feng\nCreated on May 9th, 2022\nLast Modified on May 9th, 2022\n Task 1 - Q19. 正则表达式匹配 Question 请实现一个函数用来匹配包含'.'和'*'的正则表达式。模式中的字符'.'表示任意一个字符，而'*'表示它前面的字符可以出现任意次（含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串\u0026quot;aaa\u0026quot;与模式\u0026quot;a.a\u0026quot;和\u0026quot;ab*ac*a\u0026quot;匹配，但与\u0026quot;aa.a\u0026quot;和\u0026quot;ab*a\u0026quot;均不匹配。\nSolution 1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  class Solution: # Recursion def isMatch(self, s: str, p: str) -\u0026gt; bool: @lru_cache(None) # Optimize and improve the speed def recur(i, j): if j == len(p): return i == len(s) flag = i \u0026lt; len(s) and (s[i] == p[j] or p[j] == \u0026#39;.\u0026#39;) if j \u0026lt; len(p) - 1 and p[j+1] == \u0026#39;*\u0026#39;: \u0026#39;\u0026#39;\u0026#39; 1) Ignore the character and \u0026#39;*\u0026#39; 2) Check if the next character matches p[j] \u0026#39;\u0026#39;\u0026#39; return recur(i, j+2) or (flag and recur(i+1, j)) else: return flag and recur(i+1, j+1) return recur(0, 0)   Solution 2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47  class Solution: # DP def isMatch(self, s: str, p: str) -\u0026gt; bool: def match(charS: str, charP: str) -\u0026gt; bool: \u0026#39;\u0026#39;\u0026#39;当正则字符为‘.’，或二者字符相等时，返回True\u0026#39;\u0026#39;\u0026#39; return charP == \u0026#39;.\u0026#39; or charP == charS # dp[i][j]表示 [正则串p的前i个字符] 能否配对成功 [目标串s的前j个字符] # 为了更多的cache hit，我们将逐个遍历i，即逐个读入p串的字符 lenS, lenP = len(s), len(p) dp = [[False] * (lenS+1) for _ in range(lenP+1)] # 空字符配对空字符则必定成功 dp[0][0] = True # 如果正则串为‘X*X*X*...’的形式，则其可配对空字符串 for i in range(1, lenP+1): if p[i-1] == \u0026#39;*\u0026#39;: dp[i][0] = dp[i-2][0] for i in range(1, lenP+1): for j in range(1, lenS+1): # 如果p新读入的字符是\u0026#39;*\u0026#39;，则需要比对\u0026#39;*\u0026#39;之前的字符与s的相应字符 if p[i-1] == \u0026#39;*\u0026#39;: # 1. 如果两个字符能够配对，我们用\u0026#39;X\u0026#39;表示这个字符，有两种情况： # 1.1. 不使用\u0026#39;X*\u0026#39;，即p串除去\u0026#39;X*\u0026#39;的部分可以与s串配对，即dp[i-2][j] # 1.2. 使用\u0026#39;X*\u0026#39;，因为我们已经确定\u0026#39;X\u0026#39;能够与s串的字符配对，因此， # 只要p串之前的某一个字符与s串的这个字符配对成功过，之后\u0026#39;*\u0026#39;这行所有 # 能够配对的字符都能配对成功，dp[i][j-1] # e.g. \u0026#39;ab*\u0026#39; 只要与\u0026#39;abbbb...\u0026#39;在第三行第一列配对成功了，即\u0026#39;ab*\u0026#39;与\u0026#39;a\u0026#39;的dp[3][1] # 之后对于所有\u0026#39;bbbbb...\u0026#39;，dp[3][...]都是True if match(s[j-1], p[i-2]): dp[i][j] = dp[i-2][j] or dp[i][j-1] # 2. 如果两个字符配对不成功 # 2.1. 此时只有不使用\u0026#39;X*\u0026#39;一种方法能够使p,s配对，即dp[i-2][j] else: dp[i][j] = dp[i-2][j] # 如果p新读入的不是\u0026#39;*\u0026#39;，就很简单了，只要[配对]且[二者上一个字符能够配对]就可以 else: dp[i][j] = match(s[j-1], p[i-1]) and dp[i-1][j-1] return dp[-1][-1]   Explanation  Solution 1 \u0026amp; 2  Time Complexity: O(M * N) Space Complexity: O(M * N)     Task 2 - Q49. 丑数 Question 我们把只包含质因子 2、3 和 5 的数称作丑数（Ugly Number）。求按从小到大的顺序的第 n 个丑数。\nSolution 1 2 3 4 5 6 7 8 9 10 11 12 13  class Solution: def nthUglyNumber(self, n: int) -\u0026gt; int: dp, id2, id3, id5 = [1] * n, 0, 0, 0 for i in range(1, n): n2, n3, n5 = dp[id2] * 2, dp[id3] * 3, dp[id5] * 5 dp[i] = min(n2, n3, n5) if dp[i] == n2: id2 += 1 if dp[i] == n3: id3 += 1 if dp[i] == n5: id5 += 1 return dp[-1]   Explanation  Time Complexity: O(N) Space Complexity: O(N)    Task 3 - Q60. n个骰子的点数 Question 把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s的所有可能的值出现的概率。你需要用一个浮点数数组返回答案，其中第 i 个元素代表这 n 个骰子所能掷出的点数集合中第 i 小的那个的概率。\nSolution 1 2 3 4 5 6 7 8 9 10  class Solution: def dicesProbability(self, n: int) -\u0026gt; List[float]: dp = [1/6] * 6 for i in range(2, n+1): # i means the possible value of s tmp = [0] * (6 * i - 1 * i + 1) # s is in the range n ~ 6n for j in range(len(dp)): for k in range(6): tmp[j+k] += dp[j] * (1/6) dp = tmp return dp   Explanation  Transition Function: $ f(n, x_{n})=\\sum_{i=1}^{6} f(n-1, x_{n-1}+i) \\times \\frac{1}{6} $    Time Complexity: O(N2) Space Complexity: O(N)   ","date":"2022-05-10T22:16:25+08:00","permalink":"https://tonyfpy.github.io/p/%E5%89%91%E6%8C%87offer-day-29-dynamic-programming/","title":"[剑指Offer] Day 29: Dynamic Programming"},{"content":" Authored by Tony Feng\nCreated on May 9th, 2022\nLast Modified on May 9th, 2022\n Task 1 - Q37. 序列化二叉树 Question 请实现两个函数，分别用来序列化和反序列化二叉树。你需要设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。\nSolution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51  class TreeNode(object): def __init__(self, x): self.val = x self.left = None self.right = None from collections import deque class Codec: def serialize(self, root): \u0026#34;\u0026#34;\u0026#34;Encodes a tree to a single string. :type root: TreeNode :rtype: str \u0026#34;\u0026#34;\u0026#34; if not root: return \u0026#34;[]\u0026#34; ans = [] queue = deque() queue.append(root) while queue: # BFS node = queue.popleft() if node: ans.append(str(node.val)) queue.append(node.left) queue.append(node.right) else: ans.append(\u0026#34;null\u0026#34;) return \u0026#39;[\u0026#39; + \u0026#34;,\u0026#34;.join(ans) + \u0026#39;]\u0026#39; def deserialize(self, data): \u0026#34;\u0026#34;\u0026#34;Decodes your encoded data to tree. :type data: str :rtype: TreeNode \u0026#34;\u0026#34;\u0026#34; if not data or data == \u0026#34;[]\u0026#34;: return None data = data.strip(\u0026#39;[\u0026#39;).strip(\u0026#39;]\u0026#39;).split(\u0026#39;,\u0026#39;) root = TreeNode(int(data[0])) queue = deque() queue.append(root) i = 1 while queue: node = queue.popleft() if data[i] != \u0026#34;null\u0026#34;: # Check the left node node.left = TreeNode(int(data[i])) queue.append(node.left) i += 1 if data[i] != \u0026#34;null\u0026#34;: # Check the right node node.right = TreeNode(int(data[i])) queue.append(node.right) i += 1 return root   Explanation  deserialize and serialize:  Time Complexity: O(N) Space Complexity: O(N)     Task 2 - Q38. 字符串的排列 Question 输入一个字符串，打印出该字符串中字符的所有排列。输入：s = \u0026quot;abc\u0026quot;; 输出：[\u0026quot;abc\u0026quot;,\u0026quot;acb\u0026quot;,\u0026quot;bac\u0026quot;,\u0026quot;bca\u0026quot;,\u0026quot;cab\u0026quot;,\u0026quot;cba\u0026quot;]\nSolution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  class Solution: def permutation(self, s: str) -\u0026gt; List[str]: ans = set() # Avoid duplicates visited = [0 for _ in range(len(s))] def back(path): if len(path) == len(s): ans.add(path[:]) return for i in range(0, len(s)): if visited[i] == 0: visited[i] = 1 back(path + s[i]) visited[i] = 0 # Go back back(\u0026#34;\u0026#34;) return list(ans)   Explanation  Time Complexity: O(N! * N)  DFS: N * (N-1) * (N-2) * \u0026hellip; * 1 Set -\u0026gt; List: O(N)   Space Complexity: O(N2)   ","date":"2022-05-09T22:44:41+08:00","permalink":"https://tonyfpy.github.io/p/%E5%89%91%E6%8C%87offer-day-28-searching-and-backtracking/","title":"[剑指Offer] Day 28: Searching and Backtracking"},{"content":" Authored by Tony Feng\nCreated on May 8th, 2022\nLast Modified on May 8th, 2022\n Task 1 - Q59,I. 滑动窗口的最大值 Question 给定一个数组 nums 和滑动窗口的大小 k，请找出所有滑动窗口里的最大值。你可以假设 k 总是有效的，在输入数组不为空的情况下，1 ≤ k ≤ 输入数组的大小。\n1 2 3 4 5 6 7 8 9 10 11 12  输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3 输出: [3,3,5,5,6,7] 解释: 滑动窗口的位置 最大值 --------------- ----- [1 3 -1] -3 5 3 6 7 3 1 [3 -1 -3] 5 3 6 7 3 1 3 [-1 -3 5] 3 6 7 5 1 3 -1 [-3 5 3] 6 7 5 1 3 -1 -3 [5 3 6] 7 6 1 3 -1 -3 5 [3 6 7] 7   Solution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  class Solution: def maxSlidingWindow(self, nums: List[int], k: int) -\u0026gt; List[int]: ans, window = [], [] # Record the indices whose nums are in descending order for i in range(len(nums)): # Remove the index whose elements \u0026lt; the new num while window and nums[i] \u0026gt; nums[window[-1]]: window.pop() # Add the index of the new num window.append(i) # if the size of the window \u0026gt; k, pop the first index in the window if i - window[0] + 1 \u0026gt; k: window.pop(0) # Add the first element after the window is formed if i \u0026gt;= k - 1: ans.append(nums[window[0]]) return ans   Explanation  Time Complexity: O(N) Space Complexity: O(K), i.e. It depends on the k   Task 2 - Q59,II. 队列的最大值 Question 请定义一个队列并实现函数 max_value 得到队列里的最大值，要求函数max_value、push_back 和 pop_front 的均摊时间复杂度都是O(1)。若队列为空，pop_front 和 max_value 需要返回 -1\nSolution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  import queue class MaxQueue: def __init__(self): self.queue = queue.Queue() self.deque = queue.deque() # Double-ended queue, the left is always the largest def max_value(self) -\u0026gt; int: return self.deque[0] if self.deque else -1 def push_back(self, value: int) -\u0026gt; None: self.queue.put(value) while self.deque and self.deque[-1] \u0026lt; value: self.deque.pop() self.deque.append(value) def pop_front(self) -\u0026gt; int: if self.queue.empty(): return -1 val = self.queue.get() if val == self.deque[0]: self.deque.popleft() return val   Explanation  Time Complexity  max_value: O(1) pop_front: O(1) push_back: O(1)  For example, 543216，the last push_back takes O(N) and the rest of each only needs O(1). So the average is (O(1)*(N-1)+O(N))/N=O(1).     Space Complexity: O(N)   ","date":"2022-05-08T16:50:11+08:00","permalink":"https://tonyfpy.github.io/p/%E5%89%91%E6%8C%87offer-day-27-stack-and-queue/","title":"[剑指Offer] Day 27: Stack and Queue"},{"content":" Authored by Tony Feng\nCreated on May 7th, 2022\nLast Modified on May 7th, 2022\n Task 1 - Q20. 表示数值的字符串 Question 请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。\n数值（按顺序）可以分成以下几个部分：\n 若干空格 一个 小数 或者 整数 （可选）一个 \u0026rsquo;e\u0026rsquo; 或 \u0026lsquo;E\u0026rsquo; ，后面跟着一个 整数 若干空格  小数（按顺序）可以分成以下几个部分：\n （可选）一个符号字符（\u0026rsquo;+\u0026rsquo; 或 \u0026lsquo;-\u0026rsquo;） 下述格式之一：  至少一位数字，后面跟着一个点 \u0026lsquo;.\u0026rsquo; 至少一位数字，后面跟着一个点 \u0026lsquo;.\u0026rsquo; ，后面再跟着至少一位数字 一个点 \u0026lsquo;.\u0026rsquo; ，后面跟着至少一位数字    整数（按顺序）可以分成以下几个部分：\n （可选）一个符号字符（\u0026rsquo;+\u0026rsquo; 或 \u0026lsquo;-\u0026rsquo;） 至少一位数字   部分数值列举如下： [\u0026quot;+100\u0026quot;, \u0026ldquo;5e2\u0026rdquo;, \u0026ldquo;-123\u0026rdquo;, \u0026ldquo;3.1416\u0026rdquo;, \u0026ldquo;-1E-16\u0026rdquo;, \u0026ldquo;0123\u0026rdquo;]\n部分非数值列举如下： [\u0026ldquo;12e\u0026rdquo;, \u0026ldquo;1a3.14\u0026rdquo;, \u0026ldquo;1.2.3\u0026rdquo;, \u0026ldquo;+-5\u0026rdquo;, \u0026ldquo;12e+5.4\u0026rdquo;]\n Solution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  class Solution: # State Machine def isNumber(self, s: str) -\u0026gt; bool: states = [ { \u0026#39; \u0026#39;: 0, \u0026#39;s\u0026#39;: 1, \u0026#39;d\u0026#39;: 2, \u0026#39;.\u0026#39;: 4 }, # 0. start with \u0026#39;blank\u0026#39; { \u0026#39;d\u0026#39;: 2, \u0026#39;.\u0026#39;: 4 } , # 1. \u0026#39;sign\u0026#39; before \u0026#39;e\u0026#39; { \u0026#39;d\u0026#39;: 2, \u0026#39;.\u0026#39;: 3, \u0026#39;e\u0026#39;: 5, \u0026#39; \u0026#39;: 8 }, # 2. \u0026#39;digit\u0026#39; before \u0026#39;dot\u0026#39; { \u0026#39;d\u0026#39;: 3, \u0026#39;e\u0026#39;: 5, \u0026#39; \u0026#39;: 8 }, # 3. \u0026#39;digit\u0026#39; after \u0026#39;dot\u0026#39; { \u0026#39;d\u0026#39;: 3 }, # 4. \u0026#39;digit\u0026#39; after \u0026#39;dot\u0026#39; (‘blank’ before \u0026#39;dot\u0026#39;) { \u0026#39;s\u0026#39;: 6, \u0026#39;d\u0026#39;: 7 }, # 5. \u0026#39;e\u0026#39; { \u0026#39;d\u0026#39;: 7 }, # 6. \u0026#39;sign\u0026#39; after \u0026#39;e\u0026#39; { \u0026#39;d\u0026#39;: 7, \u0026#39; \u0026#39;: 8 }, # 7. \u0026#39;digit\u0026#39; after \u0026#39;e\u0026#39; { \u0026#39; \u0026#39;: 8 } # 8. end with \u0026#39;blank\u0026#39; ] p = 0 # start with state 0 for c in s: if \u0026#39;0\u0026#39; \u0026lt;= c \u0026lt;= \u0026#39;9\u0026#39;: t = \u0026#39;d\u0026#39; # digit elif c in \u0026#34;+-\u0026#34;: t = \u0026#39;s\u0026#39; # sign elif c in \u0026#34;eE\u0026#34;: t = \u0026#39;e\u0026#39; # e or E elif c in \u0026#34;. \u0026#34;: t = c # dot, blank else: t = \u0026#39;?\u0026#39; # unknown if t not in states[p]: return False p = states[p][t] # Use hash map to transfer the state return p in (2, 3, 7, 8)   Explanation  State Machine    Time Complexity: O(N) Space Complexity: O(1)   Task 2 - Q67. 把字符串转换成整数 Question 写一个函数 StrToInt，实现把字符串转换成整数这个功能。不能使用 atoi 或者其他类似的库函数。\n 首先，该函数会根据需要丢弃无用的开头空格字符。 当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面所欲=有连续数字组合起来，作为该整数的正负号。 假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。 该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。 假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。 在任何情况下，若函数不能进行有效的转换时，请返回 0。 我们只能存储 32 位大小的有符号整数[−2147483648, 2147483647]。 如果数值超过这个范围，请返回 INT_MAX ( 231 − 1) 或 INT_MIN (−231) 。  Solution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  class Solution: def strToInt(self, str: str) -\u0026gt; int: if not str: return 0 # Ignore the spaces i = 0 while i \u0026lt; len(str) and str[i] == \u0026#34; \u0026#34;: i += 1 if i == len(str): # str consist of spaces return 0 ans = 0 sign = -1 if str[i] == \u0026#39;-\u0026#39; else 1 if str[i] in [\u0026#39;+\u0026#39;, \u0026#39;-\u0026#39;]: # Move to next position i += 1 intMax, intMin, lmt = 2**31 - 1, -2**31, 2**31//10 # 214748364 for c in str[i:]: if not \u0026#39;0\u0026#39; \u0026lt;= c \u0026lt;= \u0026#39;9\u0026#39;: # not a number break if ans \u0026gt; lmt or (ans == lmt and c \u0026gt; \u0026#39;7\u0026#39;): return intMax if sign == 1 else intMin else: ans = 10 * ans + (ord(c) - ord(\u0026#39;0\u0026#39;)) # The difference of ASCII return sign * ans   Explanation  Time Complexity: O(N) Space Complexity: O(1)   ","date":"2022-05-07T22:22:04+08:00","permalink":"https://tonyfpy.github.io/p/%E5%89%91%E6%8C%87offer-day-26-string/","title":"[剑指Offer] Day 26: String"},{"content":" Authored by Tony Feng\nCreated on May 6th, 2022\nLast Modified on May 7th, 2022\n Intro Logistic regression is a process of modeling the probability of a discrete outcome given an input variable. The most common logistic regression models a binary outcome. It’s an extension of the linear regression model for classification problems.\n Hypothesis Representation Logistic Function Since $\\theta^{T}x$ could be $ \\ll 0 $ and $ \\gg 1 $, which is not very natural for a binary classification problem with labels 0 or 1. Instead of fitting a straight line or hyperplane, the logistic regression model uses the logistic function to squeeze the output of a linear equation between 0 and 1.\n$$ g(z) = \\frac{1}{1+e^{-z}} $$\nThe deravative of the sigmoid functin is:\n$$ \\frac{\\partial}{\\partial z} g(z) = \\frac{1}{(1+e^{-z})} \\cdot(1-\\frac{1}{(1+e^{-z})}) = g(z)\\cdot(1-g(z)) $$\nFrom the plot of this function, we could see that $ g(z) $ starts off really close to 0, then rises and asymptotes towards 1. Since we want our hypothesis to output values between 0 and 1, we could combine $ g(z) $ and $ h_{\\theta}(x) $:\n$$ h_{\\theta}(x) = g(\\theta^{T}x) = \\frac{1}{1+e^{-\\theta^{T}x}} $$\nIf $ h_{\\theta}(x) \u0026gt;= 0.5 $, we could know $ y = 1 $, and vice versa.\nEstimated Probability In the logistic regression model, the ouput of $ h_{\\theta}(x) $ represents the estimated probability of $ y = 1 $ or $ y = 0 $. Thus, for a single training example $ (x^{(i)},y^{(i)}) $, we have:\n$$ P(y^{(i)}=1 \\mid x^{(i)} ; \\theta)=h_{\\theta}(x^{(i)}) $$ $$ P(y^{(i)}=0 \\mid x^{(i)} ; \\theta)=1-h_{\\theta}(x^{(i)}) $$\nThose can be written more compactly as a single equation as follows:\n$$ P(y^{(i)} \\mid x^{(i)} ; \\theta)=(h_{\\theta}(x^{(i)}))^{y^{(i)}}(1-h_{\\theta}(x^{(i)}))^{1-y^{(i)}} $$\n Cost Function Maximum Likelihood Estimation Assuming that the $m$ training examples were generated independently, we can express the likelihood of the parameters $L(\\theta)$ as:\n$$ L(\\theta) =\\prod_{i=1}^{m} P(y^{(i)} \\mid x^{(i)} ; \\theta) =\\prod_{i=1}^{m}(h_{\\theta}(x^{(i)}))^{y^{(i)}}(1-h_{\\theta}(x^{(i)}))^{1-y^{(i)}} $$\nWe can make the calculation simpler by applying logarithm:\n$$ \\ell(\\theta) =\\log L(\\theta) =\\sum_{i=1}^{m} (y^{(i)} \\log (h(x^{(i)})) + (1-y^{(i)}) \\log (1-h(x^{(i)}))) $$\nCost Function Formation Usually, in machine learning, we want to convert the \u0026ldquo;acsent\u0026rdquo; problem into a \u0026ldquo;descent\u0026rdquo; problem. Therefore,\n$$ J(\\theta) = - \\ell(\\theta) = - \\sum_{i=1}^{m} (y^{(i)} \\log (h(x^{(i)})) + (1-y^{(i)}) \\log (1-h(x^{(i)}))) $$\nUpdate Rules Now, let\u0026rsquo;s take derivatives to derive the gradient descent rule:\n$$ \\frac{\\delta}{\\delta \\theta_{j}} J(\\theta)=- \\sum_{i=1}^{m}(y^{(i)} \\frac{1}{h_{\\theta}(x^{(i)})} \\frac{\\delta}{\\delta \\theta_{j}} h_{\\theta}(x^{(i)})-(1-y^{(i)}) \\frac{1}{1-h_{\\theta}(x^{(i)})} \\frac{\\delta}{\\delta \\theta_{j}} h_{\\theta}(x^{(i)})) $$\nBecasue $ h_{\\theta}(x) = g(\\theta^{T}x) $, we have:\n$$ \\frac{\\delta}{\\delta \\theta_{j}} J(\\theta)=- \\sum_{i=1}^{m}(y^{(i)} \\frac{1}{g(\\theta^{\\mathrm{T}} x^{(i)})}-(1-y^{(i)}) \\frac{1}{1-g(\\theta^{\\mathrm{T}} x^{(i)})}) \\frac{\\delta}{\\delta \\theta_{j}} g(\\theta^{\\mathrm{T}} x^{(i)}) $$\nPreviously, we have $ \\frac{\\partial}{\\partial z} g(z) = g(z)\\cdot(1-g(z)) $ and $ \\frac{\\partial}{\\partial \\theta_{j}} \\theta^{T} x^{(i)} = x_{j}^{(i)} $. So,\n$$ \\frac{\\delta}{\\delta \\theta_{j}} J(\\theta)=-\\sum_{i=1}^{m}(y^{(i)} \\frac{1}{g(z)}-(1-y^{(i)}) \\frac{1}{1-g(z)}) g(z)(1-g(z)) x_{j}^{(i)} $$\nFinally, we have\n$$ \\frac{\\delta}{\\delta \\theta_{j}} J(\\theta)=(h_{\\theta}(x^{(i)})-y) x_{j}^{(i)} $$\nThus, the gradient descent rule is\n$$ \\theta_{j}\\gets \\theta_{j}-\\alpha \\cdot \\sum_{i=1}^{m}(h_{\\theta}(x^{(i)})-y^{(i)}) x_{j}^{(i)} $$\nIf we compare this to the LMS update rule, we see that it looks identical; but this is not the same algorithm, because $ h_{\\theta}\\left(x^{(i)}\\right) $ is now defined as a non-linear function of $ \\theta^{T} x^{(i)} $.\nIt might be a little surprising that we end up with the same update rule for a rather different algorithm and learning problem. This is actually not a coincidence, and is in fact a general property of a much bigger class of algorithms called generalized linear models.\n Reference  Stanford CS229 ML Notes Interpretable ML - Logistic Regression Coursera ML Andrew Ng Notes   ","date":"2022-05-06T21:25:32+08:00","permalink":"https://tonyfpy.github.io/p/machine-learning-topic-2-logistic-regression/","title":"[Machine Learning] Topic 2: Logistic Regression"},{"content":" Authored by Tony Feng\nCreated on May 6th, 2022\nLast Modified on May 30th, 2022\n Task 1 - Q29. 顺时针打印矩阵 Question 输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。\nSolution 1 1 2 3 4 5 6 7 8 9 10 11  class Solution: def spiralOrder(self, matrix: List[List[int]]) -\u0026gt; List[int]: ans = [] while matrix: \u0026#39;\u0026#39;\u0026#39; 1) Extract the top of the matrix 2) Reverse the matrix in a counter-clockwise direction \u0026#39;\u0026#39;\u0026#39; ans.append(matrix.pop(0)) matrix = list(zip(*matrix))[::-1] # zip(*a) is equal to zip(a[0], a[1], a[2], ...) return ans   Solution 2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  class Solution: def spiralOrder(self, matrix: List[List[int]]) -\u0026gt; List[int]: if not matrix: return [] l, r, t, b = 0, len(matrix[0])-1, 0, len(matrix)-1 ans = [] # Follows the clockwise oreder and shrink the range while True: for i in range(l, r+1): ans.append(matrix[t][i]) # left to right t += 1 if t \u0026gt; b: break for i in range(t, b+1): ans.append(matrix[i][r]) # top to bottom r -= 1 if l \u0026gt; r: break for i in range(r, l-1, -1): ans.append(matrix[b][i]) # right to left b -= 1 if t \u0026gt; b: break for i in range(b, t-1, -1): ans.append(matrix[i][l]) # bottom to top l += 1 if l \u0026gt; r: break return ans   Explanation  Solution 1  Time Complexity: O(M * N) Space Complexity: O(M * N)   Solution 2  Time Complexity: O(M * N) Space Complexity: O(1)     Task 2 - Q31. 栈的压入、弹出序列 Question 输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。\n例如，序列 {1,2,3,4,5} 是某栈的压栈序列，序列 {4,5,3,2,1} 是该压栈序列对应的一个弹出序列，但 {4,3,5,1,2} 就不可能是该压栈序列的弹出序列。\npush(1), push(2), push(3), push(4), pop() -\u0026gt; 4, push(5), pop() -\u0026gt; 5, pop() -\u0026gt; 3, pop() -\u0026gt; 2, pop() -\u0026gt; 1\nSolution 1 2 3 4 5 6 7 8 9  class Solution: def validateStackSequences(self, pushed: List[int], popped: List[int]) -\u0026gt; bool: stack, i = [], 0 # A pointer pointing to the popped list for num in pushed: stack.append(num) while stack and stack[-1] == popped[i]: stack.pop() i += 1 return True if not stack else False   Explanation  Time Complexity: O(N) Space Complexity: O(N)   ","date":"2022-05-06T16:30:00+08:00","permalink":"https://tonyfpy.github.io/p/%E5%89%91%E6%8C%87offer-day-25-simulation/","title":"[剑指Offer] Day 25: Simulation"},{"content":" Authored by Tony Feng\nCreated on May 5th, 2022\nLast Modified on May 30th, 2022\n Task 1 - Q14,I. 剪绳子 Question 给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n\u0026gt;1并且m\u0026gt;1），每段绳子的长度记为 k[0],k[1]...k[m-1] 。请问 k[0]*k[1]*...*k[m-1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。其中，2 \u0026lt;= n \u0026lt;= 58\nSolution 1 1 2 3 4 5 6 7 8 9 10 11  class Solution: # Dynamic Programming def cuttingRope(self, n: int) -\u0026gt; int: dp = [0] * (n+1) dp[2] = 1 # 2 = 1 + 1; res = 1 * 1 = 1 for i in range(3, n+1): for j in range(2, i): # Starting from 2 because 1 doesn\u0026#39;t change the result in multiplication dp[i] = max(dp[i], j*(i-j), j*dp[i-j]) # 1) Keep unchanged # 2) Cut length of j and keep the rest line unchanged # 3) Cut length of j and continue to cut following the way of dp[i-j] return dp[n]   Solution 2 1 2 3 4 5 6 7 8 9 10 11  class Solution: # Optimized Dynamic Programming def cuttingRope(self, n: int) -\u0026gt; int: dp = [0, 1, 1] for i in range(3, n+1): res1 = max(1*dp[(i-1)%3], 1*(i-1)) res2 = max(2*dp[(i-2)%3], 2*(i-2)) res3 = max(3*dp[(i-3)%3], 3*(i-3)) dp[i%3] = max(res1, res2, res3) return dp[n%3]   Solution 3 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  class Solution: \u0026#39;\u0026#39;\u0026#39; 1) The length of each sub-line should be as equal as possible. 2) The optimal length of each sub-line is 3. \u0026#39;\u0026#39;\u0026#39; def cuttingRope(self, n: int) -\u0026gt; int: if n \u0026lt; 4: return n - 1 a, b = n // 3, n % 3 if b == 0: return pow(3, a) elif b == 1: # The last length is 1. Instead, we deal with the last two sub-lines, because 2*2 \u0026gt; 3*1 return pow(3, a - 1) * 4 else: # b == 2 return pow(3, a) * 2   Explanation  Solution 1  Time Complexity: O(N2) Space Complexity: O(N)   Solution 2  Time Complexity: O(N) Space Complexity: O(1)   Solution 3  Time Complexity: O(1) Space Complexity: O(1) Assuming we have a line with length $n$, we want to cut it evenly into $ m $ pieces with the length of $ x $.  The product $ x * \\frac{n}{x} $reaching maximum happens when $ x * \\frac{1}{x}$ is the maximum. Therefore, we need to find the integer $x$ so that $ x^{\\frac{1}{x}} $ is the largest. Apply log to the equation, $ y = x^{\\frac{1}{x}} \\rightarrow ln(y) = ln(x^{\\frac{1}{x}})$ Calculate the derivative of $y$ in respect to $x$: $ \\frac{\\partial y}{\\partial x} =\\frac{1-\\ln x}{x^{2}} x^{\\frac{1}{x}} = 0 $ When $ x_0 = e $, it reaches maximum. Because $x$ is an integer, $x = 3$ is the best solution.       Task 2 - Q57,II. 和为s的连续正数序列 Question 输入一个正整数 target ，输出所有和为 target 的连续正整数序列（至少含有两个数）。序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。\nSolution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  class Solution: # Sliding Window def findContinuousSequence(self, target: int) -\u0026gt; List[List[int]]: i, j = 1, 2 total, res = i+j, [] while j - i \u0026gt; 0: if total == target: res.append(list(range(i, j+1))) if total \u0026gt;= target: # We need to remove the first num total -= i i += 1 else: # We need to add the next num j += 1 total += j return res   Explanation  Time Complexity: O(N) Space Complexity: O(1)   Task 3 - Q62. 圆圈中最后剩下的数字 Question 0,1,···,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字（删除后从下一个数字开始计数）。求出这个圆圈里剩下的最后一个数字。\n例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。\nSolution 1 1 2 3 4 5 6 7 8 9  class Solution: # Recursion def lastRemaining(self, n: int, m: int) -\u0026gt; int: def recur(remain, cnt): if remain == 1: return 0 else: return (recur(remain-1, cnt) + cnt) % remain return recur(n, m)   Solution 2 1 2 3 4 5 6 7  class Solution: # Iteration def lastRemaining(self, n: int, m: int) -\u0026gt; int: p = 0 for i in range(2, n+1): p = (p + m) % i return p   Explanation  F(curNum, m) = (F(curNum−1, m) + m) % curNum   Solution 1  Time Complexity: O(N) Space Complexity: O(N)   Solution 2  Time Complexity: O(N) Space Complexity: O(1)     ","date":"2022-05-05T21:44:05+08:00","permalink":"https://tonyfpy.github.io/p/%E5%89%91%E6%8C%87offer-day-24-mathematics/","title":"[剑指Offer] Day 24: Mathematics"},{"content":" Authored by Tony Feng\nCreated on May 4th, 2022\nLast Modified on May 29th, 2022\n Task 1 - Q39. 数组中出现次数超过一半的数字 Question 数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。你可以假设数组是非空的，并且给定的数组总是存在多数元素。\nSolution 1 1 2 3 4 5 6 7  class Solution: # Sort and Find the Medium def majorityElement(self, nums: List[int]) -\u0026gt; int: if not nums: return None m = len(nums) // 2 return sorted(nums)[m]   Solution 2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  class Solution: # Dictionary def majorityElement(self, nums: List[int]) -\u0026gt; int: if not nums: return None dict = {} halfSize = len(nums) // 2 for num in nums: if num in dict: dict[num] += 1 else: dict[num] = 1 if dict[num] \u0026gt; halfSize: return num   Solution 3 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  class Solution: # Boyer–Moore majority vote algorithm def majorityElement(self, nums: List[int]) -\u0026gt; int: if not nums: return None votes = 0 ans = None for num in nums: if votes == 0: ans = num if num != ans: votes -= 1 else: votes += 1 return ans   Explanation  Solution 1  Time Complexity: O(N * log(N)) Space Complexity: O(1)   Solution 2  Time Complexity: O(N) Space Complexity: O(N)   Solution 3  Time Complexity: O(N) Space Complexity: O(1) Boyer–Moore majority vote algorithm  If n is majority, vote + 1; else vote - 1. Finally, vote must be positive. If vote of the first $a$ numbers is 0, then the rest of vote is still positive, which means the majority number doesn\u0026rsquo;t change.       Task 2 - Q66. 构建乘积数组 Question 给定一个数组 A[0,1,…,n-1]，请构建一个数组 B[0,1,…,n-1]，其中 B[i] 的值是数组 A 中除了下标 i 以外的元素的积, 即 B[i]=A[0]×A[1]×…×A[i-1]×A[i+1]×…×A[n-1]。要求不能使用除法。\nSolution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  class Solution: # Left-Right Traversal def constructArr(self, a: List[int]) -\u0026gt; List[int]: ans = [1] * len(a) # Travese from the left tmp = 1 for i in range(0,len(a)): ans[i] *= tmp tmp *= a[i] # Travese from the right tmp = 1 for j in range(len(a)-1, -1, -1): ans[j] *= tmp tmp *= a[j] return ans   Explanation  Time Complexity: O(N) Space Complexity: O(1), i.e. ans is a return variable so it won\u0026rsquo;t take into account.                B[0] = 1 A[1] A[2] \u0026hellip; A[n-2] A[n-1]   B[1] = A[0] 1 0 \u0026hellip; A[n-2] A[n-1]   B[2] = A[0] A[1] A[2] \u0026hellip; A[n-2] A[n-1]   \u0026hellip; \u0026hellip; \u0026hellip; \u0026hellip; \u0026hellip; \u0026hellip; \u0026hellip;   B[n-2] = A[0] A[1] A[2] \u0026hellip; 1 A[n-1]   B(n-1) = A[0] A[1] A[2] \u0026hellip; A[n-2] 1     ","date":"2022-05-04T15:58:13+08:00","permalink":"https://tonyfpy.github.io/p/%E5%89%91%E6%8C%87offer-day-23-mathematics/","title":"[剑指Offer] Day 23: Mathematics"},{"content":" Authored by Tony Feng\nCreated on May 3rd, 2022\nLast Modified on May 29th, 2022\n Task 1 - Q56,I. 数组中数字出现的次数 Question 一个整型数组 nums 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是 O(1)。\nSolution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  class Solution: def singleNumbers(self, nums: List[int]) -\u0026gt; List[int]: num1, num2, xo, flag = 0, 0, 0, 1 for num in nums: xo ^= num while xo \u0026amp; flag == 0: # Find the first 1\u0026#39;s position flag = flag \u0026lt;\u0026lt; 1 for num in nums: if num \u0026amp; flag == 0: # Split the nums into two groups num1 ^= num else: num2 ^= num return [num1, num2]   Explanation  Ideas  a XO b XO b XO b \u0026hellip; XO b = a a XO b XO c XO c \u0026hellip; XO c = a XO b Assuming a XO b = 1010, we can find flag = 0010 to split the nums and put a, b in different groups. flag = 0010 means a and b\u0026rsquo;s second bits are different.      Time Complexity: O(N) Space Complexity: O(1)   Task 2 - Q56,II. 数组中数字出现的次数 II Question 在一个数组 nums 中除一个数字只出现1次之外，其他数字都出现了3次。请找出那个只出现一次的数字。\nSolution 1 1 2 3 4 5 6 7 8 9 10 11 12 13  class Solution: def singleNumber(self, nums: List[int]) -\u0026gt; int: bits = [0] * 32 for num in nums: for j in range(32): bits[j] += num \u0026amp; 1 num \u0026gt;\u0026gt;= 1 res, m = 0, 3 for i in range(32): res = res \u0026lt;\u0026lt; 1 res = res | bits[31 - i] % m return res if bits[31] % m == 0 else ~(res ^ 0xffffffff) # Take measures for negative number   Solution 2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  \u0026#39;\u0026#39;\u0026#39; Three cases: a) 333 444 5; b) 333 4 555; c) 3 444 555 \u0026#39;\u0026#39;\u0026#39; class Solution: def singleNumber(self, nums: List[int]) -\u0026gt; int: if not nums: return None if len(nums) == 1: return nums[0] nums = sorted(nums) n = len(nums) for i in range(0, n, 3): if i == n - 1: return nums[i] elif nums[i] == nums[i+2]: continue else: return nums[i]   Explanation  Solution 1  Time Complexity: O(N) Space Complexity: O(1) Steps  Create an array to store counts Count how many 1s in each position bits[i] % 3 bits -\u0026gt; binary binary -\u0026gt; int        Solution 2  Time Complexity: O(N) Space Complexity: O(N)     ","date":"2022-05-03T15:35:56+08:00","permalink":"https://tonyfpy.github.io/p/%E5%89%91%E6%8C%87offer-day-22-bit-operation/","title":"[剑指Offer] Day 22: Bit Operation"},{"content":" Authored by Tony Feng\nCreated on May 2nd, 2022\nLast Modified on May 5th, 2022\n Intro Linear Regression is studied as a model for understanding the relationship between input and output numerical variables. It is classified as a supervised learning problem, whose goal is to learn a function/hypothesis $ h: X \\rarr Y $ so that $ h(x) $ is a “good” predictor for the corresponding value of $ y $.\n Notations Dataset  $ x^{(i)} $ denotes the input variables or features, and $ y^{(i)} $ denotes the output variable that we’re trying to predict, where the superscript $ i $ denotes the $ i^{th} $ training sample. A pair $ (x^{(i)}, y^{(i)}) $ denotes a single training example. $ x^{(i)}_j $ represents the $ j^{th} $ feature of the $ i^{th} $ training sample. $ m $ denotes the number of training examples, while $ n $ denotes the number of features.  Hypothesis Function  $ h_{\\theta}(x) $ denotes the hypothesis function, which is a linear function of the features $ x $ and $ x_0=1 $.  Cost Function  $ J_{\\theta} $ denotes the cost function that we want to minimize by finding the optimal set of parameters $ \\theta $.   Hypothesis Function Initial Representation Given a set of data, let\u0026rsquo;s say we want to approximate $ y $ as a linear function of $ x $:\n$$ h_{\\theta}(x) = {\\theta}_0 + {\\theta}_1x_1 + {\\theta}_2x_2 + \u0026hellip; + {\\theta}_nx_n $$\n, where the $ {\\theta}_j $\u0026rsquo;s are the parameters (also called weights) parameterizing the space of linear functions mapping from $ X $ to $ Y $.\nRepresentation Improvement To make it simplied, we introduce an intercept term $ x_0=1 $ such that:\n$$ h(x) = \\sum_{j=0}^{n} {\\theta}_jx_j = {\\theta}^Tx $$\n, where on the right-hand side above we are viewing $ {\\theta} $ and $ x $ both as vectors.\n Cost Function Error Interpretation The hypothesis may not capture unmodeled effects or random noise, so we can say:\n$$ y^{(i)} = {\\theta}^Tx^{(i)} + {\\epsilon}^{(i)} $$\nLet’s further assume that $ {\\epsilon}^{(i)} $ follows a Gaussian distribution (Normal distribution) with mean $ {\\mu}=0 $ and variance $ {\\sigma}^2 $. This could be expressed as $ {\\epsilon}^{(i)} {\\sim} N(0, {\\sigma}^2)$. This implies that the probability density of $ {\\epsilon}^{(i)} $ follows a Gaussian density function as follows:\n$$ P({\\epsilon}^{(i)}) = \\frac{1}{\\sqrt{2 \\pi} \\sigma} exp (-\\frac{({\\epsilon}^{(i)})^2}{2 \\sigma^{2}}) $$\nAnother assumption we’re going to make is that the $ {\\epsilon}^{(i)} $ error terms are IID, which in statistics stands for independently and identically distributed. Under these set of assumptions, the probability density of $ y^{(i)} $ given $ x^{(i)} $ and parameterized by $ {\\theta} $:\n$$ P(y^{(i)} \\mid x^{(i)} ; \\theta)=\\frac{1}{\\sqrt{2 \\pi} \\sigma} exp (-\\frac{(y^{(i)}-\\theta^{T} x^{(i)})^{2}}{2 \\sigma^{2}}) $$\nIn other words, given $ x^{(i)} $ and $ {\\theta} $, the random variable $ y^{(i)} $ is sampled from a Gaussian Distribution $ N({\\theta}^Tx^{(i)}, {\\sigma}^{2}) $.\nLikelihood Function Given the input features matrix (design matrix) $ X $ (All $ x^{(i)} $ and $ {\\theta} $), the probability distribution of $ \\vec{y} $ (All $ y^{(i)} $’s) is given by $ P(\\vec{y}∣X;{\\theta}) $. The likelikhood of the parameters $ L({\\theta}) $ is defined as:\n$$ L(\\theta) =P(\\vec{y} \\mid X ; \\theta) =\\prod_{i=1}^{m} P(y^{(i)} \\mid x^{(i)} ; \\theta) $$\nNow, we add details into the above equation, $$ L(\\theta)=\\prod_{i=1}^{m} \\frac{1}{\\sqrt{2 \\pi} \\sigma} exp (-\\frac{(y^{(i)}-\\theta^{T} x^{(i)})^{2}}{2 \\sigma^{2}}) $$\nThe principal of Maximum Likelihood Estimation (MLE) states that we should choose $ {\\theta} $ so as to make the data as high probability as possible. The derivations will be a bit simpler if we instead maximize the log likelihood $ {\\ell(\\theta)} $:\n$$ {\\ell(\\theta)}=ln(\\prod_{i=1}^{m} \\frac{1}{\\sqrt{2 \\pi} \\sigma} exp (-\\frac{(y^{(i)}-\\theta^{T} x^{(i)})^{2}}{2 \\sigma^{2}})) $$\nAccording to the product rule of logarithms,\n$$ \\ell(\\theta)=\\sum_{i=1}^{m} ln \\frac{1}{\\sqrt{2 \\pi} \\sigma} exp (-\\frac{(y^{(i)}-\\theta^{T} x^{(i)})^{2}}{2 \\sigma^{2}}) $$\nAgain, the log product rule shows us:\n$$ \\ell(\\theta)=\\sum_{i=1}^{m} \\left[ln \\frac{1}{\\sqrt{2 \\pi} \\sigma} + ln(exp (-\\frac{(y^{(i)}-\\theta^{T} x^{(i)})^{2}}{2 \\sigma^{2}})\\right] $$\nThis could be expanded as:\n$$ \\ell(\\theta)= m {\\cdot} ln \\frac{1}{\\sqrt{2 \\pi} \\sigma} - \\frac{1}{\\sigma^{2}} {\\cdot} \\frac{1}{2} {\\cdot} \\sum_{i=1}^{m} (y^{(i)}-\\theta^{T} x^{(i)})^{2} $$\nCost Function Formation From the probability interpretation above, we could regard $ \\ell(\\theta) $ as:\n$$ \\ell(\\theta)= C_1 - C_2 {\\cdot} \\frac{1}{2} {\\cdot} \\sum_{i=1}^{m} (y^{(i)}-\\theta^{T} x^{(i)})^{2} $$\n, where $ C_1 $ and $ C_2 $ are constant. Hence, maximizing $ \\ell(\\theta) $ is equivalent to minimizing $ J(\\theta) $:\n$$ J(\\theta)= \\frac{1}{2} {\\cdot} \\sum_{i=1}^{m} (y^{(i)}-\\theta^{T} x^{(i)})^{2} $$\n, where $ 1/2 $ is a constant that helps cancel 2 in derivative of the function.\nThe formation above shows that choosing the value of $ \\theta $ to minimize the least squares error cost function, is equivalent to finding the MLE for the parameters $ \\theta $ under the set of assumptions that the error terms $ {\\epsilon}^{(i)} $ are Gaussian and IID.\n Cost Function Minimization Least Mean Square To find a set of parameters, one way is to find the optimum that minimizes the cost function. Therefore, we need $ \\nabla_{\\theta} J(\\theta)= 0 $. More specifically, $ \\frac{\\partial J}{\\partial \\theta_{1}} = 0, \\frac{\\partial J}{\\partial \\theta_{2}} = 0, \\frac{\\partial J}{\\partial \\theta_{3}} = 0, \u0026hellip;, \\frac{\\partial J}{\\partial \\theta_{n}} = 0 $.\nHowever, this may generate $ n $ equations and is computationally expensive if there are many features in the dataset. We need to find other ways.\nGradient Descent We can start with some “initial guess” for $ {\\theta} $, and that repeatedly changes $ {\\theta} $ to make $ J(\\theta) $ smaller, until hopefully we converge to a value of $ {\\theta} $ that minimizes $ J(\\theta) $. For $ j = 0, 1, 2, \u0026hellip;, n $, we simultaneously update the $ {\\theta} $ and this process will be kept until convergence:\n$$ \\theta _{j} \\gets \\theta _{j} - \\alpha \\cdot \\frac{\\partial J}{\\partial \\theta _{j}} $$\nHere, $ \\alpha$ is the learning rate, a hyperparameter to control the searching speed. Now, we put all the equations together and we coud see:\n$$ \\theta_{j}\\gets \\theta_{j}-\\alpha \\cdot \\sum_{i=1}^{m}(h_{\\theta}(x^{(i)})-y^{(i)}) x_{j}^{(i)} $$\nThis is the Stochastic Gradient Descent strategy, because we update the parameters according to the gradient of the error with respect to a single training example only. Beside, there are other strategies, such as Batch GD, Mini-batch GD, etc, which will be discussed in my future posts.\n Normal Equation In this method, we will minimize $ J(\\theta) $ by explicitly taking its derivatives with respect to the $ {\\theta}_j $’s, and setting them to zero.\nGiven a training set, define the design matrix $ X $ to be the $ m×n $, and let $ y $ to be the $ m×1 $ vector containing all the target values from the training set. We can obtain:\n$$ J(\\theta)= \\frac{1}{2} {\\cdot} \\sum_{i=1}^{m} (y^{(i)}-\\theta^{T} x^{(i)})^{2} = \\frac{1}{2} || X\\theta-y || ^2 = \\frac{1}{2} (X \\theta-y)^{T}(X \\theta-y) $$\nNow, we expand the equation:\n$$ J(\\theta)= \\frac{1}{2} (\\theta^{T} X^{T} X \\theta-\\theta^{T} X^{T} y-y^{T} X \\theta + y^{T} y) $$\nSince $ \\theta^{T} X^{T} y $ and $ y^{T} X \\theta $ are scalars, so they are equivalent. We can now simplify the equation as:\n$$ J(\\theta)= \\frac{1}{2} (\\theta^{T} X^{T} X \\theta-2\\theta^{T} X^{T} y + y^{T} y) $$\nAccoding to the rules of derivative of matrix, $ \\frac{d B^{T} A B}{d B}=(A+A^{\\mathrm{T}}) B $ and $ \\frac{d B^{T} A}{d B}=A $, we can find its derivatives with respect to $ \\theta $:\n$$ \\nabla_{\\theta} J(\\theta)= \\frac{1}{2} ((X^TX + (X^TX)^T)\\theta - 2X^Ty) = \\frac{1}{2} (2X^TX\\theta - 2X^Ty) $$\nNow, we set $ \\nabla_{\\theta} J(\\theta) $ to zero:\n$$ X^TX\\theta = X^Ty $$\nThus, the value of $ \\theta $ that minimizes $ J(\\theta) $ is given in closed form by the equation:\n$$ \\theta=(X^{T} X)^{-1} X^{T} y $$\nThis approach requires the matrix to be inversible. Usually, if some features have linear relations or the size of training samples is smaller than the number of features, $ X^TX $ is not inversible.\n Reference  Stanford CS229 ML Notes Machine Learning Regression Explained Linear Regression for Machine Learning Logistic Regression — Detailed Overview ML Fundamentals: What Is Cost Function? Coursera ML Andrew Ng Notes   ","date":"2022-05-02T23:09:54+08:00","permalink":"https://tonyfpy.github.io/p/machine-learning-topic-1-linear-regression/","title":"[Machine Learning] Topic 1: Linear Regression"},{"content":" Authored by Tony Feng\nCreated on May 2nd, 2022\nLast Modified on May 2nd, 2022\n Intro Matplotlib is a comprehensive library for creating static, animated, and interactive visualizations in Python. It produces publication-quality figures in a variety of hardcopy formats and interactive environments across platforms.\n Basics of Figure Drawing Plotting 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  import numpy as np import matplotlib.pyplot as plt # Compute the x and y coordinates for points on sine and cosine curves x = np.linspace(-5,5) y_sin = np.sin(x) y_cos = np.cos(x) # Plot the points using matplotlib # You can set up many kinds of parameters in plot(). plt.plot(x, y_sin) plt.plot(x, y_cos) plt.xlabel(\u0026#39;X axis\u0026#39;) plt.ylabel(\u0026#39;Y axis\u0026#39;) plt.title(\u0026#39;sin \u0026amp; cos\u0026#39;) plt.legend([\u0026#39;sin\u0026#39;, \u0026#39;cos\u0026#39;]) plt.show()    Subplots 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  import numpy as np import matplotlib.pyplot as plt # Compute the x and y coordinates for points on sine and cosine curves x = np.linspace(-10,10) y_sin = np.sin(x) y_cos = np.cos(x) # Set up a subplot grid that has height 2 and width 1, # and set the first such subplot as active. plt.subplot(2, 1, 1) # plt.subplot(211) # Make the first plot plt.plot(x, y_sin, color=\u0026#39;r\u0026#39;, linestyle=\u0026#39;:\u0026#39;, marker=\u0026#39;o\u0026#39;) plt.title(\u0026#39;sin\u0026#39;) plt.text(0,0, \u0026#34;Origin\u0026#34;) # Display \u0026#34;Origin\u0026#34; near (0,0) plt.annotate(\u0026#39;peak\u0026#39;, xy=(np.pi/2, 1), xytext=(3*np.pi/2, 0.5), arrowprops=dict(facecolor=\u0026#39;g\u0026#39;, shrink=0.05, headlength=10, headwidth=10)) # Show an arrow # Set the second subplot as active, and make the second plot. plt.subplot(2, 1, 2) # plt.subplot(212) plt.plot(x, y_cos, color=\u0026#39;b\u0026#39;) plt.title(\u0026#39;cos\u0026#39;) plt.grid(True) # Show grids plt.show() # Show the figure.     Common Figures Histogram 1 2 3 4 5 6 7 8 9 10 11 12  import matplotlib.pyplot as plt import numpy as np import matplotlib matplotlib.rcParams[\u0026#39;axes.unicode_minus\u0026#39;]=False # Negative Number data = np.random.randn(10000) # Normal Distribution plt.hist(data, bins=40, facecolor=\u0026#34;blue\u0026#34;, edgecolor=\u0026#34;black\u0026#34;, alpha=0.7) plt.xlabel(\u0026#34;Range\u0026#34;) plt.ylabel(\u0026#34;Frequecy\u0026#34;) plt.title(\u0026#34;Distribution\u0026#34;) plt.show()    Scatter Plot 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  import matplotlib.pyplot as plt import numpy as np mu_vec1 = np.array([0,0]) cov_mat1 = np.array([[2,0],[0,2]]) x1_samples = np.random.multivariate_normal(mu_vec1, cov_mat1, 100) x2_samples = np.random.multivariate_normal(mu_vec1+0.2, cov_mat1+0.2, 100) x3_samples = np.random.multivariate_normal(mu_vec1+0.4, cov_mat1+0.4, 100) plt.figure(figsize = (8,6)) plt.scatter(x1_samples[:,0],x1_samples[:,1],marker=\u0026#39;x\u0026#39;,color=\u0026#39;blue\u0026#39;,alpha=0.6,label=\u0026#39;x1\u0026#39;) plt.scatter(x2_samples[:,0],x2_samples[:,1],marker=\u0026#39;o\u0026#39;,color=\u0026#39;red\u0026#39;,alpha=0.6,label=\u0026#39;x2\u0026#39;) plt.scatter(x3_samples[:,0],x3_samples[:,1],marker=\u0026#39;^\u0026#39;,color=\u0026#39;green\u0026#39;,alpha=0.6,label=\u0026#39;x3\u0026#39;) plt.legend(loc=\u0026#39;best\u0026#39;) plt.show()    Box Plot 1 2 3 4 5 6 7 8 9 10 11  import matplotlib.pyplot as plt import numpy as np tang_data = [np.random.normal(0,std,100) for std in range(1,4)] fig = plt.figure(figsize=(8,6)) plt.boxplot(tang_data,notch=False,sym=\u0026#39;s\u0026#39;,vert=True) plt.xticks([y+1 for y in range(len(tang_data))],[\u0026#39;x1\u0026#39;,\u0026#39;x2\u0026#39;,\u0026#39;x3\u0026#39;]) plt.xlabel(\u0026#39;x\u0026#39;) plt.title(\u0026#39;box plot\u0026#39;) plt.show()    Pie Chart 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  import matplotlib.pyplot as plt import matplotlib matplotlib.rcParams[\u0026#39;font.sans-serif\u0026#39;] = [\u0026#39;SimHei\u0026#39;] matplotlib.rcParams[\u0026#39;axes.unicode_minus\u0026#39;] = False label_list = [\u0026#34;Part 1\u0026#34;, \u0026#34;Part 2\u0026#34;, \u0026#34;Part 3\u0026#34;] size = [55, 35, 10] color = [\u0026#34;red\u0026#34;, \u0026#34;green\u0026#34;, \u0026#34;blue\u0026#34;] explode = [0.05, 0, 0] patches, l_text, p_text = plt.pie(size, explode=explode, colors=color, labels=label_list, labeldistance=1.1, autopct=\u0026#34;%1.1f%%\u0026#34;, shadow=False, startangle=90, pctdistance=0.6) plt.axis(\u0026#34;equal\u0026#34;) # Set the lengths of two axises to be equal plt.legend() plt.show()    3D Figure 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  import matplotlib.pyplot as plt import numpy as np from mpl_toolkits.mplot3d import Axes3D fig = plt.figure() ax = Axes3D(fig) x = np.arange(-4,4,0.25) y = np.arange(-4,4,0.25) X,Y = np.meshgrid(x,y) Z = np.sin(np.sqrt(X**2+Y**2)) ax.plot_surface(X,Y,Z,rstride=1,cstride=1,cmap=\u0026#39;rainbow\u0026#39;) ax.contour(X,Y,Z,zdim=\u0026#39;z\u0026#39;,offset=-2 ,cmap=\u0026#39;rainbow\u0026#39;) ax.set_zlim(-2,2) plt.show()     Reference  Matplotlib Official Documentation Matplotlib Tutorial Python Plotting With Matplotlib (Guide)   ","date":"2022-05-02T17:16:38+08:00","permalink":"https://tonyfpy.github.io/p/data-analysis-topic-3-matplotlib/","title":"[Data Analysis] Topic 3: Matplotlib"},{"content":" Authored by Tony Feng\nCreated on May 2st, 2022\nLast Modified on May 2st, 2022\n Task 1 - Q15. 二进制中1的个数 Question 编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 \u0026lsquo;1\u0026rsquo; 的个数（也被称为 汉明重量).）。\nSolution 1 1 2 3 4 5 6 7 8  class Solution: # Recursion def hammingWeight(self, n: int) -\u0026gt; int: if n == 0: return 0 elif n \u0026amp; 1 == 0: return self.hammingWeight(n \u0026gt;\u0026gt; 1) else: return 1 + self.hammingWeight(n \u0026gt;\u0026gt; 1)   Solution 2 1 2 3 4 5 6 7  class Solution: # Iteration  def hammingWeight(self, n: int) -\u0026gt; int: res = 0 while n: res += 1 n = n \u0026amp; (n-1) # Remove leftest 1 in each loop return res   Explanation  Solution 1  Time Complexity: O(log(n)), i.e., log(n) means the rightest position of 1 in n Space Complexity: O(log(n))   Solution 2  Time Complexity: O(M), i.e., it depends on how many 1 in the binary string. Space Complexity: O(1)      Task 2 - Q65. 不用加减乘除做加法 Question 写一个函数，求两个整数之和，要求在函数体内不得使用 “+”、“-”、“*”、“/” 四则运算符号。a, b 均可能是负数或 0，并且结果不会溢出 32 位整数\nSolution 1 2 3 4 5 6 7 8 9 10  class Solution: def add(self, a, b): x = 0xffffffff a, b = a \u0026amp; x, b \u0026amp; x while b: carry = (a \u0026amp; b) \u0026lt;\u0026lt; 1 \u0026amp; x total = a ^ b a = total b = carry return a if a \u0026lt;= 0x7fffffff else ~(a ^ x)   Explanation  Time Complexity: O(1), i.e., maximum number of iterations is 32 Space Complexity: O(1) sum = a + b =\u0026gt; sum = n + c.  We progressively calculate n and c until c == 0. And return n.       a(i) b(i) 无进位和 n(i) 进位 c(i+1)     0 0 0 0   0 1 1 0   1 0 1 0   1 1 0 1      ","date":"2022-05-02T15:16:33+08:00","permalink":"https://tonyfpy.github.io/p/%E5%89%91%E6%8C%87offer-day-21-bit-operation/","title":"[剑指Offer] Day 21: Bit Operation"},{"content":" Authored by Tony Feng\nCreated on May 1st, 2022\nLast Modified on May 1st, 2022\n Task 1 - Q07. 重建二叉树 Question 输入某二叉树的前序遍历和中序遍历的结果，请构建该二叉树并返回其根节点。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。\nSolution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None class Solution: def buildTree(self, preorder: List[int], inorder: List[int]) -\u0026gt; TreeNode: if not preorder or not inorder: return None # Find the root root = TreeNode(preorder[0]) id = inorder.index(root.val) root.left = self.buildTree(preorder[1:id+1], inorder[0:id]) root.right = self.buildTree(preorder[id+1:], inorder[id+1:]) return root   Explanation  Preorder: root | left | right Inorder: left | root | right Root is the first element in preorder list. Root in inorder list separates the left and right sub-trees. Time Complexity: O(N) Space Complexity: O(N)   Task 2 - Q16. 数值的整数次方 Question 实现 pow(x, n) ，即计算 x 的 n 次幂函数（即，xn）。不得使用库函数，同时不需要考虑大数问题。\nSolution 1 2 3 4 5 6 7 8 9 10  class Solution: def myPow(self, x: float, n: int) -\u0026gt; float: if n == 0: return 1 elif n \u0026lt; 0: return 1 / self.myPow(x, -n) # Make n from negative to positive elif n \u0026amp; 1 == 0: # Even or not return self.myPow(x*x, n\u0026gt;\u0026gt;1) # i.e. n//2. It ensures the result is an integer.  else: return x * self.myPow(x, n-1)   Explanation  Time Complexity: O(log(N)) Space Complexity: O(log(N))   Task 3 - Q33. 二叉搜索树的后序遍历序列 Question 输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 true，否则返回 false。假设输入的数组的任意两个数字都互不相同。\n1 2 3 4 5 6 7  输入: [1,6,3,2,5], 输出: False 输入: [1,3,2,6,5], 输出: True 5 / \\ 2 6 / \\ 1 3   Solution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  class Solution: def verifyPostorder(self, postorder: [int]) -\u0026gt; bool: def recur(l, r): if l \u0026gt;= r: return True p = l while postorder[p] \u0026lt; postorder[r]: p += 1 m = p while postorder[p] \u0026gt; postorder[r]: p += 1 return p == r and recur(l, m-1) and recur(m, r-1) return recur(0, len(postorder)-1)   Explanation  The leftest node is always the root. We need to find the serparator who divides the left and right sub-trees. Time Complexity: O(N2), i.e., the shape is like a linked list. Space Complexity: O(N), i.e., the shape is like a linked list.   ","date":"2022-05-01T20:51:18+08:00","permalink":"https://tonyfpy.github.io/p/%E5%89%91%E6%8C%87offer-day-20-divide-and-conquer/","title":"[剑指Offer] Day 20: Divide and Conquer"},{"content":" Authored by Tony Feng\nCreated on April 30th, 2022\nLast Modified on May 1st, 2022\n Intro Pandas is great data processing library for table/database-like data. Excellent for things that come in or you wish to output as CSV/Excel. DataFrames make manipulating your data easy, from selecting or replacing columns and indices to reshaping your data.\n Data Preprocessing Dataframe Creating 1 2 3 4 5  data = { \u0026#34;Country\u0026#34;: [\u0026#39;China\u0026#39;, \u0026#39;US\u0026#39;, \u0026#39;India\u0026#39;], \u0026#34;Population\u0026#34;: [14, 3, 14] } df = pd.DataFrame(data)   Data Reading 1 2 3 4 5 6 7 8 9  import pandas as pd df = pd.read_csv(\u0026#39;data.csv\u0026#39;) df.head() # First 5 rows df.tail() # Last 5 rows df.info() # Overview of the data df.describe() # Statistical details df.columns # header df.dtype # Types of each column df.values # Data matrix   Data indexing 1 2 3 4 5 6 7 8 9 10 11 12 13 14  df_age = df[\u0026#39;Age\u0026#39;] # Get a column age = df_age.values # Get a ndarray  df_birthday = df[[\u0026#39;Year\u0026#39;, \u0026#39;Month\u0026#39;, \u0026#39;Day\u0026#39;]] # Get two columns df.iloc[0] # First piece of data df.iloc[0:5] # First 5 rows df.iloc[0:5, 1:3] # First 5 rows with specified features df = df.set_index(\u0026#39;Name\u0026#39;) # Reset index df.loc[\u0026#39;Tony\u0026#39;] df.loc[\u0026#39;Tony\u0026#39;, \u0026#39;Age\u0026#39;] # Use name to find age df[df[\u0026#39;Age\u0026#39;] \u0026gt;= 18][:5] # Find 5 people whose age is over 18 df.loc[df[\u0026#39;Sex\u0026#39;]==\u0026#39;Female\u0026#39;, \u0026#39;Age\u0026#39;].mean() # Calculate the average age of all females   Series 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  # Create val = [1, 10 ,100] id = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;] s = pd.Series(data=val, index=id) # Indexing s.loc[\u0026#39;b\u0026#39;] # 10 s.iloc[1] # 10 # Assignment s1 = s.copy() s1[\u0026#39;a\u0026#39;] = 0 s1.rename(index={\u0026#39;a\u0026#39;:\u0026#39;alpha\u0026#39;}, inplace=True) s1.index # Index([\u0026#39;alpha\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;], dtype=\u0026#39;object\u0026#39;) # Add s2 = pd.Series(data=[1000, 10000], index=[\u0026#39;e\u0026#39;, \u0026#39;f\u0026#39;]) s3 = s1.append(s2) s3[\u0026#39;d\u0026#39;] = 500 # Add an index with a value # Remove del s3[\u0026#39;alpha\u0026#39;] s3.drop([\u0026#39;b\u0026#39; ,\u0026#39;c\u0026#39;], inplace=True)    Data Analysis Statistics 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  df = pd.DataFrame([[1,2,3],[4,5,6]], index=[\u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;], columns=[\u0026#39;A\u0026#39;,\u0026#39;B\u0026#39;,\u0026#39;C\u0026#39;]) df.sum() # axis=0 by default df.mean() df.median() df.max() df.min() df.describe() # Statistical details: cnt, mean, var, max, min, etc. df.cov() # Covariance df.corr() # Correlation coefficient df[\u0026#39;Sex\u0026#39;].value_counts(ascending=True) # Female 314 Male 577 df[\u0026#39;Age\u0026#39;].value_counts(ascending=True, bins=5) # All age values will be separated in to 5 ranges. ages = [15, 18, 20, 21, 26, 33, 45, 66, 75] bins = [10, 30, 50, 80] # (10, 30], (30, 50], (50, 80] Three intervals names = [\u0026#34;Y\u0026#34;, \u0026#34;M\u0026#34;, \u0026#34;O\u0026#34;] res = pd.cut(ages, bins, labels=names) # [\u0026#39;Y\u0026#39;, \u0026#39;Y\u0026#39;, \u0026#39;Y\u0026#39;, \u0026#39;Y\u0026#39;, \u0026#39;Y\u0026#39;, \u0026#39;M\u0026#39;, \u0026#39;M\u0026#39;, \u0026#39;O\u0026#39;, \u0026#39;O\u0026#39;] # Categories (3, object): [\u0026#39;Y\u0026#39; \u0026lt; \u0026#39;M\u0026#39; \u0026lt; \u0026#39;O\u0026#39;]   Pivot Table 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40  # Pivot df = pd.DataFrame({ \u0026#34;Type\u0026#34;: [\u0026#39;Breakfast\u0026#39;, \u0026#39;Lunch\u0026#39;, \u0026#39;Dinner\u0026#39;, \u0026#39;Breakfast\u0026#39;, \u0026#39;Lunch\u0026#39;, \u0026#39;Dinner\u0026#39;, \u0026#39;Breakfast\u0026#39;, \u0026#39;Lunch\u0026#39;, \u0026#39;Dinner\u0026#39;], \u0026#34;Month\u0026#34;: [1, 1, 1, 2, 2, 2, 3, 3, 3], \u0026#34;Cost\u0026#34;: [50, 60, 100, 30, 70, 90, 40, 40, 40] }) pivot = df.pivot(index=\u0026#34;Month\u0026#34;, columns=\u0026#34;Type\u0026#34;, values=\u0026#34;Cost\u0026#34;) \u0026#39;\u0026#39;\u0026#39; Type Breakfast Dinner Lunch Month 1 50 100 60 2 30 90 70 3 40 40 40 \u0026#39;\u0026#39;\u0026#39; pivot.sum(axis=0) \u0026#39;\u0026#39;\u0026#39; Type Breakfast 120 Dinner 230 Lunch 170 dtype: int64 \u0026#39;\u0026#39;\u0026#39; # Pivot Table df = pd.DataFrame({ \u0026#34;A\u0026#34;: [\u0026#34;foo\u0026#34;, \u0026#34;foo\u0026#34;, \u0026#34;foo\u0026#34;, \u0026#34;foo\u0026#34;, \u0026#34;foo\u0026#34;,\u0026#34;bar\u0026#34;, \u0026#34;bar\u0026#34;, \u0026#34;bar\u0026#34;, \u0026#34;bar\u0026#34;], \u0026#34;B\u0026#34;: [\u0026#34;one\u0026#34;, \u0026#34;one\u0026#34;, \u0026#34;one\u0026#34;, \u0026#34;two\u0026#34;, \u0026#34;two\u0026#34;, \u0026#34;one\u0026#34;, \u0026#34;one\u0026#34;, \u0026#34;two\u0026#34;, \u0026#34;two\u0026#34;], \u0026#34;C\u0026#34;: [\u0026#34;small\u0026#34;, \u0026#34;large\u0026#34;, \u0026#34;large\u0026#34;, \u0026#34;small\u0026#34;, \u0026#34;small\u0026#34;, \u0026#34;large\u0026#34;, \u0026#34;small\u0026#34;, \u0026#34;small\u0026#34;, \u0026#34;large\u0026#34;], \u0026#34;D\u0026#34;: [1, 2, 2, 3, 3, 4, 5, 6, 7], \u0026#34;E\u0026#34;: [2, 4, 5, 5, 6, 6, 8, 9, 9] }) pTable = df.pivot_table(index=[\u0026#39;A\u0026#39;, \u0026#39;B\u0026#39;], columns=[\u0026#39;C\u0026#39;], values=\u0026#39;D\u0026#39;, aggfunc=np.sum, fill_value=-1) \u0026#39;\u0026#39;\u0026#39; C large small A B bar one 4 5 two 7 6 foo one 2 1 two -1 3 \u0026#39;\u0026#39;\u0026#39;   Group 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67  df = pd.DataFrame({ \u0026#39;Courses\u0026#39;:[\u0026#34;Spark\u0026#34;,\u0026#34;PySpark\u0026#34;,\u0026#34;Hadoop\u0026#34;,\u0026#34;Python\u0026#34;,\u0026#34;Pandas\u0026#34;,\u0026#34;Hadoop\u0026#34;,\u0026#34;Spark\u0026#34;,\u0026#34;Python\u0026#34;,\u0026#34;R\u0026#34;], \u0026#39;Fee\u0026#39; :[22000,25000,23000,24000,26000,25000,25000,22000,1500], \u0026#39;Duration\u0026#39;:[30,50,55,40,60,35,30,50,40], \u0026#39;Discount\u0026#39;:[1000,2300,1000,1200,2500,None,1400,1600,0] }) # Group by multiple columns df2 = df.groupby([\u0026#39;Courses\u0026#39;, \u0026#39;Duration\u0026#39;]).sum() \u0026#39;\u0026#39;\u0026#39; Fee Discount Courses Duration Hadoop 35 25000 0.0 55 23000 1000.0 Pandas 60 26000 2500.0 PySpark 50 25000 2300.0 Python 40 24000 1200.0 50 22000 1600.0 R 40 1500 0.0 Spark 30 47000 2400.0 \u0026#39;\u0026#39;\u0026#39; # Choose whether to sort df.groupby(\u0026#39;Courses\u0026#39;,sort=True).sum() # not choose ascending ot descending \u0026#39;\u0026#39;\u0026#39; Fee Duration Discount Courses Hadoop 48000 90 1000.0 Pandas 26000 60 2500.0 PySpark 25000 50 2300.0 Python 46000 90 2800.0 R 1500 40 0.0 Spark 47000 60 2400.0 \u0026#39;\u0026#39;\u0026#39; # Sort group key on descending order groupedDF = df.groupby(\u0026#39;Courses\u0026#39;,sort=False).sum() groupedDF.sort_values(\u0026#39;Courses\u0026#39;, ascending=False) \u0026#39;\u0026#39;\u0026#39; Spark 47000 60 2400.0 R 1500 40 0.0 Python 46000 90 2800.0 PySpark 25000 50 2300.0 Pandas 26000 60 2500.0 Hadoop 48000 90 1000.0 \u0026#39;\u0026#39;\u0026#39; # Drop NA and add an index df3 = df.groupby([\u0026#39;Courses\u0026#39;], dropna=False).sum().reset_index() \u0026#39;\u0026#39;\u0026#39; Courses Fee Duration Discount 0 Hadoop 48000 90 1000.0 1 Pandas 26000 60 2500.0 2 PySpark 25000 50 2300.0 3 Python 46000 90 2800.0 4 R 1500 40 0.0 5 Spark 47000 60 2400.0 \u0026#39;\u0026#39;\u0026#39; # Apply aggregations df.groupby(\u0026#39;Courses\u0026#39;).aggregate({\u0026#39;Duration\u0026#39;:\u0026#39;count\u0026#39;,\u0026#39;Fee\u0026#39;:[\u0026#39;min\u0026#39;,\u0026#39;max\u0026#39;]}) \u0026#39;\u0026#39;\u0026#39; Duration Fee count min max Courses Hadoop 2 23000 25000 Pandas 1 26000 26000 PySpark 1 25000 25000 Python 2 22000 24000 R 1 1500 1500 Spark 2 22000 25000 \u0026#39;\u0026#39;\u0026#39;    Usuful Functions Merge 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  df1 = pd.DataFrame({ \u0026#39;name\u0026#39;: [\u0026#39;Foreign Cinema\u0026#39;, \u0026#39;Liho Liho\u0026#39;, \u0026#39;500 Club\u0026#39;, \u0026#39;The Square\u0026#39;, \u0026#39;S86\u0026#39;], \u0026#39;Type\u0026#39;: [\u0026#39;Restaurant\u0026#39;, \u0026#39;Restaurant\u0026#39;, \u0026#39;bar\u0026#39;, \u0026#39;bar\u0026#39;, \u0026#39;bar\u0026#39;] }) df2 = pd.DataFrame({ \u0026#39;name\u0026#39;: [\u0026#39;Foreign Cinema\u0026#39;, \u0026#39;Liho Liho\u0026#39;, \u0026#39;500 Club\u0026#39;, \u0026#39;The Square\u0026#39;], \u0026#39;AvgBill\u0026#39;: [100, 200, 300, 400], \u0026#39;Rating\u0026#39;: [5, 4.2, 4.3, 4.8] }) pd.merge( df1, df2, on = \u0026#39;name\u0026#39;, how = \u0026#39;outer\u0026#39;, # Otherwise, \u0026#39;S86\u0026#39; will be deleted. indicator = True # _merge ) \u0026#39;\u0026#39;\u0026#39; name Type AvgBill Rating _merge 0 Foreign Cinema Restaurant 100.0 5.0 both 1 Liho Liho Restaurant 200.0 4.2 both 2 500 Club bar 300.0 4.3 both 3 The Square bar 400.0 4.8 both 4 S86 bar NaN NaN left_only \u0026#39;\u0026#39;\u0026#39;   Sort 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  df = pd.DataFrame({ \u0026#39;group\u0026#39;: [\u0026#39;a\u0026#39;]*3 + [\u0026#39;b\u0026#39;]*3 + [\u0026#39;c\u0026#39;]*3, \u0026#39;data\u0026#39;: [4,3,2,1,12,3,4,5,7] }) df.sort_values(by=[\u0026#39;data\u0026#39;, \u0026#39;group\u0026#39;], ascending=[False, True], inplace=True) \u0026#39;\u0026#39;\u0026#39; group data 4 b 12 8 c 7 7 c 5 0 a 4 6 c 4 1 a 3 5 b 3 2 a 2 3 b 1 \u0026#39;\u0026#39;\u0026#39;   Data Cleaning 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  # Remove duplicates  df.drop_duplicates() # key-value pairs df.drop_duplicates(subset=\u0026#39;some_feature\u0026#39;) # no duplicates in \u0026#39;some_feature\u0026#39; # NaN import numpy as np df = pd.DataFrame([range(3), [0, np.nan, 0], [0, 0, np.nan], range(3)]) df.isnull() df.isnull().any(axis=1) # Check whether rows have NaN df.fillna(-1) # Fill NaN \u0026#39;\u0026#39;\u0026#39; 0 1 2 | 0 1 2 | 0 False | 0 1 2 0 0 1.0 2.0 | 0 False False False | 1 True | 0 0 1.0 2.0 1 0 NaN 0.0 | 1 False True False | 2 True | 1 0 -1.0 0.0 2 0 0.0 NaN | 2 False False True | 3 False | 2 0 0.0 -1.0 3 0 1.0 2.0 | 3 False False False | dtype: bool | 3 0 1.0 2.0 \u0026#39;\u0026#39;\u0026#39; # apply df[\u0026#39;new_col\u0026#39;] = df.apply(some_func, axis=\u0026#39;columns\u0026#39;) # some_func could be defined somewhere or inline using lambda.   Timestamp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  # Create a timestamp ts = pd.Timestamp(\u0026#39;2022-05-01\u0026#39;) # Timestamp(\u0026#39;2022-05-01 00:00:00\u0026#39;) ts.month # 5 ts.day # 1 ts + pd.Timedelta(\u0026#39;5 days\u0026#39;) # Timestamp(\u0026#39;2022-05-06 00:00:00\u0026#39;) pd.Series(pd.date_range(start=\u0026#39;2022-05-01\u0026#39;, periods=5, freq=\u0026#39;12H\u0026#39;)) \u0026#39;\u0026#39;\u0026#39; 0 2022-05-01 00:00:00 1 2022-05-01 12:00:00 2 2022-05-02 00:00:00 3 2022-05-02 12:00:00 4 2022-05-03 00:00:00 dtype: datetime64[ns] \u0026#39;\u0026#39;\u0026#39; # Reas csv with timestamps df = pd.read_csv(\u0026#39;./data.csv\u0026#39;, index_col=0, parse_dates=True) df[\u0026#39;2022\u0026#39;] df[\u0026#39;2022-01\u0026#39;:\u0026#39;2022-02\u0026#39;] df.resample(\u0026#39;2D\u0026#39;).mean().head() # Two days as a period df.resample(\u0026#39;M\u0026#39;).max().head() # One month as a period    Big Data Techniques Datatype Conversion 1 2 3 4 5  # Assume we want to decrease the data memory space df_float = df.select_dtypes(include=[\u0026#39;float64\u0026#39;]) converted_float = df_float.apply(pd.to_numeric, downcast=\u0026#39;float\u0026#39;) print(mem_usage(df_float)) print(mem_usage(converted_float))   Property Conversion 1 2 3 4 5 6 7 8  # Assuming data contains weekdays, we can set same weekday to share the same memory space. # 70 weekdays may result in 70 memory space. we convert the \u0026#39;object\u0026#39; into \u0026#39;category\u0026#39; for data to share memory space. df_obj = df.select_dtypes(include=[\u0026#39;object\u0026#39;]) dow = df_obj.weekday # Assume there is a column called \u0026#39;weekday\u0026#39; dow_cat = dow.astype(\u0026#39;category\u0026#39;) dow_cat.cat.codes # We can see there are only 7 encoding ways print(mem_usage(df_float)) print(mem_usage(converted_float))    Reference  Pandas Documentation Pandas Tutorial   ","date":"2022-04-30T22:20:26+08:00","permalink":"https://tonyfpy.github.io/p/data-analysis-topic-2-pandas/","title":"[Data Analysis] Topic 2: Pandas"},{"content":" Authored by Tony Feng\nCreated on April 30th, 2022\nLast Modified on April 30th, 2022\n Task 1 - Q64. 求1+2+…+n Question 求 1+2+\u0026hellip;+n ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。\nSolution 1 1 2 3  class Solution: # built-in function def sumNums(self, n: int) -\u0026gt; int: return sum(range(1, n+1))   Solution 2 1 2 3  class Solution: # logical operation def sumNums(self, n: int) -\u0026gt; int: return n and (n + self.sumNums(n-1))   Explanation  Solution 1 \u0026amp; 2  Time Complexity: O(N) Space Complexity: O(N)     Task 2 - Q68,I. 二叉搜索树的最近公共祖先 Question 给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。题目中所有节点的值都是唯一的，p、q 为不同节点且均存在于给定的二叉搜索树中。\n最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”\nSolution 1 1 2 3 4 5 6 7 8 9 10  class Solution: # Iteration def lowestCommonAncestor(self, root: \u0026#39;TreeNode\u0026#39;, p: \u0026#39;TreeNode\u0026#39;, q: \u0026#39;TreeNode\u0026#39;) -\u0026gt; \u0026#39;TreeNode\u0026#39;: while root: if root.val \u0026gt; p.val and root.val \u0026gt; q.val: root = root.left elif root.val \u0026lt; p.val and root.val \u0026lt; q.val: root = root.right else: break return root   Solution 2 1 2 3 4 5 6 7 8  class Solution: # Recursion def lowestCommonAncestor(self, root: \u0026#39;TreeNode\u0026#39;, p: \u0026#39;TreeNode\u0026#39;, q: \u0026#39;TreeNode\u0026#39;) -\u0026gt; \u0026#39;TreeNode\u0026#39;: if root.val \u0026gt; p.val and root.val \u0026gt; q.val: return self.lowestCommonAncestor(root.left, p, q) elif root.val \u0026lt; p.val and root.val \u0026lt; q.val: return self.lowestCommonAncestor(root.right, p, q) else: return root   Explanation  Since it is a binary search tree, we could use its properties to solve the problem. And no duplicate nodes in the tree.  The nodes in the left sub-tree are smaller than the root. The nodes in the right sub-tree are larger than the root.   Solution 1  Time Complexity: O(N) Space Complexity: O(1)   Solution 2  Time Complexity: O(N) Space Complexity: O(N)     Task 3 - Q68,II. 二叉树的最近公共祖先 Question 给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。\nSolution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  class Solution: def lowestCommonAncestor(self, root: TreeNode, p: TreeNode, q: TreeNode) -\u0026gt; TreeNode: if not root or root == p or root == q: return root r = self.lowestCommonAncestor(root.right, p, q) l = self.lowestCommonAncestor(root.left, p, q) if not r and not l: return None elif r and not l: return r elif not r and l: return l else: return root   Explanation  If a node is the p and q\u0026rsquo;s lowest common ancestor:  p, q exist in different sides of the node respectively. p is the node and q is in its sub-tree. q is the node and p is in its sub-tree.   Solution 1 \u0026amp; 2  Time Complexity: O(N) Space Complexity: O(N)     ","date":"2022-04-30T16:26:20+08:00","permalink":"https://tonyfpy.github.io/p/%E5%89%91%E6%8C%87offer-day-19-search-and-backtracking/","title":"[剑指Offer] Day 19: Search and Backtracking"},{"content":" Authored by Tony Feng\nCreated on April 30th, 2022\nLast Modified on April 30th, 2022\n Intro NumPy is the core library for scientific computing in Python. It provides a high-performance multi-dimensional array object, along with a large collection of high-level mathematical tools for working with these arrays.\n Basics of Arrays Array Initilization 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  import numpy as np # Create a rank 1 array a = np.array([1, 2, 3]) # Create a rank 2 array b = np.array([[1,2,3],[4,5,6]]) # Create an array of all zeros c = np.zeros((2,2)) # array([[ 0. 0.][ 0. 0.]])  d = np.zeros_like(b) # array([[0, 0, 0], [0, 0, 0]])  # Create an array of all ones e = np.ones((1,2)) # array([[ 1. 1.]]) # Create a constant array f = np.full((2,2), 7) # array([[ 7. 7.][ 7. 7.]])  # Create a 2x2 identity matrix g = np.eye(2) # array([[ 1. 0.][ 0. 1.]]) h = np.identity(2) # array([[ 1. 0.][ 0. 1.]]) # Create an array filled with random values i = np.random.random((2,2)) # array([[ 0.91940167 0.08143941][ 0.68744134 0.87236687]]) # Create an empty array and fill it with 1 j = np.empty((3,2)) j.fill(1) # array([[1., 1.], [1., 1.], [1., 1.]])   Array Properties 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  # Get the shape of the array a = np.array([1, 2, 3]) b = np.array([[1,2,3],[4,5,6]]) print(a.shape) # (3,) print(b.shape) # (2, 3) # Get the number of elements of the array print(a.size) # 3 print(b.size) # 6 # Get the dimension of the data print(a.ndim) # 1 print(b.ndim) # 2 # Get the type of the array print(type(a)) # \u0026lt;class \u0026#39;numpy.ndarray\u0026#39;\u0026gt; # Get the type of the elements print(a.dtype) # dtype(\u0026#39;int64\u0026#39;) # The type of the elements in ndarray should be the same.  # Otherwise, int -\u0026gt; float -\u0026gt; string a_list = [1, 2, \u0026#39;3\u0026#39;] a_arr = np.array(a_list) # array([\u0026#39;1\u0026#39;, \u0026#39;2\u0026#39;, \u0026#39;3\u0026#39;]) b_list = [1, 2, 3.0] b_arr = np.array(b_list) # array([1., 2., 3.])    Array Indexing and Slicing Integer Array Indexing 1 2 3 4 5 6 7 8 9 10 11 12 13  a = np.array([[1, 2], [3, 4], [5, 6]]) # Two ways are equivalent below. The shape is (3,). print(a[[0, 1, 2], [0, 1, 0]]) # [1 4 5] print(np.array([a[0, 0], a[1, 1], a[2, 0]])) # [1 4 5] # Create an array of indices # Select one element from each row of a using the indices in b b = np.array([0, 1, 1]) print(a[np.arange(3), b]) # [ 1 4 6] # Mutate one element from each row of a using the indices in b a[np.arange(3), b] += 10 # array([[11 2] [ 3 14] [ 5 16]])   Boolean Array Indexing 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  a = np.array([[1,2], [3, 4], [5, 6]]) # We use boolean array indexing to construct a rank 1 array consisting  # of the elements of a corresponding to the True values of bool_idx. bool_idx = (a \u0026gt; 2) # array([[False False] [ True True] [ True True]]) a[bool_idx] # array([3 4 5 6]) # The above operation is equivalent to these. a[a \u0026gt; 2] # array([3 4 5 6]) a[np.where(a \u0026gt; 2)] # array([3 4 5 6]) x = np.array([1, 0, 3, 4]) y = np.array([1, 2, 3, 5]) x == y # array([ True, False, True, False]) np.logical_and(x, y) # array([ True, False, True, True]) np.logical_or(x, y) # array([ True, True, True, True])   Slicing 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  a = np.array([[1,2,3,4], [5,6,7,8], [9,10,11,12]]) b = a[:2, 1:3] # array([[2, 3], [6, 7]]) c = a[:2, 1:3].copy() # array([[2, 3], [6, 7]]) # A slice of an array is a view into the same data,  # so modifying it will modify the original array. print(a[0, 1]) # 2 b[0, 0] = 77 # b[0, 0] is the same piece of data as a[0, 1] print(a[0, 1]) # 77 c[0, 0] = 88 # c is a new array in a different memory space. print(a[0, 1]) # 77 # Two ways of accessing the data in the middle row of the array. # Mixing integer indexing with slices yields an array of lower rank, # while using only slices yields an array of the same rank as the original array: row_r1 = a[1, :] # Rank 1 view of the second row of a row_r2 = a[1:2, :] # Rank 2 view of the second row of a print(row_r1, row_r1.shape) # [5 6 7 8] (4,) print(row_r2, row_r2.shape) # [[5 6 7 8]] (1, 4) # We can make the same distinction when accessing columns of an array: col_r1 = a[:, 1] col_r2 = a[:, 1:2] print(col_r1, col_r1.shape) # [ 2 6 10] (3,) print(col_r2, col_r2.shape) # [[ 2] [ 6] [10]] (3, 1)    Data Calculation Basic Operations 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44  a = np.array([[1, 2, 3], [4, 5, 6]]) # Summation s1 = np.sum(a) # 27 s2 = np.sum(a, axis=0) # array([5, 7, 9]), shape is (3,) s3 = np.sum(a, axis=1) # array([ 6, 15]), shape is (2,) # Product s1 = np.prod(a) # 720 s2 = np.prod(a, axis=0) # array([4, 10, 18]), shape is (3,) s3 = np.prod(a, axis=1) # array([ 6, 120]), shape is (2,) # Minimum s1 = a.min() # 0 s2 = a.min(axis=0) # array([0, 0, 0]), shape is (3,) s3 = a.min(axis=1) # array([0, 0]), shape is (2,) # The index of the minimum s1 = a.argmin() # 1 s2 = a.argmin(axis=0) # array([1, 2, 3]), shape is (3,) s3 = a.argmin(axis=1) # array([1, 4]), shape is (2,) # Mean s1 = a.mean() # 3.5 s2 = a.mean(axis=0) # array([2.5, 3.5, 4.5]), shape is (3,) s3 = a.mean(axis=1) # array([2., 5.]), shape is (2,) # Standard Deviation s1 = a.std() s2 = a.std(axis=0) s3 = a.std(axis=1) # Variance s1 = a.var() s2 = a.var(axis=0) s3 = a.var(axis=1) # Clip a.clip(2, 4) # array([[2, 2, 3], [4, 4, 4]]),  # i.e., num -\u0026gt; 2 if num \u0026lt; 2; num -\u0026gt; 4 if num \u0026gt; 4 # Round a = np.array([1.1, 2.5, 3.8]) a.round(decimals=0) # array([1., 2., 4.])   Matrix Operation 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47  x = np.array([[1,2],[3,4]], dtype=np.float64) y = np.array([[5,6],[7,8]], dtype=np.float64) # Elementwise sum; both produce the array x + y np.add(x, y) # Elementwise difference; both produce the array x - y np.subtract(x, y) # Elementwise product; both produce the array x * y np.multiply(x, y) # Elementwise division; both produce the array x / y np.divide(x, y) # Elementwise square root; produces the array np.sqrt(x) v = np.array([9,10]) w = np.array([11, 12]) # Inner product of vectors; both produce 219 v.dot(w)) np.dot(v, w) # Matrix - Vector product; both produce the rank 1 array [29 67] x.dot(v) np.dot(x, v) # Matrix - Matrix product; both produce the rank 2 array x.dot(y) np.dot(x, y) # Transposing x = np.array([[1,2], [3,4]]) x # array([[1 2][3 4]]) x.T # array([[1 3][2 4]]) x.transpose() # array([[1 3][2 4]]) v = np.array([1,2,3]) # Note that taking the transpose of a rank 1 array does nothing v # array([1 2 3]) v.T # array([1 2 3])    Useful Modules Sorting 1 2 3 4 5 6 7  a = np.array([[1, 5, 3], [4, 2, 6]]) # Sort np.sort(a, axis=0) # array([[1 2 3] [4 5 6]]), axis = 0 by default  np.sort(a, axis=1) # array([[1 3 5] [2 4 6]]) # Sort and get index np.argsort(a) # array([[0 2 1] [1 0 2]])   Reshaping 1 2 3 4 5 6 7 8 9 10  a = np.arange(6) # array([0, 1, 2, 3, 4, 5]) # Change the shape a.shape = 2,3 # array([[0, 1, 2], [3, 4, 5]]) # Dimensionality Manipulation a = np.arange(10) a = a[np.newaxis,:] # shape is (1, 10) a = a.squeeze() # shape is (10, )  a = a[:, np.newaxis] # shape is (10, 1)   Concatenation 1 2 3 4 5 6 7 8 9 10  a = np.array([[1, 2, 3], [4, 5, 6]]) b = np.array([[7, 8, 9], [10, 11, 12]]) c = np.concatenate((a, b), axis=0) # array([[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12]]) # np.vstack((a, b)) d = np.concatenate((a, b), axis=1) # array([[1, 2, 3, 7, 8, 9], [4, 5, 6, 10, 11, 12]]) # np.hstack((a, b)) # Flatten c.flatten() # array([ 1, 2, 3, 7, 8, 9, 4, 5, 6, 10, 11, 12]), i.e. shape is (12,) d.flatten() # array([ 1, 2, 3, 7, 8, 9, 4, 5, 6, 10, 11, 12]), i.e. shape is (12,)   Randomization 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  # Create a random matrix a = np.random.rand(3,4) # Create a matrix whose range is specified b = np.random.randint(10, size=(3,2)) # Get an random number c = np.random.rand() # Create an 10-elements array in Gaussian distribution, whose mean is 1 and var is 0.1 np.set_printoptions(precision=2) # Global setup d = np.random.normal(1, 0.1, 10) # Shuffle np.random.shuffle(a) # Specify a seed so that the random results keep same. for i in range(0, 5): init = np.array([1, 2, 3, 4, 5, 6]) np.random.seed(100) for j in range(0, 3): np.random.shuffle(init) print(init)   File Operation 1 2 3 4 5 6 7  \u0026#39;\u0026#39;\u0026#39; If the data produced in execution is massive, it could be stored in .npy to avoid repeated use. ndarray is much efficient than list in computation. \u0026#39;\u0026#39;\u0026#39; a = np.array([[1, 2, 3], [4, 5, 6]]) np.save(\u0026#39;data.npy\u0026#39;, a) np.load(\u0026#39;data.npy\u0026#39;) # array([[1, 2, 3], [4, 5, 6]])    Reference  NumPy Official Website Numpy Tutorial (with Jupyter and Colab)   ","date":"2022-04-30T10:30:44+08:00","permalink":"https://tonyfpy.github.io/p/data-analysis-topic-1-numpy/","title":"[Data Analysis] Topic 1: NumPy"},{"content":" Authored by Tony Feng\nCreated on April 29th, 2022\nLast Modified on April 29th, 2022\n Task 1 - Q55,I. 二叉树的深度 Question 输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。\nSolution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None class Solution: def maxDepth(self, root: TreeNode) -\u0026gt; int: if not root: return 0 depthL = self.maxDepth(root.left) depthR = self.maxDepth(root.right) return 1 + max(depthL, depthR)   Explanation  Time Complexity: O(N) Space Complexity: O(N)   Task 2 - Q55,II. 平衡二叉树 Question Solution 1 1 2 3 4 5 6 7 8 9 10 11 12 13 14  class Solution: def isBalanced(self, root: TreeNode) -\u0026gt; bool: if not root: return True elif abs(self.getDepth(root.left) - self.getDepth(root.right)) \u0026lt;= 1: return self.isBalanced(root.left) and self.isBalanced(root.right) else: return False def getDepth(self, node): # A self-defined function to get the depth if not node: return 0 else: return 1 + max(self.getDepth(node.left), self.getDepth(node.right))   Solution 2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  class Solution: def isBalanced(self, root: TreeNode) -\u0026gt; bool: def recur(root): if not root: return 0 left = recur(root.left) if left == -1: return -1 # -1 means the tree is imbalanced right = recur(root.right) if right == -1: return -1 return max(left, right) + 1 if abs(left - right) \u0026lt;= 1 else -1 return recur(root) != -1   Explanation  Solution 1  Time Complexity: O(N * log(N))  I believe the worst case is when the tree is balanced, so the depth of the tree is log(N) If the tree is like a linked list, the algorihtm will stop once the height difference exceeds 1 and will not go through the rest nodes of the tree. getDepth: O(log(N)) isBalanced: O(N)   Space Complexity: O(N)   Solution 2  Time Complexity: O(N) Space Complexity: O(N)     ","date":"2022-04-29T16:22:29+08:00","permalink":"https://tonyfpy.github.io/p/%E5%89%91%E6%8C%87offer-day-18-search-and-backtracking/","title":"[剑指Offer] Day 18: Search and Backtracking"},{"content":" Authored by Tony Feng\nCreated on April 28th, 2022\nLast Modified on April 28th, 2022\n Task 1 - Q40. 最小的k个数 Question 输入整数数组 arr ，找出其中最小的 k 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。\nSolution 1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  class Solution: def getLeastNumbers(self, arr: List[int], k: int) -\u0026gt; List[int]: def quickSort(arr, l, r): if l \u0026gt;= r: # len(subarray) == 1 return i, j = l, r while i \u0026lt; j: while i \u0026lt; j and arr[j] \u0026gt;= arr[l]: j -= 1 while i \u0026lt; j and arr[i] \u0026lt;= arr[l]: i += 1 arr[i], arr[j] = arr[j], arr[i] arr[l], arr[i] = arr[i], arr[l] # arr[l] is the base number and needs to separate two sub-arrays quickSort(arr, l, i - 1) quickSort(arr, i + 1, r) quickSort(arr, 0, len(arr)-1) return arr[:k]   Solution 2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  class Solution: def getLeastNumbers(self, arr: List[int], k: int) -\u0026gt; List[int]: if k \u0026gt;= len(arr): return arr def quickSort(l, r): i, j = l, r while i \u0026lt; j: while i \u0026lt; j and arr[j] \u0026gt;= arr[l]: j -= 1 while i \u0026lt; j and arr[i] \u0026lt;= arr[l]: i += 1 arr[i], arr[j] = arr[j], arr[i] arr[l], arr[i] = arr[i], arr[l] if k \u0026lt; i: return quickSort(l, i - 1) elif k \u0026gt; i: return quickSort(i + 1, r) else: return arr[:k] return quickSort(0, len(arr) - 1)   Explanation  Solution 1  Time Complexity: O(N * log(N)), i.e., quick sort Space Complexity: O(N), i.e., the worst case is the input array is in descending order.   Solution 2  Time Complexity: O(N), i.e., Every time only one side will be processed, N + N/2 + N/4 + N/8 + \u0026hellip; Space Complexity: O(log(N)), i.e., Average recursion depth is log(N).     Task 2 - Q41. 数据流中的中位数 Question 如何得到一个数据流中的中位数？设计一个支持以下两种操作的数据结构：\n void addNum(int num): 从数据流中添加一个整数到数据结构中。 double findMedian(): 返回目前所有元素的中位数。  Solution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  import heapq class MedianFinder: def __init__(self): self.large = [] # A half of larger elements and the top is the smallest in the heap self.small = [] # A half of smaller elements and the top is the bigest in the heap heapq.heapify(self.large) heapq.heapify(self.small) def addNum(self, num: int) -\u0026gt; None: if len(self.large) == len(self.small): # Even number of elements heapq.heappush(self.small, -num) n = -heapq.heappop(self.small) heapq.heappush(self.large, n) else: # Odd number of elements heapq.heappush(self.large, num) n = heapq.heappop(self.large) heapq.heappush(self.small, -n) def findMedian(self) -\u0026gt; float: if len(self.large) == len(self.small): return (self.large[0] - self.small[0])/2 # Find the top elements of two heaps else: return self.large[0]   Explanation  heapq pops only smallest number, so number should be inversed before stored into self.small. Time Complexity  findMedian: O(1) addNum: O(log(N))   Space Complexity: O(N)   ","date":"2022-04-28T20:45:44+08:00","permalink":"https://tonyfpy.github.io/p/%E5%89%91%E6%8C%87offer-day-17-sorting/","title":"[剑指Offer] Day 17: Sorting"},{"content":" Authored by Tony Feng\nCreated on April 27th, 2022\nLast Modified on April 27th, 2022\n Task 1 - Q61. 扑克牌中的顺子 Question 从若干副扑克牌中随机抽 5 张牌，判断是不是一个顺子，即这5张牌是不是连续的。2～10为数字本身，A为1，J为11，Q为12，K为13，而大、小王为 0 ，但可以看成任意数字。A 不能视为 14。\ne.g. 输入: [0,0,1,2,5]; 输出: True\nSolution 1 1 2 3 4 5 6 7 8 9 10 11 12 13 14  class Solution: def isStraight(self, nums: List[int]) -\u0026gt; bool: repeat = set() nMax, nMin = 0, 14 # The range of the Poker cards for num in nums: if num in repeat: return False # If repeated elements exist, return False elif num == 0: continue else: nMax = max(num, nMax) nMin = max(num. nMin) repeat.add(num) return nMax - nMin \u0026lt; 5   Solution 2 1 2 3 4 5 6 7 8 9 10 11  class Solution: def isStraight(self, nums: List[int]) -\u0026gt; bool: joker = 0 nums.sort() for i in range(0, 4): if nums[i] == 0: joker += 1 elif nums[i] == nums[i+1]: return False return nums[4] - nums[joker] \u0026lt; 5   Explanation  Solution 1  Time Complexity: O(N) or O(1), i.e., N = 5 accroding to the questions Space Complexity: O(N) or O(1), i.e., the length of the set is 5   Solution 2  Time Complexity: O(N * log(N)) or O(1) Space Complexity: O(1), i.e., only variable joker is used     Task 2 - Q45. 把数组排成最小的数 Question 输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。\nSolution 1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  class Solution: # Quick Sort def minNumber(self, nums: List[int]) -\u0026gt; str: def quickSort(l , r): if l \u0026gt;= r: return i, j = l, r while i \u0026lt; j: while strs[j] + strs[l] \u0026gt;= strs[l] + strs[j] and i \u0026lt; j: j -= 1 while strs[i] + strs[l] \u0026lt;= strs[l] + strs[i] and i \u0026lt; j: i += 1 strs[i], strs[j] = strs[j], strs[i] strs[i], strs[l] = strs[l], strs[i] quickSort(l, i - 1) quickSort(i + 1, r) strs = list(map(str, nums)) quickSort(0, len(strs) - 1) return \u0026#39;\u0026#39;.join(strs)   Solution 2 1 2 3 4 5 6 7 8 9 10 11 12 13  class Solution: # Built-in sort func def minNumber(self, nums: List[int]) -\u0026gt; str: def sortRule(x, y): if x + y \u0026gt; y + x: return 1 elif x + y \u0026lt; y + x: return -1 else: return 0 strs = list(map(str, nums)) strs.sort(key = functools.cmp_to_key(sortRule)) return \u0026#39;\u0026#39;.join(strs)   Explanation  The problem requires us to sort based on new rules  if int(str(x) + str(y)) \u0026gt; int(str(y) + str(x)), str(x) should be behind str(y). else str(y) should be behind str(x)      Solution 1 \u0026amp; 2  Time Complexity: O(N * log(N)) Space Complexity: O(N)     ","date":"2022-04-27T14:09:46+08:00","permalink":"https://tonyfpy.github.io/p/%E5%89%91%E6%8C%87offer-day-16-sorting/","title":"[剑指Offer] Day 16: Sorting"},{"content":" Authored by Tony Feng\nCreated on April 26th, 2022\nLast Modified on April 28th, 2022\n Intro Recently, I am preparing for the application of 2023 summer intership in US. Since it might be my last industrial internship, this experience would influence my career path to a large extent and pave the way to my future career development. It\u0026rsquo;s time to conisder it comprehensively.\nI would like to consider myself as a freshman in job hunting, because it\u0026rsquo;s my first time to seek employment in another country. In order to find a desirable job placement, I\u0026rsquo;ve gone through many related materials online. In this post, I\u0026rsquo;m gonna talk about Software Devlopment(SD) and Data Science(DS), two popular job directions most CS graduates will choose.\nSD V.S. DS Number of Job Opportunities In general, companies offers more job positions for SD than DS evidently. The ratio is about 10 : 1 in average. SD is more friendly to new graduates than DS in that companies provides more SD placements for them. DS requires the candidates to earn a high education degree or have past working experience.\nJob Categories SD:\n Software Development Engineer Application Developer Full-stack Web Developer Frontend Developer Backend Developer \u0026hellip;  DS:\n Data Scientist Applied Scientist Statistician Business Intelligence Engineer Data/Product/Business Analyst \u0026hellip;  Cross Domain:\n Machine Learning Engineer Deep Learning Engineer Data Engineer \u0026hellip;  Salary The salary may vary depending on your experience, skills, training, certifications and your employer. In general, SD-related professionals are paid higher than DS-related professionals. Reasearch-oriented DS jobs have higher salaries than other kinds of DS jobs, because they are usually demanding and only open for PhDs.\nDegree Requirements SD: Bachlor\u0026rsquo;s degree or higher  DS: Master\u0026rsquo;s degree or higher. Many positions even require a Doctoral degree. \nHard Skills SD:\n Algorithm and Data Structure Programming Paradigms System Design Testing  DS:\n Statistics and Machien Learning Data Manipulation and Modeling Data Visualization Experiemnts Design and Analysis Business Case  Soft Skills Common soft skills are indispensable for SD and DS in your long-term career development.\nBesides, DS requires the candidates to have strong communications skills, data-driven decision making, product sense, etc.\n Job Descriptions  Job responsibilities vary based on employers\u0026rsquo; requirements and should be learned case by case.\n SD  Full-Stack Engineer  Front-End + Back-End UI + Server + Database Configuration   Mobile App Developer  Android / IOS Memory + Computational Power   Graphics Engineer  2D and 3D Digital Platforms for Gaming and Video Production Math + CS Unity, OpenGL   Embedded Systems Engineer  Control of machines   Software Development Engineer in Test(SDET)  Dev + Automated Testing   DevOps Engineer  Dev + Operations + Deployment Network or Sys Admin Source Control / Infrastructure Automation / Cloud    DS  Data Analysts  Datasets -\u0026gt; Analysis -\u0026gt; Visulization(Reports / Resentations / \u0026hellip;) Experiment (A/B testing) + Statistic + SQL / R / Python Product Interpretation + Actionable Insights + Communication   Data Scientist  Data Manipulation + Statistical Modeling + Machine Learning Product Improvement   Applied Scientist / Research Scientist  Independent Research + Literature Review Model Design + Implementation + Optimization Long-term Research   Quant Researcher  Finance + Statistics + Coding Time Series    Cross Domain  Data Engineer  Data Pipeline Data Infrastructure   Machine Learning Engineer  Mathematics + Statistics + Probability Data Modeling and Evaluation ML System Design     Reference  SDE and DS 的求职难度和就业现状 一个典型北美DS master的求职全过程回顾 疫情下我是如何拿到FB DS offer 的？ An introduction to data science careers Data Science vs Software Engineering 数据岗位大合集｜DS、DA、BA和DE的区别及求职面试重点 你为什么不该选择DS - 可能是2022年最详细的劝退贴 Data Science相关岗位全面解析(DS vs DA vs MLE vs DE) DS找工回顾及资料总结 A Complete Guide To Data Science Career Path – By Great Learning \u0026amp; AIM Software Engineer Career Path Career Paths For Software Developers and Programmers   ","date":"2022-04-26T22:57:49+08:00","permalink":"https://tonyfpy.github.io/p/career-talk-topic-1-sde-or-ds-how-can-i-choose/","title":"[Career Talk] Topic 1: SDE or DS, How Can I Choose?"},{"content":" Authored by Tony Feng\nCreated on April 26th, 2022\nLast Modified on April 26th, 2022\n Task 1 - Q54. 二叉搜索树的第k大节点 Question 给定一棵二叉搜索树，请找出其中第 k 大的节点的值。 e.g. 输入: [5,3,6,2,4,null,null,1], k = 3; 输出: 4 \n1 2 3 4 5 6 7  5 / \\ 3 6 / \\ 2 4 / 1   Solution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None class Solution: def kthLargest(self, root: TreeNode, k: int) -\u0026gt; int: nums = [] def dfs(node): if len(nums) \u0026gt;= k or not node: return dfs(node.right) nums.append(node.val) dfs(node.left) dfs(root) return nums[k-1]   Explanation  We can adopt the properties of binary tree by traversing the tree from the rightest node, which is a reversed version of inorder traverse. Time Complexity: O(N) Space Complexity: O(N)   Task 2 - Q36. 二叉搜索树与双向链表 Question 输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。链表中的每个节点都有一个前驱和后继指针。对于双向循环链表，第一个节点的前驱是最后一个节点，最后一个节点的后继是第一个节点。head 表示指向链表中有最小元素的节点。\n Solution 1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  class Solution: # Use a tmp list def treeToDoublyList(self, root: TreeNode) -\u0026gt; TreeNode: if not root: return None s = [] def dfs(node: TreeNode): # Inorder traverse if node: dfs(node.left) s.append(node) dfs(node.right) # All nodes are stored in a list temporarily dfs(root) # Build doubly list n = len(s) for i in range(1, n - 1): s[i].left = s[i - 1] s[i].right = s[i + 1] # Handle the first and last elements head = s[0] head.left = s[-1] head.right = s[1] if n \u0026gt; 1 else head if n \u0026gt; 1: head.left.left = s[-2] head.left.right = head return head   Solution 2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  class Solution: # DFS def treeToDoublyList(self, root: TreeNode) -\u0026gt; TreeNode: if not root: return None def dfs(cur: TreeNode): # Inorder traverse if cur: dfs(cur.left) if self.pre: self.pre.right, cur.left = cur, self.pre else: self.head = cur # head points to the leftest node self.pre = cur dfs(cur.right) self.pre = None # global var dfs(root) self.head.left, self.pre.right = self.pre, self.head return self.head   Explanation  Solution 1 \u0026amp; 2:  Time Complexity: O(N) Space Complexity: O(N)     Task 3 - Q34. 二叉树中和为某一值的路径 Question 给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径。\nSolution 1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class Solution: # DFS def pathSum(self, root: TreeNode, target: int) -\u0026gt; List[List[int]]: if not root: return [] res = [] def dfs(node, curSum, tmp): curSum += node.val tmp.append(node.val) if not node.left and not node.right: if curSum == target: res.append(tmp[:]) return if node.left: dfs(node.left, curSum, tmp) tmp.pop() if node.right: dfs(node.right, curSum, tmp) tmp.pop() dfs(root, 0, []) return res   Solution 2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  class Solution: # DFS def pathSum(self, root: TreeNode, sum: int) -\u0026gt; List[List[int]]: res, path = [], [] def dfs(root, cnt): if not root: return path.append(root.val) cnt -= root.val if cnt == 0 and not root.left and not root.right: res.append(path[:]) dfs(root.left, cnt) dfs(root.right, cnt) path.pop() dfs(root, sum) return res   Explanation  Solution 1 is my solution and Solution 2 is from others. Both of them adopt DFS, but they are slightly different. Time Complexity: O(N) Space Complexity: O(N)   ","date":"2022-04-26T17:28:50+08:00","permalink":"https://tonyfpy.github.io/p/%E5%89%91%E6%8C%87offer-day-15-searching-and-backtracking/","title":"[剑指Offer] Day 15: Searching and Backtracking"},{"content":" Authored by Tony Feng\nCreated on April 25th, 2022\nLast Modified on April 25th, 2022\n Task 1 - Q13. 机器人的运动范围 Question 地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？\nSolution 1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  class Solution: # BFS def movingCount(self, m: int, n: int, k: int) -\u0026gt; int: grid = [[0 for _ in range(n)] for _ in range(m)] q, cnt = [], 0 def sumCoord(i, j): total = 0 while i \u0026gt; 0: total += i % 10 i = i // 10 while j \u0026gt; 0: total += j % 10 j = j // 10 return total if k \u0026gt;= 0: q.append([0,0]) grid[0][0] = 1 # Mark as visited cnt += 1 while q: [x,y] = q.pop(0) if x+1 \u0026lt; m and grid[x+1][y] == 0 and sumCoord(x+1, y) \u0026lt;= k: q.append([x+1,y]) grid[x+1][y] = 1 cnt += 1 if y+1 \u0026lt; n and grid[x][y+1] == 0 and sumCoord(x, y+1) \u0026lt;= k: q.append([x,y+1]) grid[x][y+1] = 1 cnt += 1 return cnt   Solution 2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  class Solution: # DFS def movingCount(self, m: int, n: int, k: int) -\u0026gt; int: grid = [[0] * n for _ in range(m)] def sumCoord(i, j): total = 0 while i \u0026gt; 0: total += i % 10 i = i // 10 while j \u0026gt; 0: total += j % 10 j = j // 10 return total def dfs(x, y): if x \u0026lt; 0 or x \u0026gt;= m or y \u0026lt; 0 or y \u0026gt;= n or grid[x][y] == 1 or sumCoord(x, y) \u0026gt; k: return 0 grid[x][y] = 1 # Mark as visited return 1 + dfs(x + 1, y) + dfs(x, y + 1) return dfs(0, 0)   Explanation  This question is similar to the Leetcode 200, Number of Islands. Because of the properties of position indexes, we only need to check the right and down directions instead of all directions. Solution 1 \u0026amp; 2  Time Complexity: O(M * N) Space Complexity: O(M * N)     Task 2 - Q12. 矩阵中的路径 Question 给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。\n单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。\nSolution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  class Solution: # DFS def exist(self, board: List[List[str]], word: str) -\u0026gt; bool: def dfs(x, y, id): if x \u0026lt; 0 or y \u0026lt; 0 or x \u0026gt;= len(board) or y \u0026gt;= len(board[0]) or board[x][y] != word[id]: return False elif id == len(word)-1: # Tracking which character is being tracked return True else: board[x][y] = \u0026#34;\u0026#34; # Mark as visited so that same elements won\u0026#39;t be used multiple times res = dfs(x-1, y, id+1) or dfs(x, y-1, id+1) or dfs(x+1, y, id+1) or dfs(x, y+1, id+1) board[x][y] = word[id] # Put the original value back return res m, n = len(board), len(board[0]) for i in range(0, m): for j in range(0, n): if dfs(i, j, 0): return True return False   Explanation  Time Complexity: O(3K * M * N)  The length of the string is K and there are 4-1 options each time. The time would be O(3K) There are M * N grids in total   Space Complexity: O(K)  The depth of recursion is no longer than K. In the worst case, K = MN.     ","date":"2022-04-25T20:17:54+08:00","permalink":"https://tonyfpy.github.io/p/%E5%89%91%E6%8C%87offer-day-14-searching-and-backtracking/","title":"[剑指Offer] Day 14: Searching and Backtracking"},{"content":" Authored by Tony Feng\nCreated on April 24th, 2022\nLast Modified on April 24th, 2022\n Task 1 - Q21. 调整数组顺序使奇数位于偶数前面 Question 输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数在数组的前半部分，所有偶数在数组的后半部分。\nSolution 1 1 2 3 4 5 6 7 8 9 10 11 12 13  class Solution: # Head \u0026amp; Tail def exchange(self, nums: List[int]) -\u0026gt; List[int]: i, j = 0, len(nums) - 1 while i \u0026lt; j: # Traverse the array from two sides if nums[i] % 2 == 1: i += 1 elif nums[j] % 2 == 0: j -= 1 else: nums[i], nums[j] = nums[j], nums[i] i += 1 j -= 1 return nums   Solution 2 1 2 3 4 5 6 7 8 9  class Solution: # Fast \u0026amp; Slow def exchange(self, nums: List[int]) -\u0026gt; List[int]: slow = fast = 0 while fast \u0026lt; len(nums): if nums[fast] % 2 == 1: # Find odd number and swap no matter what slow points to nums[slow], nums[fast] = nums[fast], nums[slow] slow += 1 fast += 1 return nums   Explanation  Solution 1 \u0026amp; 2  Time Complexity: O(N) Space Complexity: O(1)     Task 2 - Q57. 和为s的两个数字 Question 输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，则输出任意一对即可。\nSolution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  class Solution: def twoSum(self, nums: List[int], target: int) -\u0026gt; List[int]: if len(nums) \u0026lt;= 1: return None l, r = 0, len(nums)-1 # Head \u0026amp; Tail while nums[r] \u0026gt; target: # Ignore the number who\u0026#39;s larger than the target r -= 1 while l \u0026lt; r: if nums[l] + nums[r] \u0026gt; target: r -= 1 elif nums[l] + nums[r] \u0026lt; target: l += 1 else: return [nums[l], nums[r]] return None   Explanation  Time Complexity: O(N) Space Complexity: O(1)   Task 3 - Q58,I. 翻转单词顺序 Question 输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。 要求：\n 为简单起见，标点符号和普通字母一样处理。 \u0026ldquo;I am a student. \u0026quot; -\u0026gt;\u0026ldquo;student. a am I\u0026rdquo;。 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。  \u0026quot; hello world! \u0026quot; -\u0026gt; \u0026ldquo;world! hello\u0026rdquo;  如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。 \u0026ldquo;a good example\u0026rdquo; -\u0026gt; \u0026ldquo;example good a\u0026rdquo;   Solution 1 2 3 4  class Solution: def reverseWords(self, s: str) -\u0026gt; str: # Use the built-in function of Python return (\u0026#34; \u0026#34;).join(s.split()[::-1])   Explanation  Time Complexity: O(N) Space Complexity: O(1)   ","date":"2022-04-24T17:27:01+08:00","permalink":"https://tonyfpy.github.io/p/%E5%89%91%E6%8C%87offer-day-13-two-pointers/","title":"[剑指Offer] Day 13: Two Pointers"},{"content":" Authored by Tony Feng\nCreated on April 23rd, 2022\nLast Modified on April 23rd, 2022\n Task 1 - Q25. 合并两个排序的链表 Question 输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。\nSolution 1 1 2 3 4 5 6 7 8 9 10 11  class Solution: # Recursion def mergeTwoLists(self, l1: ListNode, l2: ListNode) -\u0026gt; ListNode: if not l1 or not l2: return l2 or l1 if l1.val \u0026lt;= l2.val: l1.next = self.mergeTwoLists(l1.next, l2) return l1 else: l2.next = self.mergeTwoLists(l1, l2.next) return l2   Solution 2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  class Solution: # Iteration def mergeTwoLists(self, l1: ListNode, l2: ListNode) -\u0026gt; ListNode: dummy = ListNode(0) pre = dummy while l1 and l2: if l1.val \u0026lt;= l2.val: pre.next = l1 l1 = l1.next else: pre.next = l2 l2 = l2.next pre = pre.next pre.next = l1 if l1 else l2 return dummy.next   Explanation  Solution 1  Time Complexity: O(M+N) Space Complexity: O(M+N)   Solution 2  Time Complexity: O(M+N) Space Complexity: O(1)     Task 2 - Q52. 两个链表的第一个公共节点 Question 输入两个链表，找出它们的第一个公共节点。如果两个链表没有交点，返回 null。 要求： - 在返回结果后，两个链表仍须保持原有的结构。 - 程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。\nSolution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  class ListNode: def __init__(self, x): self.val = x self.next = None class Solution: def getIntersectionNode(self, headA: ListNode, headB: ListNode) -\u0026gt; ListNode: if not headA or not headB: return None \u0026#39;\u0026#39;\u0026#39; 1 -\u0026gt; 2 -\u0026gt; 3 -\u0026gt; 4 | 6 -\u0026gt; 3 -\u0026gt; 4 6 -\u0026gt; 3 -\u0026gt; 4 | 1 -\u0026gt; 2 -\u0026gt; 3 -\u0026gt; 4 \u0026#39;\u0026#39;\u0026#39; tmpA, tmpB = headA, headB while tmpA != tmpB: tmpA = tmpA.next if tmpA else headB tmpB = tmpB.next if tmpB else headA return tmpA   Explanation  Time Complexity: O(M+N) Space Complexity: O(1)   ","date":"2022-04-23T16:20:30+08:00","permalink":"https://tonyfpy.github.io/p/%E5%89%91%E6%8C%87offer-day-12-two-pointers/","title":"[剑指Offer] Day 12: Two Pointers"},{"content":" Authored by Tony Feng\nCreated on April 22nd, 2022\nLast Modified on April 22nd, 2022\n Task 1 - Q18. 删除链表的节点 Question 给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。返回删除后的链表的头节点。\nSolution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  class ListNode: def __init__(self, x): self.val = x self.next = None class Solution: def deleteNode(self, head: ListNode, val: int) -\u0026gt; ListNode: if not head: return head node = ListNode(0) # dummy node node.next = head pre = node while head: if head.val != val: pre = pre.next head = head.next else: pre.next = head.next return node.next return node.next   Explanation  Time Complexity: O(N) Space Complexity: O(1)   Task 2 - Q22. 链表中倒数第k个节点 Question 输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。 例如，一个链表有 6 个节点，从头节点开始，它们的值依次是 1、2、3、4、5、6。这个链表的倒数第 3 个节点是值为 4 的节点。\nSolution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  class ListNode: def __init__(self, x): self.val = x self.next = None class Solution: # Fast \u0026amp; Slow Pointers def getKthFromEnd(self, head: ListNode, k: int) -\u0026gt; ListNode: fast, slow = head, head # Let the Fast go through k nodes  while fast and k \u0026gt; 0: fast = fast.next k = k - 1 while fast: fast = fast.next slow = slow.next return slow   Explanation  Time Complexity: O(N) Space Complexity: O(1)   ","date":"2022-04-22T16:48:56+08:00","permalink":"https://tonyfpy.github.io/p/%E5%89%91%E6%8C%87offer-day-11-linked-list/","title":"[剑指Offer] Day 11: Linked List"},{"content":" Authored by Tony Feng\nCreated on April 21st, 2022\nLast Modified on April 21st, 2022\n Task 1 - Q48. 最长不含重复字符的子字符串 Question 请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。 e.g.  输入: \u0026ldquo;abcabcbb\u0026rdquo;, 输出: 3  解释: 因为无重复字符的最长子串是 \u0026ldquo;abc\u0026rdquo;，所以其长度为 3。\nSolution 1 2 3 4 5 6 7 8 9 10  class Solution: def lengthOfLongestSubstring(self, s: str) -\u0026gt; int: dict = {} res = tmp = 0 for j in range(0, len(s)): i = dict.get(s[j], -1) # get index i, the position where s[j] exists dict[s[j]] = j # update the hash map tmp = tmp + 1 if tmp \u0026lt; j - i else j - i # dp[j - 1] -\u0026gt; dp[j] res = max(res, tmp) # max(dp[j - 1], dp[j]) return res   Explanation  tmp records the length of the unrepeated substring ending with s[j]. dict records the last position where each key exists. Time Complexity: O(N) Space Complexity: O(1)   Task 2 - Q46. 把数字翻译成字符串 Question 给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。 e.g.  输入: 12258, 输出: 5  解释: 12258有5种不同的翻译，分别是\u0026quot;bccfi\u0026quot;, \u0026ldquo;bwfi\u0026rdquo;, \u0026ldquo;bczi\u0026rdquo;, \u0026ldquo;mcfi\u0026quot;和\u0026quot;mzi\u0026rdquo; \nSolution 1 1 2 3 4 5 6 7 8 9 10 11 12 13 14  class Solution: # dp def translateNum(self, num: int) -\u0026gt; int: num = list(str(num)) dp = [1 for _ in range(0, len(num)+1)] # dp[0] == dp[1] == 1 for i in range(2, len(num)+1): # dp[i] means the sum of the approaches before num[i] (i.e., num[0] ... num[i-1]) # Be careful with the index here if int(num[i-2] + num[i-1]) \u0026lt; 26 and int(num[i-2]) != 0: dp[i] = dp[i-1] + dp[i-2] else: dp[i] = dp[i-1] return dp[-1]   Solution 2 1 2 3 4 5 6 7 8 9 10 11 12 13 14  class Solution: # Recursion def translateNum(self, num: int) -\u0026gt; int: def recur(arr): if len(arr) \u0026lt;= 1: # base case return 1 # no need to count on \u0026#34;01\u0026#34;, \u0026#34;02\u0026#34;, ..., \u0026#34;09\u0026#34;  # no need to count on num \u0026gt;= 26 if int(arr[0] + arr[1]) \u0026lt; 26 and int(arr[0]) != 0: return recur(arr[1:]) + recur(arr[2:]) else: return recur(arr[1:]) return recur(str(num))   Explanation  Solution 1  Time Complexity: O(N) Space Complexity: O(N)   Solution 2  Time Complexity: O(2N) Space Complexity: O(N)     ","date":"2022-04-21T20:31:37+08:00","permalink":"https://tonyfpy.github.io/p/%E5%89%91%E6%8C%87offer-day-10-dynamic-programming/","title":"[剑指Offer] Day 10: Dynamic Programming"},{"content":" Authored by Tony Feng\nCreated on April 20th, 2022\nLast Modified on April 20th, 2022\n Task 1 - Q42. 连续子数组的最大和 Question 输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。要求时间复杂度为 O(n)。\nSolution 1 2 3 4 5 6 7 8 9  class Solution: def maxSubArray(self, nums: List[int]) -\u0026gt; int: tmp = float(\u0026#39;-inf\u0026#39;) maxSum = float(\u0026#39;-inf\u0026#39;) for num in nums: tmp = max(tmp + num, num) # It chooses whether to extend the sub-array or restart from the new item. maxSum = max(maxSum, tmp) # It records the max value after an array has been updated. return maxSum   Explanation  Time Complexity: O(N) Space Complexity: O(1)   Task 2 - Q47. 礼物的最大价值 Question 在一个 m * n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？\nSolution 1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  class Solution: def maxValue(self, grid: List[List[int]]) -\u0026gt; int: if not grid: return 0 dp = [[0 for _ in range(len(grid[0]))] for _ in range(len(grid))] for i in range(0, len(grid)): for j in range(0, len(grid[0])): if i == j == 0: dp[i][j] = grid[i][j] elif i - 1 \u0026lt; 0: dp[i][j] = dp[i][j-1] + grid[i][j] elif j - 1 \u0026lt; 0: dp[i][j] = dp[i-1][j] + grid[i][j] else: dp[i][j] = grid[i][j] + max(dp[i][j-1], dp[i-1][j]) return dp[-1][-1]   Solution 2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  class Solution: # Space Optimization def maxValue(self, grid: List[List[int]]) -\u0026gt; int: if not grid: return 0 for i in range(0, len(grid)): for j in range(0, len(grid[0])): if i == j == 0: continue elif i - 1 \u0026lt; 0: grid[i][j] += grid[i][j-1] elif j - 1 \u0026lt; 0: grid[i][j] += grid[i-1][j] else: grid[i][j] += max(grid[i][j-1], grid[i-1][j]) return grid[-1][-1]   Explanation  Solution 2 is an optimized version of solution 1 in the spatial dimension. Time Complexity: O(N) Space Complexity  Solution 1: O(N) Solution 2: O(1)     ","date":"2022-04-20T22:13:36+08:00","permalink":"https://tonyfpy.github.io/p/%E5%89%91%E6%8C%87offer-day-9-dynamic-programming/","title":"[剑指Offer] Day 9: Dynamic Programming"},{"content":" Authored by Tony Feng\nCreated on April 19th, 2022\nLast Modified on April 19th, 2022\n Task 1 - Q10,I. 斐波那契数列 Question 写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项。 斐波那契数列的定义如下： F(0) = 0, F(1) = 1 F(N) = F(N - 1) + F(N - 2), N \u0026gt; 1 答案需要取模 1e9+7（1000000007）\nSolution 1 1 2 3 4 5 6 7 8 9 10 11  class Solution: def fib(self, n: int) -\u0026gt; int: MOD = 10 ** 9 + 7 if n \u0026lt;= 1 : return n dp = [0] * (n+1) dp[1] = 1 for i in range(2, n+1): dp[i] = (dp[i-1] + dp[i-2]) % MOD return dp[n]   Solution 2 1 2 3 4 5 6 7 8 9 10  class Solution: def fib(self, n: int) -\u0026gt; int: MOD = 10 ** 9 + 7 if n \u0026lt;= 1: return n p, q, r = 0, 0, 1 for i in range(2, n + 1): p = q q = r r = (p + q) % MOD return r   Explanation  Solution 1 \u0026amp; 2 use the same idea, dynamic programming. However, solution 2 is more spatially-efficient. Time Complexity: O(N) Space Complexity  Solution 1: O(N) Solution 2: O(1)     Task 2 - Q10,II. 青蛙跳台阶问题 Question 一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法? 答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。\nSolution 1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  class Solution: # Recursion def numWays(self, n: int) -\u0026gt; int: if n \u0026lt;= 1: return 1 MOD = 10 ** 9 + 7 buffer = [-1] * (n+1) # Avoid repeated calculation buffer[0], buffer[1] = 1, 1 def recur(num): if buffer[num] != -1: return buffer[num] else: res = (recur(num-1) + recur(num-2)) % MOD buffer[num] = res return res return recur(n)   Solution 2 1 2 3 4 5 6 7  class Solution: # DP def numWays(self, n: int) -\u0026gt; int: a, b = 1, 1 MOD = 10 ** 9 + 7 for _ in range(n): a, b = b, (a + b) % MOD return a   Explanation  Solution1  Time Complexity: O(N) Space Complexity: O(N)   Solution2  Time Complexity: O(N) Space Complexity: O(1)     Task 3 - Q63. 股票的最大利润 Question 假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？ 输入: [7,1,5,3,6,4], 输出: 5  解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5。注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。\nSolution 1 1 2 3 4 5 6 7 8 9 10 11  class Solution: def maxProfit(self, prices: List[int]) -\u0026gt; int: if len(prices) \u0026lt;= 1: return 0 dp = [0] * len(prices) minP = prices[0] for i in range(1, len(prices)): dp[i] = max(dp[i-1], prices[i]-minP) minP = min(minP, prices[i]) return dp[-1]   Solution 2 1 2 3 4 5 6 7 8 9 10  class Solution: def maxProfit(self, prices: List[int]) -\u0026gt; int: if len(prices) \u0026lt;= 1: return 0 minPrice, maxProfit = float(\u0026#34;+inf\u0026#34;), 0 for price in prices: minPrice = min(minPrice, price) maxProfit = max(maxProfit, price - minPrice) return maxProfit   Explanation  Time Complexity: O(N) Space Complexity  Solution 1: O(N) Solution 2: O(1)     ","date":"2022-04-19T22:13:32+08:00","permalink":"https://tonyfpy.github.io/p/%E5%89%91%E6%8C%87offer-day-8-dynamic-programming/","title":"[剑指Offer] Day 8: Dynamic Programming"},{"content":" Authored by Tony Feng\nCreated on April 18th, 2022\nLast Modified on April 18th, 2022\n Task 1 - Q26. 树的子结构 Question 输入两棵二叉树A和B，判断B是不是A的子结构。若B是A的子结构，即A中有出现和B相同的结构和节点值。(约定空树不是任意一个树的子结构)\nSolution 1 2 3 4 5 6 7 8 9 10 11 12 13  class Solution: def isSubStructure(self, A: TreeNode, B: TreeNode) -\u0026gt; bool: if not B or not A: return False def compare(nodeA, nodeB): if not nodeB: # Finish checking all nodes in B return True if not nodeA: # nodeA is empty but nodeB not return False return nodeA.val == nodeB.val and compare(nodeA.left, nodeB.left) and compare(nodeA.right, nodeB.right) return (compare(A, B) or self.isSubStructure(A.left, B) or self.isSubStructure(A.right, B))   Explanation  N = # of nodes in tree A; M = # of nodes in tree B Time Complexity: O(N*M) Space Complexity: O(N)  The worst case is traversing the whole tree A.     Task 2 - Q27. 二叉树的镜像 Question 请完成一个函数，输入一个二叉树，该函数输出它的镜像。(类似于水平翻转)\nSolution 1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  class MySolution: # BFS def mirrorTree(self, root: TreeNode) -\u0026gt; TreeNode: if not root: return None mRoot = TreeNode(root.val) que = [root] mQue = [mRoot] while que: node = que.pop(0) mNode = mQue.pop(0) if node.left: mNode.right = TreeNode(node.left.val) mQue.append(mNode.right) que.append(node.left) if node.right: mNode.left = TreeNode(node.right.val) mQue.append(mNode.left) que.append(node.right) return mRoot class Solution: # BFS def mirrorTree(self, root: TreeNode) -\u0026gt; TreeNode: if not root: return stack = [root] # FILO while stack: node = stack.pop() if node.left: stack.append(node.left) if node.right: stack.append(node.right) node.left, node.right = node.right, node.left return root   Solution 2 1 2 3 4 5 6 7  class Solution: # Recursion def mirrorTree(self, root: TreeNode) -\u0026gt; TreeNode: if not root: return root.left = self.mirrorTree(root.right) root.right = self.mirrorTree(root.left) return root   Explanation  My solution and solution 1 have the same idea, but the latter is more tricky. Solution1 \u0026amp; 2  Time Complexity: O(N) Space Complexity: O(N)     Task 3 - Q28. 对称的二叉树 Question 请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。\nSolution 1 2 3 4 5 6 7 8 9 10  class Solution: def isSymmetric(self, root: TreeNode) -\u0026gt; bool: def recur(L, R): if not L and not R: return True if not L or not R: return False return L.val == R.val and recur(L.left, R.right) and recur(L.right, R.left) return recur(root.left, root.right) if root else True   Explanation  Time Complexity: O(N)  The algorithm calls the recur() for N/2 times at most.   Space Complexity: O(N)   ","date":"2022-04-18T22:13:27+08:00","permalink":"https://tonyfpy.github.io/p/%E5%89%91%E6%8C%87offer-day-7-searching-and-backtracking/","title":"[剑指Offer] Day 7: Searching and Backtracking"},{"content":" Authored by Tony Feng\nCreated on April 17th, 2022\nLast Modified on April 17th, 2022\n Task 1 - Q32 - I. 从上到下打印二叉树 Question 从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。\nSolution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None class Solution: # BFS def levelOrder(self, root: TreeNode) -\u0026gt; List[int]: if not root: return [] res, tmp = [], [] tmp.append(root) while tmp: # Break until the queue is empty node = tmp.pop(0) res.append(node.val) if node.left: tmp.append(node.left) if node.right: tmp.append(node.right) return res   Explanation  Time Complexity: O(N)  The algorithm needs to go through every node.   Space Complexity: O(N)  At most N/2 nodes are in the queue at the same time.     Task 2 - Q32 - II. 从上到下打印二叉树 II Question 从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。\nSolution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None class Solution: def levelOrder(self, root: TreeNode) -\u0026gt; List[List[int]]: if not root: return [] res, tmp = [], [root] while tmp: level = [] for _ in range(0, len(tmp)): # Tracing the number of nodes on each level node = tmp.pop(0) if node.left: tmp.append(node.left) if node.right: tmp.append(node.right) level.append(node.val) res.append(level) return res   Explanation  Time Complexity: O(N) Space Complexity: O(N)   Task 3 - Q32 - III. 从上到下打印二叉树 III Question 请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。\nSolution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None from collections import deque class Solution: def levelOrder(self, root: TreeNode) -\u0026gt; List[List[int]]: if not root: return [] res, tmp = [], [root] while tmp: level = deque() for _ in range(len(tmp)): node = tmp.pop(0) if len(res) % 2 == 0: # res contains the traversed nodes level.append(node.val) # level will contain the next level of nodes else: level.appendleft(node.val) if node.left: tmp.append(node.left) if node.right: tmp.append(node.right) res.append(list(level)) return res   Explanation  Time Complexity: O(N) Space Complexity: O(N)   ","date":"2022-04-17T22:13:20+08:00","permalink":"https://tonyfpy.github.io/p/%E5%89%91%E6%8C%87offer-day-6-searching-and-backtracking/","title":"[剑指Offer] Day 6: Searching and Backtracking"},{"content":" Authored by Tony Feng\nCreated on April 16th, 2022\nLast Modified on April 16th, 2022\n Task 1 - Q04. 二维数组中的查找 Question 在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 e.g.  [1, 4, 7, 11, 15],  [2, 5, 8, 12, 19],  [3, 6, 9, 16, 22],  [10, 13, 14, 17, 24],  [18, 21, 23, 26, 30]\nSolution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  class Solution: def findNumberIn2DArray(self, matrix: List[List[int]], target: int) -\u0026gt; bool: if matrix == [] or matrix == [[]]: return False n, m = len(matrix), len(matrix[0]) i, j = 0, m-1 while i \u0026lt;= n-1 and j \u0026gt;= 0: if matrix[i][j] \u0026gt; target: j -= 1 elif matrix[i][j] \u0026lt; target: i += 1 else: return True return False   Explanation  Using the properties of the matrix properly is a trick.  The top-right item is the largest number in its row; The top-right item is the smallest number in its column;   Time Complexity: O(N+M) Space Complexity: O(1)   Task 2 - Q50. 第一个只出现一次的字符 Question 在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。 s 只包含小写字母。\nSolution 1 2 3 4 5 6 7 8 9  class Solution: def firstUniqChar(self, s: str) -\u0026gt; str: dict = {} for c in s: dict[c] = not c in dict for c in s: if dict[c]: return c return \u0026#39; \u0026#39;   Explanation  Time Complexity: O(N) Space Complexity: O(1)  At most 26 keys are in the dictionary.     ","date":"2022-04-16T22:13:16+08:00","permalink":"https://tonyfpy.github.io/p/%E5%89%91%E6%8C%87offer-day-5-searching/","title":"[剑指Offer] Day 5: Searching"},{"content":" Authored by Tony Feng\nCreated on April 15th, 2022\nLast Modified on April 15th, 2022\n Task 1 - Q03. 数组中重复的数字 Question 在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。\nSolution 1 1 2 3 4 5 6 7 8  class Solution: # Hash Map def findRepeatNumber(self, nums: List[int]) -\u0026gt; int: dict = {} for n in nums: if n in dict: return n dict[n] = 1 return -1   Solution 2 1 2 3 4 5 6 7 8  class Solution: # Set def findRepeatNumber(self, nums: [int]) -\u0026gt; int: s = set() for num in nums: if num in s: return num s.add(num) return -1   Explanation  Solution1 and 2 use the same idea but different data structures. Time Complexity: O(N) Space Complexity: O(N)   Task 2 - Q53,I. 在排序数组中查找数字 I Question 统计一个数字在排序数组中出现的次数。\nSolution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  class Solution: # Bianry Search \u0026#39;\u0026#39;\u0026#39; Find the right bound of target and target-1 \u0026#39;\u0026#39;\u0026#39; def search(self, nums: [int], target: int) -\u0026gt; int: def findR(tar): i, j = 0, len(nums) - 1 while i \u0026lt;= j: m = i + (j - i) // 2 if nums[m] \u0026lt;= tar: i = m + 1 else: j = m - 1 return i return findR(target) - findR(target - 1)   Explanation  Time Complexity: O(log N) Space Complexity: O(1)   Task 3 - Q53,II. 0～n-1中缺失的数字 Question 一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。\nSolution 1 2 3 4 5 6 7 8 9 10 11 12 13 14  \u0026#39;\u0026#39;\u0026#39; Find the rightest index that is not equal to its element \u0026#39;\u0026#39;\u0026#39; class Solution: def missingNumber(self, nums: List[int]) -\u0026gt; int: i, j = 0, len(nums)-1 while i \u0026lt;= j: m = i + (j - i) // 2 if m == nums[m]: i = m + 1 else: j = m - 1 return i   Explanation  Time Complexity: O(log N) Space Complexity: O(1)   ","date":"2022-04-15T22:13:09+08:00","permalink":"https://tonyfpy.github.io/p/%E5%89%91%E6%8C%87offer-day-4-searching/","title":"[剑指Offer] Day 4: Searching"},{"content":" Authored by Tony Feng\nCreated on April 14th, 2022\nLast Modified on April 14th, 2022\n Task 1 - Q05. 替换空格 Question 请实现一个函数，把字符串 s 中的每个空格替换成 \u0026quot;%20\u0026quot;。\nSolution 1 1 2 3  class Solution: def replaceSpace(self, s: str) -\u0026gt; str: return s.replace(\u0026#34; \u0026#34;, \u0026#34;%20\u0026#34;)   Solution 2 1 2 3  class Solution: def replaceSpace(self, s: str) -\u0026gt; str: return \u0026#34;%20\u0026#34;.join(s.split(\u0026#34; \u0026#34;))   Explanation  Time Complexity: O(N) Space Complexity: O(N)   Task 2 - Q58,II. 左旋转字符串 Question 字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串\u0026quot;abcdefg\u0026quot;和数字2，该函数将返回左旋转两位得到的结果\u0026quot;cdefgab\u0026quot;。\nSolution 1 1 2 3 4 5  class Solution: def reverseLeftWords(self, s: str, n: int) -\u0026gt; str: s1 = s[0:n] s2 = s[n:] return s2 + s1   Solution 2 1 2 3 4 5 6 7  class Solution: def reverseLeftWords(self, s: str, n: int) -\u0026gt; str: res = \u0026#34;\u0026#34; for i in range(n, len(s) + n): res += s[i % len(s)] return res   Explanation  Solution 2 is less efficient than 1, because additional space are created every time. Time Complexity: O(N) Space Complexity: O(N)   ","date":"2022-04-14T22:13:03+08:00","permalink":"https://tonyfpy.github.io/p/%E5%89%91%E6%8C%87offer-day-3-string/","title":"[剑指Offer] Day 3: String"},{"content":" Authored by Tony Feng\nCreated on April 13th, 2022\nLast Modified on April 13th, 2022\n Task 1 - Q06. 从尾到头打印链表 Question 输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。\nSolution 1 1 2 3 4 5 6 7 8 9 10 11  class Solution: # Iteration def reversePrint(self, head: ListNode) -\u0026gt; List[int]: if not head: return [] res = [] while head: res.append(head.val) head = head.next return res[::-1]   Solution 2 1 2 3 4 5 6  class Solution: # Recursion def reversePrint(self, head: ListNode) -\u0026gt; List[int]: if not head: return [] else: return self.reversePrint(head.next) + [head.val]   Explanation  Solution1 \u0026amp; Solution2  Time Complexity: O(N) Space Complexity: O(N)     Task 2 - Q24. 反转链表 Question 定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。\nSolution 1 1 2 3 4 5 6 7 8 9  class Solution: # Two Pointers def reverseList(self, head: ListNode) -\u0026gt; ListNode: cur, pre = head, None while cur: tmp = cur.next # 暂存后继节点 cur.next cur.next = pre # 修改 next 引用指向 pre = cur # pre 暂存 cur cur = tmp # cur 访问下一节点 return pre   Solution 2 1 2 3 4 5 6 7 8 9 10 11  class Solution: # Recursion def reverseList(self, head: ListNode) -\u0026gt; ListNode: if not head or not head.next: return head node = self.reverseList(head.next) head.next.next = head head.next = None return node   Explanation  Solution1  Time Complexity: O(N) Space Complexity: O(1)   Solution2  Time Complexity: O(N) Space Complexity: O(N)     Task 3 - Q35. 复杂链表的复制 Question 请实现 copyRandomList 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 next 指针指向下一个节点，还有一个 random 指针指向链表中的任意节点或者 null。\nSolution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  class Node: def __init__(self, x: int, next: \u0026#39;Node\u0026#39; = None, random: \u0026#39;Node\u0026#39; = None): self.val = int(x) self.next = next self.random = random class Solution: def copyRandomList(self, head: \u0026#39;Node\u0026#39;) -\u0026gt; \u0026#39;Node\u0026#39;: if not head: return head node_dict = {} cur = head # Traverse the origin nodes and put them in a dictionary while cur: # Mapping the original node to a new node # Only val is updated here node_dict[cur] = Node(x=cur.val) cur = cur.next node_dict[cur] = None # Traverse the dictionary and update the next and random pointer cur = head while cur: node_dict[cur].next = node_dict[cur.next] node_dict[cur].random = node_dict[cur.random] cur = cur.next # Return the head of the new linked list return node_dict[head]   Explanation  Steps  Use a dictionary to record the position of the original nodes Update the next and random pointer in reference to the original nodes   Time Complexity: O(N) Space Complexity: O(N)   ","date":"2022-04-13T22:12:58+08:00","permalink":"https://tonyfpy.github.io/p/%E5%89%91%E6%8C%87offer-day-2-linked-list/","title":"[剑指Offer] Day 2: Linked List"},{"content":" Authored by Tony Feng\nCreated on April 12th, 2022\nLast Modified on May 16th, 2022\n Task 1 - Q09. 用两个栈实现队列 Question 用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )\nSolution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  class CQueue: def __init__(self): self.que = [] self.tmp = [] # Buffer def appendTail(self, value: int) -\u0026gt; None: self.que.append(value) def deleteHead(self) -\u0026gt; int: # Reverse the order while self.que: self.tmp.append(self.que.pop()) head = self.tmp.pop() if self.tmp else -1 while self.tmp: self.que.append(self.tmp.pop()) return head   Explanation  Two Stacks: One is for storage and the other is for buffering. Time Complexity  appendTail: O(1) deleteHead: O(N)   Space Complexity  appendTail: O(N) deleteHead: O(N)     Task 2 - Q30. 包含min函数的栈 Question 定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。\nSolution 1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  class MinStack: def __init__(self): self.stack = [] self.minVal = [] def push(self, x: int) -\u0026gt; None: self.stack.append(x) if self.minVal: self.minVal.append(min(x, self.minVal[-1])) else: self.minVal.append(x) def pop(self) -\u0026gt; None: if self.stack: self.stack.pop() if self.minVal: self.minVal.pop() def top(self) -\u0026gt; int: if self.stack: return self.stack[-1] if self.minVal: return self.minVal[-1] def min(self) -\u0026gt; int: return self.minVal[-1]   Solution 2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  class MinStack: def __init__(self): self.stack = [] def push(self, x: int) -\u0026gt; None: if not self.stack: self.stack.append((x, x)) else: m = self.min() r = min(m, x) self.stack.append((x, r)) def pop(self) -\u0026gt; None: if self.stack: self.stack.pop() def top(self) -\u0026gt; int: if self.stack: return self.stack[-1][0] def min(self) -\u0026gt; int: if self.stack: return self.stack[-1][1]   Explanation  Two Stacks: One is for storage and the other is for tracing the minimum value. Time Complexity: O(1) Space Complexity: O(N)   ","date":"2022-04-12T22:12:52+08:00","permalink":"https://tonyfpy.github.io/p/%E5%89%91%E6%8C%87offer-day-1-stack-and-queue/","title":"[剑指Offer] Day 1: Stack and Queue"},{"content":" Authored by Tony Feng\nCreated on April 10th, 2022\nLast Modified on April 10th, 2022\n Understanding Trie Main Concepts  A trie is a special tree that can compactly store strings. Tries are based on the prefix of a string. They are used to represent the \u0026ldquo;Retrieval\u0026rdquo; of data and thus the name Trie.  Charateristics  Strengths  Sometimes Space-Efficient. If you\u0026rsquo;re storing lots of words that start with similar patterns, tries may reduce the overall storage cost by storing shared prefixes once. Efficient Prefix Queries. Tries can quickly answer queries about words with shared prefixes   Weakness  Usually Space-Inefficient. Tries rarely save space when compared to storing strings in a set. Not Standard. Most languages don\u0026rsquo;t come with a built-in trie implementation.     Example Leetcode 208 Implement Trie (Prefix Tree) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41  class TrieNode: def __init__(self, char = \u0026#34;\u0026#34;): self.char = char self.children = {} self.is_end = False # self.counter = 0 class Trie: def __init__(self): self.root = TrieNode() def insert(self, word: str) -\u0026gt; None: node = self.root for char in word: if char in node.children: node = node.children[char] else: new_node = TrieNode(char) node.children[char] = new_node node = new_node node.is_end = True # node.counter += 1 def search(self, word: str) -\u0026gt; bool: node = self.root for char in word: if char not in node.children: return False node = node.children[char] # Reached at the end of word # return True if word is present, i.e is_end = True else False return node.is_end def startsWith(self, prefix: str) -\u0026gt; bool: node = self.root for char in prefix: if char not in node.children: return False node = node.children[char] return True   Leetcode 720 Longest Word in Dictionary 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  class TrieNode: def __init__(self, val): self.children = {} self.value = val self.endOfWord = False class Solution: def longestWord(self, words: List[str]) -\u0026gt; str: root = TrieNode(0) maxLen = 0 res = \u0026#34;\u0026#34; for word in sorted(words): cur = root count = 0 for letter in word: if letter not in cur.children: cur.children[letter] = TrieNode(count) cur = cur.children[letter] if cur.endOfWord: count += 1 cur.endOfWord = True cur.value += 1 if cur.value == len(word) and cur.value \u0026gt; maxLen: maxLen = cur.value res = word return res    Reference  Trie (Keyword Tree) InterviewCake - Trie 手把手带你刷Leetcode力扣 - 前缀树 Trie 手把手带你刷Leetcode力扣 - Leetcode 720   ","date":"2022-04-10T22:38:44+08:00","permalink":"https://tonyfpy.github.io/p/data-structure-topic-11-trie/","title":"[Data Structure] Topic 11: Trie"},{"content":" Authored by Tony Feng\nCreated on April 10th, 2022\nLast Modified on April 10th, 2022\n Understanding Dynamic Programming Intro  Dynamic Programming helps to efficiently solve a class of problems that have overlapping subproblems and optimal substructure property. Key elements  Initialization State-transition Equation Termination    Characteristics  Overlapping Subproblems  Any problem has overlapping sub-problems if finding its solution involves solving the same subproblem multiple times.   Optimal Substructure Property  Any problem has optimal substructure property if its overall optimal solution can be constructed from the optimal solutions of its subproblems.    Dynamic Programming Methods  Top-down with Memoization  In this approach, we try to solve the bigger problem by recursively finding the solution to smaller sub-problems. Whenever we solve a sub-problem, we cache its result so that we can just return the saved result if it’s called multiple times.   Bottom-up with Tabulation  Tabulation is the opposite of the top-down approach and avoids recursion. In this approach, we solve the problem “bottom-up” (i.e. by solving all the related sub-problems first). This is typically done by filling up an n-dimensional table. Based on the results in the table, the solution to the top/original problem is then computed.     Examples Leetcode 509 Fibonacci Number 1 2 3 4 5 6 7 8 9 10 11 12  class Solution: def fib(self, n: int) -\u0026gt; int: if n == 0: return 0 if n == 1: return 1 dp = [0] * (n + 1) dp[0], dp[1] = 0, 1 for i in range(2, n+1): dp[i] = dp[i-1] + dp[i-2] # State-transition Equation return dp[n]   Leetcode 62 Unique Paths 1 2 3 4 5 6 7 8 9 10 11 12 13 14  class Solution: def uniquePaths(self, m: int, n: int) -\u0026gt; int: dp = [[1 for _ in range(n)] for _ in range(m)] for i in range(0, m): for j in range(0, n): if i - 1 \u0026lt; 0: dp[i][j] = dp[i][j-1] elif j - 1 \u0026lt; 0: dp[i][j] = dp[i-1][j] else: dp[i][j] = dp[i-1][j] + dp[i][j-1] return dp[m - 1][n - 1]    Reference  手把手带你刷Leetcode力扣 - 动态规划 Dynamic Programming 手把手带你刷Leetcode力扣 - Leetcode 509 手把手带你刷Leetcode力扣 - Leetcode 62 What is Dynamic Programming? Programiz - Dynamic Programming   ","date":"2022-04-10T22:37:31+08:00","permalink":"https://tonyfpy.github.io/p/algorithm-topic-10-dynamic-programming/","title":"[Algorithm] Topic 10: Dynamic Programming"},{"content":" Authored by Tony Feng\nCreated on April 9th, 2022\nLast Modified on April 9th, 2022\n Understanding Greedy Search Intro  A greedy algorithm is an approach for solving a problem by selecting the best option available at the moment. It works in a top-down approach. It doesn\u0026rsquo;t guarantee whether the current best result will bring the overall optimal result. We can determine if the algorithm can be used with any problem if the problem has the following properties:  Greedy Choice Property Optimal Substructure    Characteristics  Advantages of Greedy Approach  The algorithm is easier to describe.   Drawback of Greedy Approach  The greedy algorithm doesn\u0026rsquo;t always produce the optimal solution. The difficult part is that for greedy algorithms you have to work much harder to understand correctness issues. Optimization problems (Dijkstra’s Algorithm) with negative graph edges cannot be solved using a greedy algorithm.    Steps  To begin with, the solution set (containing answers) is empty. At each step, an item is added to the solution set until a solution is reached. If the solution set is feasible, the current item is kept. Else, the item is rejected and never considered again.   Template 1 2 3 4 5 6 7 8 9 10  # Pseudocode Greedy(input I): begin while (solution is not complete) do Select the best element x in the remaining input I; Put x next in the output; Remove x from the remaining input; endwhile end    Examples Leetcode 55 Jump Game 1 2 3 4 5 6 7 8 9 10 11 12  class Solution: def canJump(self, nums): \u0026#34;\u0026#34;\u0026#34; :type nums: List[int] :rtype: bool \u0026#34;\u0026#34;\u0026#34; reach = 0 for i, num in enumerate(nums): if i \u0026gt; reach: return False reach = max(reach, i + num) return True    Reference  手把手带你刷Leetcode力扣 - 贪心算法 Greedy Search Greedy Algorithms Explained with Examples   ","date":"2022-04-09T22:37:19+08:00","permalink":"https://tonyfpy.github.io/p/algorithm-topic-9-greedy-search/","title":"[Algorithm] Topic 9: Greedy Search"},{"content":" Authored by Tony Feng\nCreated on April 7th, 2022\nLast Modified on April 9th, 2022\n Understanding Union Find Intro  A disjoint-set data structure keeps track of a set of elements partitioned into a number of disjoint (non-overlapping) subsets. A union-find algorithm performs union and find operation on those subsets. Union-Find Algorithm can be used to check whether an undirected graph contains cycle or not.  Union \u0026amp; Find  Find  It determines in which subset a particular element is in and returns the representative of that particular set.   Union  It merges two different subsets into a single subset, and the representative of one set becomes representative of another.     Template Common Union Find 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  class UnionFind: def __init__(self, n): # Initialization.  # The parent of each node is itself. self.root = list(range(0,n)) def find(self, x): if x == self.root[x]: return self.root[x] else: return self.find(self.root[x]) def union(self, x, y): rootX = self.root[x] rootY = self.root[y] if rootX != rootY: self.root[rootX] = rootY   Union Find Improvement 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  class UnionFind: def __init__(self, n): # Initialization.  # The parent of each node is itself. self.root = list(range(0,n)) self.rank = [0] * n def find(self, x): if x != self.root[x]: # Use recursion to assign the root value self.root[x] = self.find(self.root[x]) return self.root[x] # Avoid the tree to be too high def union(self, x, y): rootX = self.root[x] rootY = self.root[y] if rootX != rootY: if self.rank[rootX] \u0026gt; self.rank[rootY]: self.root[rootY] = rootX elif self.rank[rootX] \u0026lt; self.rank[rootY]: self.root[rootX] = rootY else: self.root[rootY] = rootX self.rank[rootX] += 1    Examples Leetcode 200 Number of Islands 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48  # Time Complexity: O(MN) # Space Complexity: O(MN) class Solution: def numIslands(self, grid: List[List[str]]) -\u0026gt; int: if grid is None or len(grid) == 0: return 0 row = len(grid) col = len(grid[0]) waters = 0 uf = UnionFind(grid) for i in range(0, row): for j in range(0, col): if grid[i][j] == \u0026#39;0\u0026#39;: waters += 1 else: directions = [(0,1), (0,-1), (-1,0), (1,0)] for x, y in directions: x = x + i y = y + j if x\u0026gt;=0 and y\u0026gt;=0 and x\u0026lt;row and y\u0026lt;col and grid[x][y] == \u0026#39;1\u0026#39;: uf.union(x*col+y, i*col+j) return uf.getCount() - waters class UnionFind: def __init__(self, grid): row = len(grid) col = len(grid[0]) self.root = [-1]*(row*col) self.count = row*col for i in range(0, row*col): self.root[i] = i def find(self, x): if x == self.root[x]: return self.root[x] else: self.root[x] = self.find(self.root[x]) return self.root[x] def union(self, x, y): rootX = self.find(x) rootY = self.find(y) if rootX != rootY: self.root[rootX] = rootY self.count -= 1 def getCount(self): return self.count    Reference  手把手带你刷Leetcode力扣 - 并查集 Union Find 手把手带你刷Leetcode力扣 - 并查集优化 Union Find Optimization 手把手带你刷Leetcode力扣 - Leetcode 200 Disjoint Set (Or Union-Find) Disjoint–Set Data Structure (Union–Find Algorithm)   ","date":"2022-04-07T22:37:04+08:00","permalink":"https://tonyfpy.github.io/p/algorithm-topic-8-union-find/","title":"[Algorithm] Topic 8: Union Find"},{"content":" Authored by Tony Feng\nCreated on April 6th, 2022\nLast Modified on April 6th, 2022\n Understanding BFS Intro  Breadth-First Search (BFS) is an algorithm used for traversing graphs or trees. Breadth-First Search is a recursive algorithm to search all the vertices of a graph or a tree. BFS starts from a node, then it checks all the nodes at distance I from the beginning node, then it checks all the nodes at distance II, and so on. In order to re-collect the nodes to be visited, BFS uses a queue. The time complexity of DFS if the entire tree is traversed is O(V), where V is the number of nodes. In the case of a graph, the time complexity is O(V + E), where V is the number of vertexes and E is the number of edges.  Please note that O(E) may vary between O(1) and O(V2), depending on how dense the graph is.    Steps of BFS  Add the root/start node to the Queue. For every node, set that they don\u0026rsquo;t have a defined parent node. Until the Queue is empty:  Extract the node from the beginning of the Queue. Perform output processing. For every neighbor of the current node that doesn\u0026rsquo;t have a defined parent (is not visited), add it to the Queue, and set the current node as their parent.     Template 1 2 3 4 5 6 7 8 9 10 11 12  def bfs(visited, graph, node): #function for BFS visited.append(node) queue.append(node) while queue: # Creating loop to visit each node m = queue.pop(0) print (m, end = \u0026#34; \u0026#34;) for neighbour in graph[m]: if neighbour not in visited: visited.append(neighbour) queue.append(neighbour)    Examples Leetcode 102 Binary Tree Level Order Traversal 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  from collections import deque class Solution: def levelOrder(self, root: Optional[TreeNode]) -\u0026gt; List[List[int]]: if not root: return [] ans = [] q = deque() # Store nodes q.append(root) while len(q) \u0026gt; 0: size = len(q) # Get how many nodes are in current level tmp = [] # Store nodes in the current level while size \u0026gt; 0: node = q.popleft() tmp.append(node.val) if node.left: q.append(node.left) if node.right: q.append(node.right) size -= 1 ans.append(tmp[:]) return ans   Leetcode 200 Number of Islands 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  class Solution: def numIslands(self, grid: List[List[str]]) -\u0026gt; int: if not grid or len(grid) == 0: return 0 res = 0 q = deque() for i in range(0, len(grid)): for j in range(0, len(grid[0])): if grid[i][j] == \u0026#34;1\u0026#34;: res += 1 q.append([i,j]) grid[i][j] = \u0026#34;2\u0026#34; while len(q) \u0026gt; 0: [x,y] = q.popleft() if x-1 \u0026gt;= 0 and grid[x-1][y] == \u0026#34;1\u0026#34;: q.append([x-1,y]) grid[x-1][y] = \u0026#34;2\u0026#34; if x+1 \u0026lt; len(grid) and grid[x+1][y] == \u0026#34;1\u0026#34;: q.append([x+1,y]) grid[x+1][y] = \u0026#34;2\u0026#34; if y-1 \u0026gt;= 0 and grid[x][y-1] == \u0026#34;1\u0026#34;: q.append([x, y-1]) grid[x][y-1] = \u0026#34;2\u0026#34; if y+1 \u0026lt; len(grid[0]) and grid[x][y+1] == \u0026#34;1\u0026#34;: q.append([x, y+1]) grid[x][y+1] = \u0026#34;2\u0026#34; return res    Reference  手把手带你刷Leetcode力扣 - 广度优先搜索 BFS 手把手带你刷Leetcode力扣 - Leetcode 102 手把手带你刷Leetcode力扣 - Leetcode 107 手把手带你刷Leetcode力扣 - Leetcode 200 Breadth First Search in Python (with Code) | BFS Algorithm Graphs in Python: Breadth-First Search (BFS) Algorithm What is Breadth First Search?   ","date":"2022-04-06T22:36:48+08:00","permalink":"https://tonyfpy.github.io/p/algorithm-topic-7-breadth-first-search/","title":"[Algorithm] Topic 7: Breadth-First Search"},{"content":" Authored by Tony Feng\nCreated on April 5th, 2022\nLast Modified on April 5th, 2022\n Understanding DFS Intro  Depth-first search is an algorithm for traversing or searching tree or graph data structures. The algorithm starts at the root node (selecting some arbitrary node as the root node in the case of a graph) and explores as far as possible along each branch before backtracking. The time complexity of DFS if the entire tree is traversed is O(V), where V is the number of nodes; In the case of a graph, the time complexity is O(V + E), where V is the number of vertexes and E is the number of edges.  Steps of DFS  Create a recursive function that takes the index of the node and a visited array. Mark the current node as visited and print the node. Traverse all the adjacent and unmarked nodes and call the recursive function with the index of the adjacent node.   Template 1 2 3 4 5 6  def dfs(visited, graph, node): if node not in visited: print (node) visited.add(node) for neighbour in graph[node]: dfs(visited, graph, neighbour)    Examples Leetcode 78 Subsets 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  class Solution: def subsets(self, nums: List[int]) -\u0026gt; List[List[int]]: ans = [] def dfs(nums, res, index, subset): res.append(subset[:]) if index == len(nums): return for id in range(index, len(nums)): subset.append(nums[id]) dfs(nums, res, id+1, subset) subset.pop() dfs(nums, ans, 0, []) return ans   Leetcode 200 Number of Islands 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  class Solution: def numIslands(self, grid: List[List[str]]) -\u0026gt; int: def dfs(grid, i, j): if i \u0026lt; 0 or j \u0026lt; 0 or i \u0026gt;= len(grid) or j \u0026gt;= len(grid[0]) or grid[i][j] != \u0026#39;1\u0026#39;: return grid[i][j] = \u0026#39;2\u0026#39; dfs(grid, i+1, j) dfs(grid, i-1, j) dfs(grid, i, j+1) dfs(grid, i, j-1) if not grid or len(grid) == 0: return 0 count = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == \u0026#39;1\u0026#39;: dfs(grid, i, j) count += 1 return count   Leetcode 102 Binary Tree Level Order Traversal 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  class Solution: def levelOrder(self, root: Optional[TreeNode]) -\u0026gt; List[List[int]]: def dfs(node, ans, level): if not node: return if level \u0026gt; len(ans) - 1: ans.append([]) ans[level].append(node.val) if node.left: dfs(node.left, ans, level + 1) if node.right: dfs(node.right, ans, level + 1) if not root: return root ans = [] dfs(root, ans, 0) return ans    Reference  手把手带你刷Leetcode力扣 - 深度优先搜索 DFS 手把手带你刷Leetcode力扣 - Leetcode 938 手把手带你刷Leetcode力扣 - Leetcode 200 Depth First Search or DFS for a Graph Depth First Search (DFS) What is Depth First Search?   ","date":"2022-04-05T22:36:36+08:00","permalink":"https://tonyfpy.github.io/p/algorithm-topic-6-depth-first-search/","title":"[Algorithm] Topic 6: Depth-First Search"},{"content":" Authored by Tony Feng\nCreated on April 4th, 2022\nLast Modified on April 4th, 2022\n Understanding Backtracking Intro  A backtracking algorithm is a problem-solving algorithm that uses a brute-force approach for finding the desired output. The term backtracking suggests that if the current solution is not suitable, then go back and try other solutions. Backtracking uses recursion to discover all of the possibilities until we get the best end result for the problem. State Space Tree  A space state tree is a tree representing all the possible states (solution or nonsolution) of the problem from the root as an initial state to the leaf as a terminal state. In combinatorial search problems, search space is in the shape of a tree.    Types of Problems  Decision Problem: Search for a feasible solution Optimization Problem: Search for the best solution Enumeration Problem: Find all feasible soutions   Template 1 2 3 4 5 6 7 8 9 10 11  # Pseudocode function backtracking(node, state): if state is a solution: report(state) # e.g. add state to final result list return for child in children: if child is a part of a potential solution: state.add(child) # make move backtracking(child, state) state.remove(child) # backtrack    Examples Leetcode 46 Permutations 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  class Solution: def permute(self, nums: List[int]) -\u0026gt; List[List[int]]: ans = [] def backtrack(path, cnt): if cnt == 0: ans.append(path[:]) # Copy the content instead of the reference return for item in nums: if not item in path: path.append(item) backtrack(path, cnt-1) path.pop() backtrack([],len(nums)) return ans   Leetcode 77 Combinations 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  class Solution: def combine(self, n: int, k: int) -\u0026gt; List[List[int]]: ans = [] nums = list(range(1, n+1)) def backtrack(path, m): if len(path)==k: ans.append(path[:]) return for i in range(m, len(nums)): path.append(nums[i]) backtrack(path, i+1) path.pop() backtrack([],0) return ans   Leetcode 78 Subsets 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  class Solution: def subsets(self, nums: List[int]) -\u0026gt; List[List[int]]: ans = [[]] def backtrack(path, lmt, index): if len(path) == lmt: ans.append(path[:]) return for id in range(index, len(nums)): path.append(nums[id]) backtrack(path, lmt, id+1) path.pop() for i in range(1, len(nums)+1): backtrack([], i, 0) return ans   Leetcode 22 Generate Parentheses 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  class Solution: def generateParenthesis(self, n: int) -\u0026gt; List[str]: left, right = 0, 0 ans = [] def backtrack(path, l, r): if l == n and r == n: path = (\u0026#34;\u0026#34;).join(path) ans.append(path[:]) return # The number of right bracket cannot exceed that of left bracket. if l \u0026lt; r: return if l \u0026lt;= n: path.append(\u0026#34;(\u0026#34;) backtrack(path, l+1, r) path.pop() if l \u0026gt; r: path.append(\u0026#34;)\u0026#34;) backtrack(path, l, r+1) path.pop() backtrack([], left, right) return ans    Reference  手把手带你刷Leetcode力扣 - 回溯法 Backtracking 手把手带你刷Leetcode力扣 - Leetcode 22 手把手带你刷Leetcode力扣 - Leetcode 78 Backtracking in Python Backtracking Template   ","date":"2022-04-04T22:36:22+08:00","permalink":"https://tonyfpy.github.io/p/algorithm-topic-5-backtracking/","title":"[Algorithm] Topic 5: Backtracking"},{"content":" Authored by Tony Feng\nCreated on April 3rd, 2022\nLast Modified on April 3rd, 2022\n Understanding Divide \u0026amp; Conquer Intro  In computer science, divide and conquer is an algorithm design paradigm. A divide-and-conquer algorithm recursively breaks down a problem into two or more sub-problems of the same or related type, until these become simple enough to be solved directly.  Components  Divide/Break  This involves dividing the problem into smaller sub-problems.   Conquer/Solve  Solve sub-problems by calling recursively until solved.   Combine/Merge  Combine the sub-problems to get the final solution of the whole problem.    Applications  Merge Sort Quick Sort Binary Search Strassen\u0026rsquo;s Matrix Multiplication Closest pair (points)   Examples Tower of Hanoi 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  def TowerOfHanoi(n , source, destination, auxiliary): if n==1: print (\u0026#34;Move disk 1 from source\u0026#34;,source,\u0026#34;to destination\u0026#34;,destination) return TowerOfHanoi(n-1, source, auxiliary, destination) print (\u0026#34;Move disk\u0026#34;,n,\u0026#34;from source\u0026#34;,source,\u0026#34;to destination\u0026#34;,destination) TowerOfHanoi(n-1, auxiliary, destination, source) # Driver code n = 4 TowerOfHanoi(n,\u0026#39;A\u0026#39;,\u0026#39;B\u0026#39;,\u0026#39;C\u0026#39;) # A, C, B are the name of rods \u0026#39;\u0026#39;\u0026#39; Move disk 1 from source A to destination C Move disk 2 from source A to destination B Move disk 1 from source C to destination B Move disk 3 from source A to destination C Move disk 1 from source B to destination A Move disk 2 from source B to destination C Move disk 1 from source A to destination C Move disk 4 from source A to destination B Move disk 1 from source C to destination B Move disk 2 from source C to destination A Move disk 1 from source B to destination A Move disk 3 from source C to destination B Move disk 1 from source A to destination C Move disk 2 from source A to destination B Move disk 1 from source C to destination B \u0026#39;\u0026#39;\u0026#39;   Merge Sort 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49  def mergeSort(arr): if len(arr) \u0026gt; 1: # Finding the mid of the array mid = len(arr)//2 # Dividing the array elements into 2 halves L = arr[:mid] R = arr[mid:] # Sort mergeSort(L) mergeSort(R) i = j = k = 0 # Copy data to temp arrays L[] and R[] while i \u0026lt; len(L) and j \u0026lt; len(R): if L[i] \u0026lt; R[j]: arr[k] = L[i] i += 1 else: arr[k] = R[j] j += 1 k += 1 # Checking if any element was left while i \u0026lt; len(L): arr[k] = L[i] i += 1 k += 1 while j \u0026lt; len(R): arr[k] = R[j] j += 1 k += 1 # Code to print the list def printList(arr): for i in range(len(arr)): print(arr[i], end=\u0026#34; \u0026#34;) print() # Driver Code if __name__ == \u0026#39;__main__\u0026#39;: arr = [12, 11, 13, 5, 6, 7] print(\u0026#34;Given array is\u0026#34;, end=\u0026#34;\\n\u0026#34;) printList(arr) mergeSort(arr) print(\u0026#34;Sorted array is: \u0026#34;, end=\u0026#34;\\n\u0026#34;) printList(arr)    Reference  手把手带你刷Leetcode力扣 - 分治法 Divide \u0026amp; Conquer Programiz - Divide \u0026amp; Conquer GreekforGreek - Merge Sort GreekforGreek - Python Program for Tower of Hanoi   ","date":"2022-04-03T22:30:30+08:00","permalink":"https://tonyfpy.github.io/p/algorithm-topic-4-divide-conquer/","title":"[Algorithm] Topic 4: Divide \u0026 Conquer"},{"content":" Authored by Tony Feng\nCreated on April 2nd, 2022\nLast Modified on April 2nd, 2022\n Understanding Recursion Intro  Recursion is the process of defining a problem (or the solution to a problem) in terms of (a simpler version of) itself. Memoization could be used to save computational time.  Components of Recursion  Base Case  The point where you stop applying the recursive case   Recursive Steps  Divide the problem into one or more simpler or smaller parts of the problem; Call the function (recursively) on each part; Combine the solutions of the parts into a solution for the problem.    Characteristics  Advantages of Recursion  Recursive functions make the code look clean and elegant. A complex task can be broken down into simpler sub-problems using recursion. Sequence generation is easier with recursion than using some nested iteration.   Disadvantages of Recursion  Sometimes the logic behind recursion is hard to follow through. Recursive calls are expensive (inefficient) as they take up a lot of memory and time. Recursive functions are hard to debug.     Examples The Factorial of an Integer 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  term = [0 for i in range(10)] # Memoization # Fibonacci Series using memoized Recursion def fib(n): # base case if n \u0026lt;= 1: return n # if fib(n) has already been computed we do not do further  # recursive calls and hence reduce the number of repeated work; # else store the computed value of fib(n) in an array term at # index n if term[n] != 0: return term[n] else: term[n] = fib(n - 1) + fib(n - 2) return term[n]   Leetcode 509 Fibonacci Number 1 2 3 4 5 6 7 8  # Time: O(N) # Space: O(N) i.e. Recursive Stack class Solution: def fib(self, n: int) -\u0026gt; int: if n \u0026lt;= 1: return n return self.fib(n - 1) + self.fib(n - 2)   Leetcode 206 Reverse Linked List 1 2 3 4 5 6 7 8 9 10  class Solution: def reverseList(self, head: Optional[ListNode]) -\u0026gt; Optional[ListNode]: if not head or not head.next: return head node = self.reverseList(head.next) head.next.next = head head.next = None return node    Reference  手把手带你刷Leetcode力扣 - 递归 Recursion 手把手带你刷Leetcode力扣 - 力扣509 手把手带你刷Leetcode力扣 - 力扣206 Programiz - Python Recursion WTF is Memoization   ","date":"2022-04-02T23:49:58+08:00","permalink":"https://tonyfpy.github.io/p/algorithm-topic-3-recursion/","title":"[Algorithm] Topic 3: Recursion"},{"content":" Authored by Tony Feng\nCreated on April 1st, 2022\nLast Modified on April 1st, 2022\n Understanding Binary Search Intro  Binary search is often used to efficiently locate an item in a sorted sequence of items. It divides the search space in 2 after every comparison. Compared to linear search which requires O(N) running time, binary search only takes O(log N) where n is the size of the sequence.  Main Steps of the Algorithm  Pre-processing  Sort if collection is unsorted.   Binary Search  Using a loop or recursion to divide search space in half after each comparison.   Post-processing  Determine viable candidates in the remaining space    When Do We Use Binary Search?  The array is partially or fully sorted. The upper bound of time complexity is O(N) or O(log N).   Templates  There are many variants of binary search, such as [l, r), [l, r], (l, r], etc. We should be careful of loop condition, mid/left/right update and return value.\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  # The most common case class Solution: def binarySearch(self, nums, target): \u0026#34;\u0026#34;\u0026#34; :type nums: List[int] :type target: int :rtype: int \u0026#34;\u0026#34;\u0026#34; if len(nums) == 0: return -1 left, right = 0, len(nums) - 1 while left \u0026lt;= right: mid = left + (right - left) // 2 # Avoid overflow if nums[mid] \u0026lt; target: left = mid + 1 elif nums[mid] \u0026gt; target: right = mid - 1 else: return mid # End Condition: left \u0026gt; right return -1    Examples Leetcode 704 Binary Search 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  class Solution: def search(self, nums: List[int], target: int) -\u0026gt; int: if not nums or len(nums) == 0: return -1 l, r = 0, len(nums)-1 while l \u0026lt;= r: m = l + (r - l) // 2 if nums[m] \u0026gt; target: r = m - 1 elif nums[m] \u0026lt; target: l = m + 1 else: return m return -1   Leetcode 35 Search Insert Position 1 2 3 4 5 6 7 8 9 10 11 12  class Solution: def searchInsert(self, nums: List[int], target: int) -\u0026gt; int: l, r = 0, len(nums)-1 while l \u0026lt; r: # break if l == r mid = l + (r - l) // 2 if nums[mid] \u0026lt; target: l = mid + 1 elif nums[mid] \u0026gt; target: r = mid - 1 else: return mid return l if target \u0026lt;= nums[l] else l + 1   Leetcode 162 Find Peak Element 1 2 3 4 5 6 7 8 9 10  class Solution: def findPeakElement(self, nums: List[int]) -\u0026gt; int: l, r = 0, len(nums)-1 while l \u0026lt; r: m = l + (r - l) // 2 if nums[m] \u0026gt; nums[m+1]: r = m else: l = m + 1 return l   Leetcode 74 Search a 2D Matrix 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  class Solution: def searchMatrix(self, matrix: List[List[int]], target: int) -\u0026gt; bool: nums = [] for nums in matrix: if nums[-1] \u0026gt;= target: # Find which row the target is in l, r = 0, len(nums)-1 while l \u0026lt;= r: mid = l + (r - l) // 2 if nums[mid] \u0026lt; target: l = mid + 1 elif nums[mid] \u0026gt; target: r = mid - 1 else: return True return False    Reference  手把手带你刷Leetcode力扣 - 二分查找 Binary Search 手把手带你刷Leetcode力扣 - 力扣705 手把手带你刷Leetcode力扣 - 力扣35 手把手带你刷Leetcode力扣 - 力扣162 手把手带你刷Leetcode力扣 - 力扣74 Collection of Binary Search Templates   ","date":"2022-04-01T22:36:50+08:00","permalink":"https://tonyfpy.github.io/p/algorithm-topic-2-binary-search/","title":"[Algorithm] Topic 2: Binary Search"},{"content":" Authored by Tony Feng\nCreated on March 30th, 2022\nLast Modified on March 30th, 2022\n Understanding Two-pointer Algorithm Intro  The approach optimizes the runtime by utilizing some order (not necessarily sorting) of the data. It is generally applied on lists (arrays) and linked lists. Here, pointers represent either index or an iteration attribute like node’s Next.  Main Steps of the Algorithm  Pointer Initialization Pointer Movement Stop Condition  Categories  Old \u0026amp; New State Pointers Slow \u0026amp; Fast Pointers Left \u0026amp; Right Pointers Pointers from Two Sequences Sliding Window   Old \u0026amp; New State Pointers Template 1 2 3 4 5 6 7  class Solution: def old_new_state(self, arr): # initialize states old, new = default_val1, default_val2 for item in arr: # process current element with old state old, new = new, self.some_func(item, old)   Examples Leetcode 509 Fibonacci Number 1 2 3 4 5 6 7  # Each number is the sum of the two preceding ones, starting from 0 and 1. class Solution: def fibonacci(self, n: int) -\u0026gt; int: a, b = 0, 1 for i in range(n + 1): a, b = b, a + b return a   Leetcode 198 House Robber 1 2 3 4 5 6 7 8  # Determine the maximum amount of money you can steal tonight  # without robbing adjacent houses. class Solution: def rob(self, nums: \u0026#39;List[int]\u0026#39;) -\u0026gt; int: last, now = 0, 0 for i in nums: last, now = now, max(last + i, now) return now    Slow \u0026amp; Fast Pointers Template 1 2 3 4 5 6 7 8 9 10 11 12 13  class Solution: def slow_fast_runner(self, arr): # initialize slow runner slow = arr[0] # fast-runner grows each iteration generally for fast in range(arr): #slow-runner grows with some restrictions if self.slow_condition(slow): slow = slow.next # slow += 1 # process logic before or after pointers movement self.some_func(slow, fast)   Examples Leetcode 141 Linked List Cycle 1 2 3 4 5 6 7 8 9 10 11 12  class Solution: def hasCycle(self, head: Optional[ListNode]) -\u0026gt; bool: if not head or not head.next: return False slow, fast = head, head while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: return True return False   Leetcode 881 Boats to Save People 1 2 3 4 5 6 7 8 9 10 11  class Solution: def numRescueBoats(self, people: List[int], limit: int) -\u0026gt; int: people = sorted(people) i, j, res = 0, len(people)-1, 0 while i \u0026lt;= j: if people[i] + people[j] \u0026lt;= limit: i = i + 1 j = j - 1 res += 1 return res   Leetcode 26 Remove Duplicates from Sorted Array 1 2 3 4 5 6 7 8 9 10 11 12 13  # Given a sorted array nums, remove the duplicates in place such that  # each element appear only once and return the new length. class Solution: def removeDuplicates(self, nums: \u0026#39;List[int]\u0026#39;) -\u0026gt; int: if not nums: return 0 slow = 0 for fast in range(1, len(nums)): # if current element is not duplicate,  # slow runner grows one step and copys the current value if nums[slow] != nums[fast]: slow += 1 nums[slow] = nums[fast] return slow + 1    Left \u0026amp; Right Pointers Template 1 2 3 4 5 6 7 8 9 10 11 12  class Solution: def left_right_boundary(self, arr): left, right = 0, len(arr) - 1 while left \u0026lt; right: # left index moves when satisfy the condition if self.left_condition(left): left += 1 # right index move when satisfy the condition if self.right_condition(right): right -= 1 # process logic before or after pointers movement self.some_func(left, right)   Examples Leetcode 167 Two Sum II - Input Array Is Sorted 1 2 3 4 5 6 7 8 9 10 11 12 13  # Given an array of integers that is already sorted in ascending  # order, find two numbers such that they add up to a specific target number. class Solution: def twoSum(self, numbers: \u0026#39;List[int]\u0026#39;, target: \u0026#39;int\u0026#39;) -\u0026gt; \u0026#39;List[int]\u0026#39;: left, right = 0, len(numbers) - 1 while left \u0026lt; right: if numbers[left] + numbers[right] == target: return [left + 1, right + 1] if numbers[left] + numbers[right] \u0026lt; target: left += 1 else: right -= 1 return [0, 0]    Pointers from Two Sequences Template 1 2 3 4 5 6 7 8 9 10 11 12 13 14  class Solution: def pointers_from_two_seq(self, arr1, arr2): # init pointers p1, p2 = 0, 0 # or seq1[0], seq2[0] while p1 \u0026lt; len(arr1) and p2 \u0026lt; len(arr2): # or other condition # p1 index moves when satisfy the condition if self.p1_condition(p1): p1 += 1 # or p1 = next(seq1) # p2 index move when satisfy the condition if self.p2_condition(p2): p2 += 1 # or p2 = next(seq2) # process logic before or after pointers movement self.some_func(p1, p2)   Examples Leetcode 244 Shortest Word Distance II 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  # Design a class which receives a list of words in the constructor  # and implements a method that takes two words, word1 and word2, and  # returns the shortest distance between these two words in the list. class WordDistance: def __init__(self, words: \u0026#39;List[str]\u0026#39;): self.locations = defaultdict(list) # Prepare a mapping from a word to all it\u0026#39;s locations (indices). for i, w in enumerate(words): self.locations[w].append(i) def shortest(self, word1: str, word2: str) -\u0026gt; int: loc1, loc2 = self.locations[word1], self.locations[word2] l1, l2 = 0, 0 min_diff = float(\u0026#34;inf\u0026#34;) # Until the shorter of the two lists is processed while l1 \u0026lt; len(loc1) and l2 \u0026lt; len(loc2): min_diff = min(min_diff, abs(loc1[l1] - loc2[l2])) if loc1[l1] \u0026lt; loc2[l2]: l1 += 1 else: l2 += 1 return min_diff    Sliding Window  There are two types of window\n  The fixed size window can be used for problem where you want to determine whether given string contain a specific substring.\n  The dynamic one can be used to find the longest or shortest substring of the given string.\n   Template 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  class Solution: def sliding_window(self, arr): start, end = 0, 0 while end \u0026lt; len(arr): # end pointer grows in the outer loop end += 1 # start pointer grows with some restrict while self.start_condition(start): # process logic before pointers movement self.some_func(start, end) # start grows in the inner loop start += 1 # or process logic after pointers movement self.some_func(start, end)   Examples Leetcode 209 Minimum Size Subarray Sum 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  # Given an array of positive integers nums and a positive integer  # target, return the minimal length of a contiguous subarray of  # which the sum is greater than or equal to target. class Solution: def minSubArrayLen(self, target: int, nums: List[int]) -\u0026gt; int: if not nums or len(nums) == 0: return 0 l, r = 0, 0 res = len(nums) + 1 add = 0 while r \u0026lt; len(nums): add += nums[r] r += 1 # Upsizing the window while add \u0026gt;= target: # Downsizing the window iteratively res = min(res, r - l) add -= nums[l] l += 1 return res if res != len(nums) + 1 else 0   Leetcode 1456 Maximum Number of Vowels in a Substring of Given Length 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  # Given a string s and an integer k, return the maximum number of vowel  # letters in any substring of s with length k. class Solution: def maxVowels(self, s: str, k: int) -\u0026gt; int: if not s or len(s) == 0 or len(s) \u0026lt; k: return 0 vl = set([\u0026#39;a\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;i\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;u\u0026#39;]) # Quick for search i, j = 0, 0 res, tmp = 0, 0 while j \u0026lt; len(s): if j - i \u0026lt; k: # Get the number of vowel letters in the first sliding window if s[j] in vl: tmp += 1 res = tmp j += 1 else: # Pop the first item if s[i] in vl: tmp -= 1 i += 1 # Add the next item if s[j] in vl: tmp += 1 res = max(tmp, res) j += 1 return res    Reference  手把手带你刷Leetcode力扣 - 双指针 Two Pointers 手把手带你刷Leetcode力扣 - 力扣141 手把手带你刷Leetcode力扣 - 力扣881 手把手带你刷Leetcode力扣 - 滑动窗口 Sliding Window 手把手带你刷Leetcode力扣 - 力扣209 手把手带你刷Leetcode力扣 - 力扣1456 Two Pointers Approach — Python Code Algorithm Templates: Two Pointers - Part 1 Algorithm Templates: Two Pointers - Part 2 Algorithm Templates: Two Pointers - Part 3 Effective LeetCode: Understanding the Sliding Window Pattern   ","date":"2022-03-30T22:59:15+08:00","permalink":"https://tonyfpy.github.io/p/algorithm-topic-1-two-pointers/","title":"[Algorithm] Topic 1: Two Pointers"},{"content":" Authored by Tony Feng\nCreated on March 29th, 2022\nLast Modified on March 29th, 2022\n Understanding Graphs Main Concepts  A Graph is a non-linear data structure consisting of nodes and edges. The nodes are sometimes also referred to as vertices. The edges are lines or arcs that connect any two nodes in the graph. Representations of Graphs G(V,E)  A collection of vertices V A collection of edges E, represented as ordered pairs of vertices (p,q)    Graph Classifications  Directed Graphs Undirected Graphs Weighted Graphs  Graph Terminology  Adjacency  A vertex is said to be adjacent to another vertex if there is an edge connecting them.   Path  A sequence of edges that allows you to go from vertex A to vertex B is called a path.    Operations  Check if the element is present in the graph Graph Traversal Add elements(vertex, edges) to graph Finding the path from one vertex to another   Implementations  This part will be dicussed when solving the problem.\n  Reference  GreeksforGreeks - Graph Data Structure And Algorithms Graph Data Stucture 手把手带你刷Leetcode力扣 - 图 Graph   ","date":"2022-03-29T22:38:32+08:00","permalink":"https://tonyfpy.github.io/p/data-structure-topic-10-graph/","title":"[Data Structure] Topic 10: Graph"},{"content":" Authored by Tony Feng\nCreated on March 28th, 2022\nLast Modified on March 28th, 2022\n Understanding Heaps Main Concepts  Heaps are complete binary trees. Complete binary trees satisfy the following conditions:  All levels are filled, except the last. All the nodes are as far left as possible.   The root of every subtree should be the greatest or smallest element in the subtree, recursively.  Minheap: The root of every subtree is the smallest element. Maxheap: The root of every subtree is the largest element.   Heapify: From an array to a heap, the solution is unique and the time complexity is O(N). (Formal Proof)  Applications of Heaps  Priority Queues  The root of a heap always contains the maximum or the minimum value, based on the heap type. The element with the highest/lowest priority can be retrieved in O(1) time.   Statistics  If we want the kth smallest or largest element, we can pop the heap k times to retrieve them.   Graph Algorithms  e.g. Dijkstra’s algorithm, Prim’s algorithm.    Operations  Search  For the top of heap, it\u0026rsquo;s O(1) The rest are O(N)   Insert - O(log(N)) Delete - O(log(N))  Explanations     Set Implementation in Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  import heapq # Create a minheap minheap = [] heapq.heapify(minheap) # In Python, there is no maxheap. If maxheap is required,  # try to multiply each element with -1 and then heapify it. # In the operations, the value should be converted back. # Add elements heapq.heappush(minheap, 10) heapq.heappush(minheap, 8) heapq.heappush(minheap, 9) heapq.heappush(minheap, 2) heapq.heappush(minheap, 1) heapq.heappush(minheap, 11) # [1,2,9,10,8,11] # Peek print(minheap[0]) # Delete heapq.heappop(minheap) # Size len(minheap) # Iteration while len(minheap) != 0: print(heapq.heappop(minheap))    Set Implementation in Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  // Create PriorityQueue\u0026lt;Integer\u0026gt; minheap = new PriorityQueue\u0026lt;\u0026gt;(); PriorityQueue\u0026lt;Integer\u0026gt; maxheap = new PriorityQueue\u0026lt;\u0026gt;(Collections.reverseOrder()); // Add minheap.add(2); maxheap.add(3); // Peek int mi = minheap.peek(); int ma = maxheap.peek(); // Remove the top element int mi = minheap.poll(); int ma = maxheap.poll(); // Get the size of the heap int lenMin = minheap.size(); int lenMax = maxheap.size(); // Iteration while (!minheap.isEmpty()) { System.out.println(minheap.poll()); }    Reference  Using the Heap Data Structure in Python 堆删除操作逻辑 GreeksforGreeks - Time Complexity of building a heap 手把手带你刷Leetcode力扣 - 集合 Set 手把手带你刷Leetcode力扣 - Python3集合常用操作 手把手带你刷Leetcode力扣 - Java集合常用操作   ","date":"2022-03-28T22:38:21+08:00","permalink":"https://tonyfpy.github.io/p/data-structure-topic-9-heap/","title":"[Data Structure] Topic 9: Heap"},{"content":" Authored by Tony Feng\nCreated on March 27th, 2022\nLast Modified on March 28th, 2022\n Understanding Trees Main Concepts  A tree is non-linear and a hierarchical data structure. It consists of a collection of nodes such that each node of the tree stores a value and a list of references to their children. Different tree data structures allow quicker and easier access to the data as it is a non-linear data structure.  Tree Terminologies    Term Explanation     Node 1. A node is an entity that contains a key or value and pointers to its child nodes.  2. Root is the topmost node of a tree.  3. The last nodes of each path are called leaf nodes or external nodes that do not contain a link/pointer to child nodes.  4. The node having at least a child node is called an internal node.  5. The node which is a predecessor of a node is called the parent node of that node.  6. The node which is the immediate successor of a node is called the child node of that node.  7. Any predecessor nodes on the path of the root to that node are called Ancestors of that node.  8. Any successor node on the path from the leaf node to that node are the descendants of the node.  9. Children of the same parent node are called siblings.   Edge It is the link between any two nodes.   Depth of a Node The depth of a node is the number of edges from the node to the tree\u0026rsquo;s root node (from bottom to top).   Height of a Node 1. The number of edges on the longest path from that node to a leaf (from top to bottom).  2. The height of a Tree is the height of the root node or the depth of the deepest node.   Level of a node 1. The level of a node is defined by 1 + the number of connections between the node and the root.  2. The level of the root is 1.   Degree of a Node It is the total count of subtrees attached to that node.    Binary Trees  Classifications  Full/ proper/ strict Binary tree  It can be defined as the tree in which each node must contain 2 children except the leaf nodes.   Complete Binary tree  It is a tree in which all the nodes are completely filled except the last level. In the last level, all the nodes must be as left as possible.   Perfect Binary tree  A tree is a perfect binary tree if all the internal nodes have 2 children. All the leaf nodes are at the same level.   Degenerate Binary tree  It is a tree in which all the internal nodes have only one children.   Balanced Binary tree  The tree, also referred to as a height-balanced binary tree, is defined as a binary tree in which the height of the left and right subtree of any node differ by not more than 1.     Traverse  Preorder traverse  Visit root node Visit all the nodes in the left subtree Visit all the nodes in the right subtree   Inorder traverse  First, visit all the nodes in the left subtree Then the root node Visit all the nodes in the right subtree   Postorder traverse  Visit all the nodes in the left subtree Visit all the nodes in the right subtree Visit the root node       Set Implementation in Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179  # Binary search tree class binarySearchTree: def __init__(self,val=None): self.val = val self.left = None self.right = None def insert(self,val): # check if there is no root if (self.val == None): self.val = val # check where to insert else: # check for duplicate then stop and return if val == self.val: return \u0026#39;no duplicates allowed in binary search tree\u0026#39; # check if value to be inserted \u0026lt; currentNode\u0026#39;s value if (val \u0026lt; self.val): # check if there is a left node to currentNode if true then recurse if(self.left): self.left.insert(val) # insert where left of currentNode when currentNode.left=None else: self.left = binarySearchTree(val) # same steps as above here the condition we check is value to be inserted \u0026gt; currentNode\u0026#39;s value else: if(self.right): self.right.insert(val) else: self.right = binarySearchTree(val) def breadthFirstSearch(self): currentNode = self bfs_list = [] queue = [] queue.insert(0,currentNode) while(len(queue) \u0026gt; 0): currentNode = queue.pop() bfs_list.append(currentNode.val) if(currentNode.left): queue.insert(0,currentNode.left) if(currentNode.right): queue.insert(0,currentNode.right) return bfs_list # In order means first left child, then parent, at last right child def depthFirstSearch_INorder(self): return self.traverseInOrder([]) # Pre order means first parent, then left child, at last right child def depthFirstSearch_PREorder(self): return self.traversePreOrder([]) # Post order means first left child, then right child , at last parent def depthFirstSearch_POSTorder(self): return self.traversePostOrder([]) def traverseInOrder(self, lst): if (self.left): self.left.traverseInOrder(lst) lst.append(self.val) if (self.right): self.right.traverseInOrder(lst) return lst def traversePreOrder(self, lst): lst.append(self.val) if (self.left): self.left.traversePreOrder(lst) if (self.right): self.right.traversePreOrder(lst) return lst def traversePostOrder(self, lst): if (self.left): self.left.traversePostOrder(lst) if (self.right): self.right.traversePostOrder(lst) lst.append(self.val) return lst def findNodeAndItsParent(self,val, parent = None): # returning the node and its parent so we can delete the node and reconstruct the tree from its parent if val == self.val: return self, parent if (val \u0026lt; self.val): if (self.left): return self.left.findNodeAndItsParent(val, self) else: return \u0026#39;Not found\u0026#39; else: if (self.right): return self.right.findNodeAndItsParent(val, self) else: return \u0026#39;Not found\u0026#39; # deleteing a node means we have to rearrange some part of the tree def delete(self,val): # check if the value we want to delete is in the tree if(self.findNodeAndItsParent(val)==\u0026#39;Not found\u0026#39;): return \u0026#39;Node is not in tree\u0026#39; # we get the node we want to delete and its parent-node from findNodeAndItsParent method deleteing_node, parent_node = self.findNodeAndItsParent(val) # check how many children nodes does the node we are going to delete have by traversePreOrder from the deleteing_node nodes_effected = deleteing_node.traversePreOrder([]) # if len(nodes_effected)==1 means, the node to be deleted doesn\u0026#39;t have any children # so we can just check from its parent node the position(left or right) of node we want to delete # and point the position to \u0026#39;None\u0026#39; i.e node is deleted if (len(nodes_effected)==1): if (parent_node.left.val == deleteing_node.val) : parent_node.left = None else: parent_node.right = None return \u0026#39;Succesfully deleted\u0026#39; # if len(nodes_effected) \u0026gt; 1 which means the node we are going to delete has \u0026#39;children\u0026#39;, # so the tree must be rearranged from the deleteing_node else: # if the node we want to delete doesn\u0026#39;t have any parent means the node to be deleted is \u0026#39;root\u0026#39; node if (parent_node == None): nodes_effected.remove(deleteing_node.val) # make the \u0026#39;root\u0026#39; nodee i.e self value,left,right to None, # this means we need to implement a new tree again without the delted node self.left = None self.right = None self.val = None # construction of new tree for node in nodes_effected: self.insert(node) return \u0026#39;Succesfully deleted\u0026#39; # if the node we want to delete has a parent # traverse from parent_node nodes_effected = parent_node.traversePreOrder([]) # deleting the node if (parent_node.left == deleteing_node) : parent_node.left = None else: parent_node.right = None # removeing the parent_node, deleteing_node and inserting the nodes_effected in the tree nodes_effected.remove(deleteing_node.val) nodes_effected.remove(parent_node.val) for node in nodes_effected: self.insert(node) return \u0026#39;Successfully deleted\u0026#39; bst = binarySearchTree() bst.insert(7) bst.insert(4) bst.insert(9) bst.insert(0) bst.insert(5) bst.insert(8) bst.insert(13) # 7 # / \\ # / \\ # 4 9 # / \\ / \\ # 0 5 8 13 print(\u0026#39;IN order: \u0026#39;,bst.depthFirstSearch_INorder()) # useful in sorting the tree in ascending order print(\u0026#39;PRE order:\u0026#39; ,bst.depthFirstSearch_PREorder()) # pre order is useful in reconstructing a tree print(\u0026#39;POST order:\u0026#39;, bst.depthFirstSearch_POSTorder()) # useful in finding the leaf nodes print(bst.delete(5)) print(bst.delete(9)) print(bst.delete(7)) # after deleting print(\u0026#39;IN order: \u0026#39;,bst.depthFirstSearch_INorder()) \u0026#39;\u0026#39;\u0026#39; Output IN order: [0, 4, 5, 7, 8, 9, 13] PRE order: [7, 4, 0, 5, 9, 8, 13] POST order: [0, 5, 4, 8, 13, 9, 7] Successfully deleted Successfully deleted Successfully deleted IN order: [0, 4, 8, 13] \u0026#39;\u0026#39;\u0026#39;    Reference  GreeksforGreeks - Intro to Tree Data Structure Height, Depth and Level of a Tree Programiz - Balanced Binary Tree Binary tree and BinarySearch tree implementation in Python 手把手带你刷Leetcode力扣 - 树 Tree 手把手带你刷Leetcode力扣 - 树 Tree 补充   ","date":"2022-03-27T22:38:11+08:00","permalink":"https://tonyfpy.github.io/p/data-structure-topic-8-tree/","title":"[Data Structure] Topic 8: Tree"},{"content":" Authored by Tony Feng\nCreated on March 27th, 2022\nLast Modified on March 27th, 2022\n Understanding Sets Main Concepts  A Set is an unordered collection data type that is iterable, mutable and has no duplicate elements. The major advantage of using a set, as opposed to a list, is that it has a highly optimized method for checking whether a specific element is contained in the set or whether some elements are repeated. This is based on a data structure known as hash table. Since sets are unordered, we cannot access items using indexes.  Main Characteristics  Unordered Unchangeable Unindexed  Operations  Search  Collision - O(K) No Collision - O(1)   Insert - O(1)  Collision - O(K) No Collision - O(1)   Delete - O(1)  Collision - O(K) No Collision - O(1)     Set Implementation in Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  # Create a set s = set() # Add an element - O(1) s.add(2) s.add(3) s.add(1) # Remove an element - O(1) s.remove(2) # Check if the value exists - O(1) 1 in s # Get the length of the set len(s)    Set Implementation in Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  // Create HashSet\u0026lt;Integer, String\u0026gt; s = new HashSet\u0026lt;\u0026gt;(); // Add - O(1) s.add(2); s.add(3); s.add(1); // Remove an element - O(1) s.remove(1); // arg is the value  // Check if the value exists - O(1) Boolean check = s.contains(2); // Get the length of the hash table - O(1) int len = s.size()    Reference  GreeksforGreeks - Sets in Python 手把手带你刷Leetcode力扣 - 集合 Set 手把手带你刷Leetcode力扣 - Python3集合常用操作 手把手带你刷Leetcode力扣 - Java集合常用操作   ","date":"2022-03-27T22:38:02+08:00","permalink":"https://tonyfpy.github.io/p/data-structure-topic-7-set/","title":"[Data Structure] Topic 7: Set"},{"content":" Authored by Tony Feng\nCreated on March 26th, 2022\nLast Modified on March 26th, 2022\n Understanding Hash Tables Main Concepts  Hash Table stores data in an associative manner. In programming languages, each key is assigned to a memory address by a hash function. The key-value pair is stored in this memory address. Hashing is a technique to convert a range of key values into a range of indexes of an array. Collision occur when two pieces of data in a hash table share the same hash value. Collisions are pretty difficult to avoid and are bound to happen, so the key to a good hash function is collision resolution. (Linked list could be a good solution.)  Main Characteristics  In a hash table, data is stored using a key-value storage method. Access of data becomes very fast if we know the index of the desired data.  Operations  Search - O(1)  If hash collision happens, O(K), where K is number of collisions.   Insert - O(1) Delete - O(1)   Hash Table Implementation in Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  # Create a hash table by Dictionary D = {} # Add an element - O(1) D[1], D[2], D[3] = \u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;d\u0026#34; # Update an element - O(1) D[3] = \u0026#34;c\u0026#34; # Remove an element - O(1) D.pop(1) # arg is the key # del D[1] # Get the value - O(1) D[2] # Check if the key exists - O(1) b in D # Get the length of the hash table len(D) # Traverse my_dict={\u0026#39;Dave\u0026#39; : \u0026#39;001\u0026#39; , \u0026#39;Ava\u0026#39;: \u0026#39;002\u0026#39; , \u0026#39;Joe\u0026#39;: \u0026#39;003\u0026#39;} for k in my_dict: print(k) #prints the keys for v in my_dict.values(): print(v) #prints values for k,v in my_dict.items(): print(k, \u0026#34;:\u0026#34; , v) #prints keys and values    Hash Table Implementation in Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  // Create HashMap\u0026lt;Integer, String\u0026gt; m = new HashMap\u0026lt;\u0026gt;(); // Add - O(1) m.put(1, \u0026#34;alpha\u0026#34;); m.put(2, \u0026#34;b\u0026#34;); m.put(3, \u0026#34;c\u0026#34;); // Update an element - O(1) m.put(1, \u0026#34;a\u0026#34;); // Remove an element - O(1) m.remove(1); // arg is the key  // Get the value - O(1) String tmp = m.get(2); // arg is the key  // Check if the key exists - O(1) Boolean check = m.containsKey(2); // Get the length of the hash table int s = m.size()    Reference  手把手带你刷Leetcode力扣 - 哈希表 Hash Table 手把手带你刷Leetcode力扣 - Python3哈希表常用操作 手把手带你刷Leetcode力扣 - Java哈希表常用操作   ","date":"2022-03-26T22:37:51+08:00","permalink":"https://tonyfpy.github.io/p/data-structure-topic-6-hash-table/","title":"[Data Structure] Topic 6: Hash Table"},{"content":" Authored by Tony Feng\nCreated on March 24th, 2022\nLast Modified on March 25th, 2022\n Understanding Stacks Main Concepts  Stack is an abstract data structure that is similar to queue. Unlike queues, a stack is open at one end. First In Last Out (FILO) e.g. Back functionanlity of browsers  Operations  Access - O(1)  Access the top of the stack   Search - O(N) Insert - O(1)  A stack can only be inserted from the top.   Delete - O(1)  A stack can only be removed from the top.     Stack Implementation in Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  # Create stack = [] # Add an element - O(1) stack.append(1) stack.append(2) stack.append(3) # [1,2,3] # Get the top of the stack - O(1) top = stack[-1] # Remove the head of the stack - O(1) top = stack.pop() # Get the size of the stack - O(1) length = len(stack) # Traverse the stack - O(N) while len(stack) != 0: tmp = stack.pop() print(tmp)    Stack Implementation in Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  // Create Stack\u0026lt;Integer\u0026gt; s = new Stack\u0026lt;\u0026gt;(); // Add - O(1) s.push(1); s.push(2); s.push(3); // Get the head of the stack - O(1) int elem = s.peek(); // 1  // Remove the head of the stack - O(1) int id = s.pop(); // 1  // Get the size of the stack - O(1) int len = s.size() // Traverse the stack - O(N) while (!s.isEmpty()) { int tmp = s.pop() System.out.println(tmp) }    Reference  手把手带你刷Leetcode力扣 - 栈 Stack 手把手带你刷Leetcode力扣 - Python3栈常用操作 手把手带你刷Leetcode力扣 - Java栈常用操作   ","date":"2022-03-24T22:37:38+08:00","permalink":"https://tonyfpy.github.io/p/data-structure-topic-5-stack/","title":"[Data Structure] Topic 5: Stack"},{"content":" Authored by Tony Feng\nCreated on March 22nd, 2022\nLast Modified on March 23rd, 2022\n Understanding Queues Main Concepts  Queue is an abstract data structure that is similar to stacks. Unlike stacks, a queue is open at both ends. First In First Out (FIFO)  Different Types  Singly-ended Queue (All queues mentioned in this file are this type.) Doubly-ended Queue  Operations  Access - O(N) Search - O(N) Insert - O(1)  A queue can only be inserted from the rear.   Delete - O(1)  A queue can only be removed from the front.     Queue Implementation in Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  # Create queue = deque() # Add an element - O(1) queue.append(1) queue.append(2) queue.append(3) # [1,2,3] # Get the head of the queue - O(1) head = queue[0] # Remove the head of the queue - O(1) head = queue.popleft() # Get the size of the queue - O(1) length = len(queue) # Traverse the queue - O(N) while len(queue) != 0: tmp = queue.popleft() print(tmp)    Queue Implementation in Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  // Create Queue\u0026lt;Integer\u0026gt; q = new LinkedList\u0026lt;\u0026gt;(); // Add - O(1) q.add(1); q.add(2); q.add(3); // Get the head of the queue - O(1) int elem = q.peek(); // 1  // Remove the head of the queue - O(1) int id = q.poll(); // 1  // Get the size of the queue - O(1) int len = q.size() // Traverse the queue - O(N) while (!q.isEmpty()) { int tmp = q.poll() System.out.println(tmp) }    Reference  手把手带你刷Leetcode力扣 - 队列 Queue 手把手带你刷Leetcode力扣 - Python3队列常用操作 手把手带你刷Leetcode力扣 - Java队列常用操作   ","date":"2022-03-22T22:37:28+08:00","permalink":"https://tonyfpy.github.io/p/data-structure-topic-4-queue/","title":"[Data Structure] Topic 4: Queue"},{"content":" Authored by Tony Feng\nCreated on March 20th, 2022\nLast Modified on March 21st, 2022\n Understanding Linked Lists Main Concepts  Linked lists are an ordered collection of objects. While other lists use a contiguous memory block to store references to their data, linked lists store references as part of their elements. Node = Data + Next  A value A reference to the next node   The first node of a linked list is called Head. The last node must have its Next pointing to None.  Different Types  Singly Linked Lists (All linked lists mentioned in this file are this type.) Doubly Linked Lists Circular Linked Lists  Operations  Access - O(N) Search - O(N) Insert - O(1)  Commonly, a function of insertion contains traverse and add, which is O(N).   Delete - O(1)  Applications  Queues - FIFO Stacks - LIFO Graphs  Linked List V.S. Array     Linked List Arrays     Pros 1. Dynamic Size  2. Ease of insertion/deletion 1. Fast access to elements  2. Linear data of similar types could be stored   Cons 1. More memory needed  2. Random access is not allowed  3. Not cache friendly 1. Fixed size  2. Slow insertion/deletion  3. Waste of memory     Linked List Implementation in Python Using collections.deque in Python 1 2 3 4 5 6 7 8 9 10 11  from collections import deque queue = deque() queue.append(\u0026#34;Mary\u0026#34;) # O(1) queue.append(\u0026#34;John\u0026#34;) queue.append(\u0026#34;Susan\u0026#34;) # deque([\u0026#39;Mary\u0026#39;, \u0026#39;John\u0026#39;, \u0026#39;Susan\u0026#39;]) queue.popleft() # deque([\u0026#39;John\u0026#39;, \u0026#39;Susan\u0026#39;]) history = deque() history.appendleft(1) history.appendleft(2) history.appendleft(3) # deque([3,2,1])   Creating a linked list from scratch in Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89  \u0026#39;\u0026#39;\u0026#39; def __init__(self, nodes=None): self.head = None if nodes is not None: node = Node(data=nodes.pop(0)) self.head = node for elem in nodes: node.next = Node(data=elem) node = node.next \u0026#39;\u0026#39;\u0026#39; class Node: def __init__(self, data): self.data = data self.next = None def __repr__(self): return self.data class LinkedList: def __init__(self): self.head = None def __repr__(self): # representation node = self.head nodes = [] while node is not None: nodes.append(node.data) node = node.next nodes.append(\u0026#34;None\u0026#34;) return \u0026#34; -\u0026gt; \u0026#34;.join(nodes) def add_first(self, node): # insert at the front node.next = self.head self.head = node def add_last(self, node): # append at the end if self.head is None: self.head = node return for current_node in self: pass current_node.next = node def add_after(self, target_node_data, new_node): # insert after an existing node if self.head is None: raise Exception(\u0026#34;List is empty\u0026#34;) for node in self: if node.data == target_node_data: new_node.next = node.next node.next = new_node return raise Exception(\u0026#34;Node with data \u0026#39;%s\u0026#39; not found\u0026#34; % target_node_data) def add_before(self, target_node_data, new_node): # insert before an existing node if self.head is None: raise Exception(\u0026#34;List is empty\u0026#34;) if self.head.data == target_node_data: return self.add_first(new_node) prev_node = self.head for node in self: if node.data == target_node_data: prev_node.next = new_node new_node.next = node return prev_node = node raise Exception(\u0026#34;Node with data \u0026#39;%s\u0026#39; not found\u0026#34; % target_node_data) def remove_node(self, target_node_data): # remove if self.head is None: raise Exception(\u0026#34;List is empty\u0026#34;) if self.head.data == target_node_data: self.head = self.head.next return previous_node = self.head for node in self: if node.data == target_node_data: previous_node.next = node.next return previous_node = node raise Exception(\u0026#34;Node with data \u0026#39;%s\u0026#39; not found\u0026#34; % target_node_data)    Linked List Implementation in Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  // Create LinkedList\u0026lt;Integer\u0026gt; ll = new LinkedList\u0026lt;\u0026gt;(); // Add - O(1) ll.add(1); ll.add(2); ll.add(3); // Access - O(N) int elem = ll.get(0); // 1  // Search - O(N) int id = ll.indexOf(3); // 2  // Update - O(N) ll.set(2,100); // [1,2,100]  // Remove - O(N) ll.remove(1); // [1,100]  // size int length = ll.size();    Reference  Linked Lists in Python: An Introduction 手把手带你刷Leetcode力扣 - 链表Linked List 手把手带你刷Leetcode力扣 - Python3链表常用操作 手把手带你刷Leetcode力扣 - Java链表常用操作   ","date":"2022-03-20T22:36:59+08:00","permalink":"https://tonyfpy.github.io/p/data-structure-topic-3-linked-list/","title":"[Data Structure] Topic 3: Linked List"},{"content":" Authored by Tony Feng\nCreated on March 18th, 2022\nLast Modified on March 19th, 2022\n Understanding Arrays Def  An array is a collection of data elements with the same type stored at contiguous memory locations. Index \u0026amp; Elements Note: This is different from the List type in Python  Common Operations  Access - O(1) Search - O(n) Insert - O(n) Delete - O(n)  Characteristics  Easy to read Hard to write   Array Implementation in Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  # Create an array arr = [] # Add an element - O(1) if the position is empty;  # O(N) if the length of the array changes. arr.append(1) arr.append(2) arr.append(3) # [1,2,3] # Insert an element - O(N) arr.insert(2, 100) # [1,2,100,3] # Remove an element arr.remove(100) # case 1: [1,2,3] - O(N), where arg is an element arr.pop(1) # case 2: [1,3] - O(N), where arg is an index arr.pop() # case 3: [1] - O(1), where the last element is removed # Traverse an array - O(N) for item in arr: print(item) for id, item in enumerate(arr): print(\u0026#34;Index at \u0026#34;, id, \u0026#34; is: \u0026#34;, item) for id in range(0, len(arr)): print(arr[id]) # Find an element - O(N) arr[1,2,3] id = arr.index(3) # 2, where arg is an element # Sort an array - O(N*log(N)) arr = [3,1,2] arr.sort() # [1,2,3] a.sort(reverse=True) # [3,2,1]    Array Implementation in Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46  // Create an array int[] a = {1,2,3}; int[] b = new int[]{1,2,3}; int[] c = new int[3]; // The initilization is [0,0,0] for (int i=0, i \u0026lt; c.length; i++){ c[i] = i + 1; } ArrayList\u0026lt;Integer\u0026gt; d = new ArrayList\u0026lt;\u0026gt;(); // Integer is an object for (int i = 0; i \u0026lt; 3; i++){ d.add(i+1) } // Add an element // An addiotnal empty array should be declared for a, b, c. // For ArrayList, the length of the array could be ignored in declaration. d.add(100); // [1,2,3,100] - O(1) d.add(3, 99); // [1,2,3,99,100] - O(N), i.e. 100 should be moved backwards for 99.  // Access an element - O(1) int item1 = a[1]; int item2 = d.get(1); // Update an element - O(1) a[1] = 0; // [1,0,3,100] d.set(1, 0); // [1,0,3,99,100], where the 1st arg is the index; the 2nd arg is the new value.  // Remove an element for ArrayList - O(N) d.remove(99) // [1,2,3,100]  // Get the length of array - O(1), i.e. there is a cnt var inside int aLen = a.length; // String.length(), Array.length int dLen = d.size(); // Traverse an array - O(N) for (int i = 0; i \u0026lt; a.length; i++) { ... } for (int i = 0; i \u0026lt; d.size(); i++) { ... } // Find an element - O(N) // Loop should be adopted for a, b, c; // For ArrayList, use .contains() boolean is100 = d.contains(100) // Sort an array - O(N*log(N)) Array.sort(a) // Read from the last to reverse the array Collections.sort(d) Collections.sort(d, Collections.reverseOrder())    Reference  手把手带你刷Leetcode力扣 - 数组Array 手把手带你刷Leetcode力扣 - Python3数组常用操作 手把手带你刷Leetcode力扣 - Java数组常用操作   ","date":"2022-03-18T22:36:44+08:00","permalink":"https://tonyfpy.github.io/p/data-structure-topic-2-array/","title":"[Data Structure] Topic 2: Array"},{"content":" Authored by Tony Feng\nCreated on March 17th, 2022\nLast Modified on March 18th, 2022\n Time Complexity Def  The efficiency of the algorithm The relationship between the algorithm\u0026rsquo;s input and its execution time  Common Cases  O(1)  1 2 3 4  def O1(num): i = num j = num * 2 return i + j    O(n)  1 2 3 4 5  def ON(num): total = 0 for i in range(0, num): total += i return total    O(m+n)  1 2 3 4 5 6 7  def OMN(num1, num2): total = 0 for i in range(0, num1): total += 1 for j in range(0, num2): total += 1 return total    O(log(n))  1 2 3 4 5  def OlogN(num): i = 1 while i \u0026lt; num: i = i * 2 return i    O(n*log(n))  1 2 3 4 5 6 7 8  def ONlogN(num1, num2): total = 0 tmp = 1 for i in range(0, num1): while tmp \u0026lt; num2: total = i + tmp tmp = tmp * 2 return total    O(n2)  1 2 3 4 5 6  def ON2(num): total = 0 for i in range(0, num): for j in range(0, num): total += 1 return total   Comparison  O(1) \u0026lt; O(log(n)) \u0026lt; O(n) \u0026lt; O(n*log(n)) \u0026lt; O(n2) \u0026lt; O(2n) \u0026lt; O(n!)   Space Complexity Def  The relationship between the algorithm\u0026rsquo;s input and its memory space needed  Common Cases  O(1)  1 2 3 4 5 6  # total is a int variable with a 4-bytes memory def O1(num): total = 0 for i in range(0, num): total += i return total    O(n)  1 2 3 4 5 6  # nodes is a list whose memory depends on the input def On(nums): nodes = [] for num in nums: nodes.append(num) return nodes   Analysis Approches   Check the variable\n  If the variable varies in response to the input, e.g. array, linked list, hash map, etc., the space complexity may be O(n), O(n2) \u0026hellip;\n  If not, it is O(1)\n  Determine the space complexity case-by-case.\n  Be careful with the recursion. Info in each level are stored on a recursive stack.\n   Summary  There is a trade-off between time and space. Time should be considered in the first place.   Reference  手把手带你刷Leetcode力扣 - 算法的时间复杂度 手把手带你刷Leetcode力扣 - 算法的空间复杂度   ","date":"2022-03-17T22:26:52+08:00","permalink":"https://tonyfpy.github.io/p/data-structure-topic-1-time-and-space-complexity/","title":"[Data Structure] Topic 1: Time and Space Complexity"}]