[{"content":"  Authored by Tony Feng\nCreated on March 17th, 2022\nLast Modified on March 18th, 2022  Time Complexity Def  The efficiency of the algorithm The relationship between the algorithm\u0026rsquo;s input and its execution time  Common Cases  O(1)  1 2 3 4  def O1(num): i = num j = num * 2 return i + j    O(n)  1 2 3 4 5  def ON(num): total = 0 for i in range(0, num): total += i return total    O(m+n)  1 2 3 4 5 6 7  def OMN(num1, num2): total = 0 for i in range(0, num1): total += 1 for j in range(0, num2): total += 1 return total    O(log(n))  1 2 3 4 5  def OlogN(num): i = 1 while i \u0026lt; num: i = i * 2 return i    O(n*log(n))  1 2 3 4 5 6 7 8  def ONlogN(num1, num2): total = 0 tmp = 1 for i in range(0, num1): while tmp \u0026lt; num2: total = i + tmp tmp = tmp * 2 return total    O(n2)  1 2 3 4 5 6  def ON2(num): total = 0 for i in range(0, num): for j in range(0, num): total += 1 return total   Comparison  O(1) \u0026lt; O(log(n)) \u0026lt; O(n) \u0026lt; O(n*log(n)) \u0026lt; O(n2) \u0026lt; O(2n) \u0026lt; O(n!)   Space Complexity Def  The relationship between the algorithm\u0026rsquo;s input and its memory space needed  Common Cases  O(1)  1 2 3 4 5 6  # total is a int variable with a 4-bytes memory def O1(num): total = 0 for i in range(0, num): total += i return total    O(n)  1 2 3 4 5 6  # nodes is a list whose memory depends on the input def On(nums): nodes = [] for num in nums: nodes.append(num) return nodes   Analysis Approches   Check the variable\n  If the variable varies in response to the input, e.g. array, linked list, hash map, etc., the space complexity may be O(n), O(n2) \u0026hellip;\n  If not, it is O(1)\n  Determine the space complexity case-by-case.\n  Be careful with the recursion. Info in each level are stored on a recursive stack.\n   Summary  There is a trade-off between time and space. Time should be comsidered in the first place.   Reference  手把手带你刷Leetcode力扣 - 算法的时间复杂度 手把手带你刷Leetcode力扣 - 算法的空间复杂度  ","date":"2022-04-18T22:26:52+08:00","permalink":"https://tonyfpy.github.io/p/data-structure-topic-1-time-and-space-complexity/","title":"[Data Structure] Topic 1: Time and Space Complexity"},{"content":"  Authored by Tony Feng\nCreated on April 1st, 2022\nLast Modified on April 1st, 2022  Understanding Binary Search Intro  Binary search is often used to efficiently locate an item in a sorted sequence of items. It divides the search space in 2 after every comparison. Compared to linear search which requires O(N) running time, binary search only takes O(log N) where n is the size of the sequence.  Main Steps of the Algorithm  Pre-processing  Sort if collection is unsorted.   Binary Search  Using a loop or recursion to divide search space in half after each comparison.   Post-processing  Determine viable candidates in the remaining space    When Do We Use Binary Search?  The array is partially or fully sorted. The upper bound of time complexity is O(N) or O(log N).   Templates  There are many variants of binary search, such as [l, r), [l, r], (l, r], etc. We should be careful of loop condition, mid/left/right update and return value.\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  # The most common case def binarySearch(nums, target): \u0026#34;\u0026#34;\u0026#34; :type nums: List[int] :type target: int :rtype: int \u0026#34;\u0026#34;\u0026#34; if len(nums) == 0: return -1 left, right = 0, len(nums) - 1 while left \u0026lt;= right: mid = left + (right - left) // 2 # Avoid overflow if nums[mid] \u0026lt; target: left = mid + 1 elif nums[mid] \u0026gt; target: right = mid - 1 else: return mid # End Condition: left \u0026gt; right return -1    Examples 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56  # Leetcode 704 Binary Search def search(nums: List[int], target: int) -\u0026gt; int: if not nums or len(nums) == 0: return -1 l, r = 0, len(nums)-1 while l \u0026lt;= r: m = l + (r - l) // 2 if nums[m] \u0026gt; target: r = m - 1 elif nums[m] \u0026lt; target: l = m + 1 else: return m return -1 # Leetcode 35 Search Insert Position def searchInsert(nums: List[int], target: int) -\u0026gt; int: l, r = 0, len(nums)-1 while l \u0026lt; r: # break if l == r mid = l + (r - l) // 2 if nums[mid] \u0026lt; target: l = mid + 1 elif nums[mid] \u0026gt; target: r = mid - 1 else: return mid return l if target \u0026lt;= nums[l] else l + 1 # Leetcode 162 Find Peak Element def findPeakElement(nums: List[int]) -\u0026gt; int: l, r = 0, len(nums)-1 while l \u0026lt; r: m = l + (r - l) // 2 if nums[m] \u0026gt; nums[m+1]: r = m else: l = m + 1 return l # Leetcode 74 Search a 2D Matrix def searchMatrix(matrix: List[List[int]], target: int) -\u0026gt; bool: nums = [] for nums in matrix: if nums[-1] \u0026gt;= target: # Find which row the target is in l, r = 0, len(nums)-1 while l \u0026lt;= r: mid = l + (r - l) // 2 if nums[mid] \u0026lt; target: l = mid + 1 elif nums[mid] \u0026gt; target: r = mid - 1 else: return True return False    Reference  手把手带你刷Leetcode力扣 - 二分查找 Binary Search 手把手带你刷Leetcode力扣 - 力扣705 手把手带你刷Leetcode力扣 - 力扣35 手把手带你刷Leetcode力扣 - 力扣162 手把手带你刷Leetcode力扣 - 力扣74 Collection of Binary Search Templates  ","date":"2022-04-01T22:36:50+08:00","permalink":"https://tonyfpy.github.io/p/algorithm-topic-2-binary-search/","title":"[Algorithm] Topic 2: Binary Search"},{"content":" Authored by Tony Feng\nCreated on March 30th, 2022\nLast Modified on March 30th, 2022\n Understanding Two-pointer Algorithm Intro  The approach optimizes the runtime by utilizing some order (not necessarily sorting) of the data. It is generally applied on lists (arrays) and linked lists. Here, pointers represent either index or an iteration attribute like node’s Next.  Main Steps of the Algorithm  Pointer Initialization Pointer Movement Stop Condition  Categories  Old \u0026amp; New State Pointers Slow \u0026amp; Fast Pointers Left \u0026amp; Right Pointers Pointers from Two Sequences Sliding Window   Old \u0026amp; New State Pointers Template 1 2 3 4 5 6  def old_new_state(self, arr): # initialize states old, new = default_val1, default_val2 for item in arr: # process current element with old state old, new = new, self.some_func(item, old)   Examples 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  # Leetcode 509 Fibonacci Number # Each number is the sum of the two preceding ones, starting from 0 and 1. def fibonacci(n: int) -\u0026gt; int: a, b = 0, 1 for i in range(n + 1): a, b = b, a + b return a # Leetcode 198 House Robber # Determine the maximum amount of money you can steal tonight without robbing adjacent houses. def rob(nums: \u0026#39;List[int]\u0026#39;) -\u0026gt; int: last, now = 0, 0 for i in nums: last, now = now, max(last + i, now) return now    Slow \u0026amp; Fast Pointers Template 1 2 3 4 5 6 7 8 9 10 11 12  def slow_fast_runner(self, arr): # initialize slow runner slow = arr[0] # fast-runner grows each iteration generally for fast in range(arr): #slow-runner grows with some restrictions if self.slow_condition(slow): slow = slow.next # slow += 1 # process logic before or after pointers movement self.some_func(slow, fast)   Examples 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38  # Leetcode 141 Linked List Cycle def hasCycle(head: Optional[ListNode]) -\u0026gt; bool: if not head or not head.next: return False slow, fast = head, head while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: return True return False # Leetcode 881 Boats to Save People def numRescueBoats(people: List[int], limit: int) -\u0026gt; int: people = sorted(people) i, j, res = 0, len(people)-1, 0 while i \u0026lt;= j: if people[i] + people[j] \u0026lt;= limit: i = i + 1 j = j - 1 res += 1 return res # Leetcode 26 Remove Duplicates from Sorted Array # Given a sorted array nums, remove the duplicates in place such # that each element appear only once and return the new length. def removeDuplicates(nums: \u0026#39;List[int]\u0026#39;) -\u0026gt; int: if not nums: return 0 slow = 0 for fast in range(1, len(nums)): # if current element is not duplicate,  # slow runner grows one step and copys the current value if nums[slow] != nums[fast]: slow += 1 nums[slow] = nums[fast] return slow + 1    Left \u0026amp; Right Pointers Template 1 2 3 4 5 6 7 8 9 10 11  def left_right_boundary(arr): left, right = 0, len(arr) - 1 while left \u0026lt; right: # left index moves when satisfy the condition if self.left_condition(left): left += 1 # right index move when satisfy the condition if self.right_condition(right): right -= 1 # process logic before or after pointers movement self.some_func(left, right)   Examples 1 2 3 4 5 6 7 8 9 10 11 12 13  # Leetcode 167 Two Sum II - Input Array Is Sorted # Given an array of integers that is already sorted in ascending  # order, find two numbers such that they add up to a specific target number. def twoSum(numbers: \u0026#39;List[int]\u0026#39;, target: \u0026#39;int\u0026#39;) -\u0026gt; \u0026#39;List[int]\u0026#39;: left, right = 0, len(numbers) - 1 while left \u0026lt; right: if numbers[left] + numbers[right] == target: return [left + 1, right + 1] if numbers[left] + numbers[right] \u0026lt; target: left += 1 else: right -= 1 return [0, 0]    Pointers from Two Sequences Template 1 2 3 4 5 6 7 8 9 10 11 12 13  def pointers_from_two_seq(self, arr1, arr2): # init pointers p1, p2 = 0, 0 # or seq1[0], seq2[0] while p1 \u0026lt; len(arr1) and p2 \u0026lt; len(arr2): # or other condition # p1 index moves when satisfy the condition if self.p1_condition(p1): p1 += 1 # or p1 = next(seq1) # p2 index move when satisfy the condition if self.p2_condition(p2): p2 += 1 # or p2 = next(seq2) # process logic before or after pointers movement self.some_func(p1, p2)   Examples 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  # Leetcode 244 Shortest Word Distance II # Design a class which receives a list of words in the constructor  # and implements a method that takes two words, word1 and word2, and  # returns the shortest distance between these two words in the list. class WordDistance: def __init__(self, words: \u0026#39;List[str]\u0026#39;): self.locations = defaultdict(list) # Prepare a mapping from a word to all it\u0026#39;s locations (indices). for i, w in enumerate(words): self.locations[w].append(i) def shortest(self, word1: str, word2: str) -\u0026gt; int: loc1, loc2 = self.locations[word1], self.locations[word2] l1, l2 = 0, 0 min_diff = float(\u0026#34;inf\u0026#34;) # Until the shorter of the two lists is processed while l1 \u0026lt; len(loc1) and l2 \u0026lt; len(loc2): min_diff = min(min_diff, abs(loc1[l1] - loc2[l2])) if loc1[l1] \u0026lt; loc2[l2]: l1 += 1 else: l2 += 1 return min_diff    Sliding Window  There are two types of window\n  The fixed size window can be used for problem where you want to determine whether given string contain a specific substring.\n  The dynamic one can be used to find the longest or shortest substring of the given string.\n   Template 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  def sliding_window(self, arr): start, end = 0, 0 while end \u0026lt; len(arr): # end pointer grows in the outer loop end += 1 # start pointer grows with some restrict while self.start_condition(start): # process logic before pointers movement self.some_func(start, end) # start grows in the inner loop start += 1 # or process logic after pointers movement self.some_func(start, end)   Examples 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52  # Leetcode 209 Minimum Size Subarray Sum # Given an array of positive integers nums and a positive integer  # target, return the minimal length of a contiguous subarray of  # which the sum is greater than or equal to target. def minSubArrayLen(target: int, nums: List[int]) -\u0026gt; int: if not nums or len(nums) == 0: return 0 l, r = 0, 0 res = len(nums) + 1 add = 0 while r \u0026lt; len(nums): add += nums[r] r += 1 # Upsizing the window while add \u0026gt;= target: # Downsizing the window iteratively res = min(res, r - l) add -= nums[l] l += 1 return res if res != len(nums) + 1 else 0 # Leetcode 1456 Maximum Number of Vowels in a Substring of Given Length # Given a string s and an integer k, return the maximum number of vowel  # letters in any substring of s with length k. def maxVowels(self, s: str, k: int) -\u0026gt; int: if not s or len(s) == 0 or len(s) \u0026lt; k: return 0 vl = set([\u0026#39;a\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;i\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;u\u0026#39;]) # Quick for search i, j = 0, 0 res, tmp = 0, 0 while j \u0026lt; len(s): if j - i \u0026lt; k: # Get the number of vowel letters in the first sliding window if s[j] in vl: tmp += 1 res = tmp j += 1 else: # Pop the first item if s[i] in vl: tmp -= 1 i += 1 # Add the next item if s[j] in vl: tmp += 1 res = max(tmp, res) j += 1 return res    Reference  手把手带你刷Leetcode力扣 - 双指针 Two Pointers 手把手带你刷Leetcode力扣 - 力扣141 手把手带你刷Leetcode力扣 - 力扣881 手把手带你刷Leetcode力扣 - 滑动窗口 Sliding Window 手把手带你刷Leetcode力扣 - 力扣209 手把手带你刷Leetcode力扣 - 力扣1456 Two Pointers Approach — Python Code Algorithm Templates: Two Pointers - Part 1 Algorithm Templates: Two Pointers - Part 2 Algorithm Templates: Two Pointers - Part 3 Effective LeetCode: Understanding the Sliding Window Pattern  ","date":"2022-03-30T22:59:15+08:00","permalink":"https://tonyfpy.github.io/p/algorithm-topic-1-two-pointers/","title":"[Algorithm] Topic 1: Two Pointers"}]