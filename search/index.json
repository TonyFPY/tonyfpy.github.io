[{"content":" Authored by Tony Feng\nCreated on March 17th, 2022\nLast Modified on March 18th, 2022\n Time Complexity Def  The efficiency of the algorithm The relationship between the algorithm\u0026rsquo;s input and its execution time  Common Cases  O(1)  1 2 3 4  def O1(num): i = num j = num * 2 return i + j    O(n)  1 2 3 4 5  def ON(num): total = 0 for i in range(0, num): total += i return total    O(m+n)  1 2 3 4 5 6 7  def OMN(num1, num2): total = 0 for i in range(0, num1): total += 1 for j in range(0, num2): total += 1 return total    O(log(n))  1 2 3 4 5  def OlogN(num): i = 1 while i \u0026lt; num: i = i * 2 return i    O(n*log(n))  1 2 3 4 5 6 7 8  def ONlogN(num1, num2): total = 0 tmp = 1 for i in range(0, num1): while tmp \u0026lt; num2: total = i + tmp tmp = tmp * 2 return total    O(n2)  1 2 3 4 5 6  def ON2(num): total = 0 for i in range(0, num): for j in range(0, num): total += 1 return total   Comparison  O(1) \u0026lt; O(log(n)) \u0026lt; O(n) \u0026lt; O(n*log(n)) \u0026lt; O(n2) \u0026lt; O(2n) \u0026lt; O(n!)   Space Complexity Def  The relationship between the algorithm\u0026rsquo;s input and its memory space needed  Common Cases  O(1)  1 2 3 4 5 6  # total is a int variable with a 4-bytes memory def O1(num): total = 0 for i in range(0, num): total += i return total    O(n)  1 2 3 4 5 6  # nodes is a list whose memory depends on the input def On(nums): nodes = [] for num in nums: nodes.append(num) return nodes   Analysis Approches   Check the variable\n  If the variable varies in response to the input, e.g. array, linked list, hash map, etc., the space complexity may be O(n), O(n2) \u0026hellip;\n  If not, it is O(1)\n  Determine the space complexity case-by-case.\n  Be careful with the recursion. Info in each level are stored on a recursive stack.\n   Summary  There is a trade-off between time and space. Time should be considered in the first place.   Reference  手把手带你刷Leetcode力扣 - 算法的时间复杂度 手把手带你刷Leetcode力扣 - 算法的空间复杂度  ","date":"2022-04-18T22:26:52+08:00","permalink":"https://tonyfpy.github.io/p/data-structure-topic-1-time-and-space-complexity/","title":"[Data Structure] Topic 1: Time and Space Complexity"},{"content":" Authored by Tony Feng\nCreated on April 10th, 2022\nLast Modified on April 10th, 2022\n Understanding Dynamic Programming Intro  Dynamic Programming helps to efficiently solve a class of problems that have overlapping subproblems and optimal substructure property. Key elements  Initialization State-transition Equation Termination    Characteristics  Overlapping Subproblems  Any problem has overlapping sub-problems if finding its solution involves solving the same subproblem multiple times.   Optimal Substructure Property  Any problem has optimal substructure property if its overall optimal solution can be constructed from the optimal solutions of its subproblems.    Dynamic Programming Methods  Top-down with Memoization  In this approach, we try to solve the bigger problem by recursively finding the solution to smaller sub-problems. Whenever we solve a sub-problem, we cache its result so that we can just return the saved result if it’s called multiple times.   Bottom-up with Tabulation  Tabulation is the opposite of the top-down approach and avoids recursion. In this approach, we solve the problem “bottom-up” (i.e. by solving all the related sub-problems first). This is typically done by filling up an n-dimensional table. Based on the results in the table, the solution to the top/original problem is then computed.     Examples Leetcode 509 Fibonacci Number 1 2 3 4 5 6 7 8 9 10 11 12  class Solution: def fib(self, n: int) -\u0026gt; int: if n == 0: return 0 if n == 1: return 1 dp = [0] * (n + 1) dp[0], dp[1] = 0, 1 for i in range(2, n+1): dp[i] = dp[i-1] + dp[i-2] # State-transition Equation return dp[n]   Leetcode 62 Unique Paths 1 2 3 4 5 6 7 8 9 10 11 12 13 14  class Solution: def uniquePaths(self, m: int, n: int) -\u0026gt; int: dp = [[1 for _ in range(n)] for _ in range(m)] for i in range(0, m): for j in range(0, n): if i - 1 \u0026lt; 0: dp[i][j] = dp[i][j-1] elif j - 1 \u0026lt; 0: dp[i][j] = dp[i-1][j] else: dp[i][j] = dp[i-1][j] + dp[i][j-1] return dp[m - 1][n - 1]    Reference  手把手带你刷Leetcode力扣 - 动态规划 Dynamic Programming 手把手带你刷Leetcode力扣 - Leetcode 509 手把手带你刷Leetcode力扣 - Leetcode 62 What is Dynamic Programming? Programiz - Dynamic Programming  ","date":"2022-04-10T22:37:31+08:00","permalink":"https://tonyfpy.github.io/p/algorithm-topic-10-dynamic-programming/","title":"[Algorithm] Topic 10: Dynamic Programming"},{"content":" Authored by Tony Feng\nCreated on April 9th, 2022\nLast Modified on April 9th, 2022\n Understanding Greedy Search Intro  A greedy algorithm is an approach for solving a problem by selecting the best option available at the moment. It works in a top-down approach. It doesn\u0026rsquo;t guarantee whether the current best result will bring the overall optimal result. We can determine if the algorithm can be used with any problem if the problem has the following properties:  Greedy Choice Property Optimal Substructure    Characteristics  Advantages of Greedy Approach  The algorithm is easier to describe.   Drawback of Greedy Approach  The greedy algorithm doesn\u0026rsquo;t always produce the optimal solution. The difficult part is that for greedy algorithms you have to work much harder to understand correctness issues. Optimization problems (Dijkstra’s Algorithm) with negative graph edges cannot be solved using a greedy algorithm.    Steps  To begin with, the solution set (containing answers) is empty. At each step, an item is added to the solution set until a solution is reached. If the solution set is feasible, the current item is kept. Else, the item is rejected and never considered again.   Template 1 2 3 4 5 6 7 8 9 10  # Pseudocode Greedy(input I): begin while (solution is not complete) do Select the best element x in the remaining input I; Put x next in the output; Remove x from the remaining input; endwhile end    Examples Leetcode 55 Jump Game 1 2 3 4 5 6 7 8 9 10 11 12  class Solution: def canJump(self, nums): \u0026#34;\u0026#34;\u0026#34; :type nums: List[int] :rtype: bool \u0026#34;\u0026#34;\u0026#34; reach = 0 for i, num in enumerate(nums): if i \u0026gt; reach: return False reach = max(reach, i + num) return True    Reference  手把手带你刷Leetcode力扣 - 贪心算法 Greedy Search Greedy Algorithms Explained with Examples  ","date":"2022-04-09T22:37:19+08:00","permalink":"https://tonyfpy.github.io/p/algorithm-topic-9-greedy-search/","title":"[Algorithm] Topic 9: Greedy Search"},{"content":" Authored by Tony Feng\nCreated on April 7th, 2022\nLast Modified on April 9th, 2022\n Understanding Union Find Intro  A disjoint-set data structure keeps track of a set of elements partitioned into a number of disjoint (non-overlapping) subsets. A union-find algorithm performs union and find operation on those subsets. Union-Find Algorithm can be used to check whether an undirected graph contains cycle or not.  Union \u0026amp; Find  Find  It determines in which subset a particular element is in and returns the representative of that particular set.   Union  It merges two different subsets into a single subset, and the representative of one set becomes representative of another.     Template Common Union Find 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  class UnionFind: def __init__(self, n): # Initialization.  # The parent of each node is itself. self.root = list(range(0,n)) def find(self, x): if x == self.root[x]: return self.root[x] else: return self.find(self.root[x]) def union(self, x, y): rootX = self.root[x] rootY = self.root[y] if rootX != rootY: self.root[rootX] = rootY   Union Find Improvement 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  class UnionFind: def __init__(self, n): # Initialization.  # The parent of each node is itself. self.root = list(range(0,n)) self.rank = [0] * n def find(self, x): if x != self.root[x]: # Use recursion to assign the root value self.root[x] = self.find(self.root[x]) return self.root[x] # Avoid the tree to be too high def union(self, x, y): rootX = self.root[x] rootY = self.root[y] if rootX != rootY: if self.rank[rootX] \u0026gt; self.rank[rootY]: self.root[rootY] = rootX elif self.rank[rootX] \u0026lt; self.rank[rootY]: self.root[rootX] = rootY else: self.root[rootY] = rootX self.rank[rootX] += 1    Examples Leetcode 200 Number of Islands 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48  # Time Complexity: O(MN) # Space Complexity: O(MN) class Solution: def numIslands(self, grid: List[List[str]]) -\u0026gt; int: if grid is None or len(grid) == 0: return 0 row = len(grid) col = len(grid[0]) waters = 0 uf = UnionFind(grid) for i in range(0, row): for j in range(0, col): if grid[i][j] == \u0026#39;0\u0026#39;: waters += 1 else: directions = [(0,1), (0,-1), (-1,0), (1,0)] for x, y in directions: x = x + i y = y + j if x\u0026gt;=0 and y\u0026gt;=0 and x\u0026lt;row and y\u0026lt;col and grid[x][y] == \u0026#39;1\u0026#39;: uf.union(x*col+y, i*col+j) return uf.getCount() - waters class UnionFind: def __init__(self, grid): row = len(grid) col = len(grid[0]) self.root = [-1]*(row*col) self.count = row*col for i in range(0, row*col): self.root[i] = i def find(self, x): if x == self.root[x]: return self.root[x] else: self.root[x] = self.find(self.root[x]) return self.root[x] def union(self, x, y): rootX = self.find(x) rootY = self.find(y) if rootX != rootY: self.root[rootX] = rootY self.count -= 1 def getCount(self): return self.count    Reference  手把手带你刷Leetcode力扣 - 并查集 Union Find 手把手带你刷Leetcode力扣 - 并查集优化 Union Find Optimization 手把手带你刷Leetcode力扣 - Leetcode 200 Disjoint Set (Or Union-Find) Disjoint–Set Data Structure (Union–Find Algorithm)  ","date":"2022-04-07T22:37:04+08:00","permalink":"https://tonyfpy.github.io/p/algorithm-topic-8-union-find/","title":"[Algorithm] Topic 8: Union Find"},{"content":" Authored by Tony Feng\nCreated on April 6th, 2022\nLast Modified on April 6th, 2022\n Understanding BFS Intro  Breadth-First Search (BFS) is an algorithm used for traversing graphs or trees. Breadth-First Search is a recursive algorithm to search all the vertices of a graph or a tree. BFS starts from a node, then it checks all the nodes at distance I from the beginning node, then it checks all the nodes at distance II, and so on. In order to re-collect the nodes to be visited, BFS uses a queue. The time complexity of DFS if the entire tree is traversed is O(V), where V is the number of nodes. In the case of a graph, the time complexity is O(V + E), where V is the number of vertexes and E is the number of edges.  Please note that O(E) may vary between O(1) and O(V2), depending on how dense the graph is.    Steps of BFS  Add the root/start node to the Queue. For every node, set that they don\u0026rsquo;t have a defined parent node. Until the Queue is empty:  Extract the node from the beginning of the Queue. Perform output processing. For every neighbor of the current node that doesn\u0026rsquo;t have a defined parent (is not visited), add it to the Queue, and set the current node as their parent.     Template 1 2 3 4 5 6 7 8 9 10 11 12  def bfs(visited, graph, node): #function for BFS visited.append(node) queue.append(node) while queue: # Creating loop to visit each node m = queue.pop(0) print (m, end = \u0026#34; \u0026#34;) for neighbour in graph[m]: if neighbour not in visited: visited.append(neighbour) queue.append(neighbour)    Examples Leetcode 102 Binary Tree Level Order Traversal 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  from collections import deque class Solution: def levelOrder(self, root: Optional[TreeNode]) -\u0026gt; List[List[int]]: if not root: return [] ans = [] q = deque() # Store nodes q.append(root) while len(q) \u0026gt; 0: size = len(q) # Get how many nodes are in current level tmp = [] # Store nodes in the current level while size \u0026gt; 0: node = q.popleft() tmp.append(node.val) if node.left: q.append(node.left) if node.right: q.append(node.right) size -= 1 ans.append(tmp[:]) return ans   Leetcode 200 Number of Islands 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  class Solution: def numIslands(self, grid: List[List[str]]) -\u0026gt; int: if not grid or len(grid) == 0: return 0 res = 0 q = deque() for i in range(0, len(grid)): for j in range(0, len(grid[0])): if grid[i][j] == \u0026#34;1\u0026#34;: res += 1 q.append([i,j]) grid[i][j] = \u0026#34;2\u0026#34; while len(q) \u0026gt; 0: cur = q.popleft() [x,y] = cur if x-1 \u0026gt;= 0 and grid[x-1][y] == \u0026#34;1\u0026#34;: q.append([x-1,y]) grid[x-1][y] = \u0026#34;2\u0026#34; if x+1 \u0026lt; len(grid) and grid[x+1][y] == \u0026#34;1\u0026#34;: q.append([x+1,y]) grid[x+1][y] = \u0026#34;2\u0026#34; if y-1 \u0026gt;= 0 and grid[x][y-1] == \u0026#34;1\u0026#34;: q.append([x, y-1]) grid[x][y-1] = \u0026#34;2\u0026#34; if y+1 \u0026lt; len(grid[0]) and grid[x][y+1] == \u0026#34;1\u0026#34;: q.append([x, y+1]) grid[x][y+1] = \u0026#34;2\u0026#34; return res    Reference  手把手带你刷Leetcode力扣 - 广度优先搜索 BFS 手把手带你刷Leetcode力扣 - Leetcode 102 手把手带你刷Leetcode力扣 - Leetcode 107 手把手带你刷Leetcode力扣 - Leetcode 200 Breadth First Search in Python (with Code) | BFS Algorithm Graphs in Python: Breadth-First Search (BFS) Algorithm What is Breadth First Search?  ","date":"2022-04-06T22:36:48+08:00","permalink":"https://tonyfpy.github.io/p/algorithm-topic-7-breadth-first-search/","title":"[Algorithm] Topic 7: Breadth-First Search"},{"content":" Authored by Tony Feng\nCreated on April 5th, 2022\nLast Modified on April 5th, 2022\n Understanding DFS Intro  Depth-first search is an algorithm for traversing or searching tree or graph data structures. The algorithm starts at the root node (selecting some arbitrary node as the root node in the case of a graph) and explores as far as possible along each branch before backtracking. The time complexity of DFS if the entire tree is traversed is O(V), where V is the number of nodes; In the case of a graph, the time complexity is O(V + E), where V is the number of vertexes and E is the number of edges.  Steps of DFS  Create a recursive function that takes the index of the node and a visited array. Mark the current node as visited and print the node. Traverse all the adjacent and unmarked nodes and call the recursive function with the index of the adjacent node.   Template 1 2 3 4 5 6  def dfs(visited, graph, node): if node not in visited: print (node) visited.add(node) for neighbour in graph[node]: dfs(visited, graph, neighbour)    Examples Leetcode 78 Subsets 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  class Solution: def subsets(self, nums: List[int]) -\u0026gt; List[List[int]]: ans = [] def dfs(nums, res, index, subset): res.append(subset[:]) if index == len(nums): return for id in range(index, len(nums)): subset.append(nums[id]) dfs(nums, res, id+1, subset) subset.pop() dfs(nums, ans, 0, []) return ans   Leetcode 200 Number of Islands 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  class Solution: def numIslands(self, grid: List[List[str]]) -\u0026gt; int: def dfs(grid, i, j): if i \u0026lt; 0 or j \u0026lt; 0 or i \u0026gt;= len(grid) or j \u0026gt;= len(grid[0]) or grid[i][j] != \u0026#39;1\u0026#39;: return grid[i][j] = \u0026#39;2\u0026#39; dfs(grid, i+1, j) dfs(grid, i-1, j) dfs(grid, i, j+1) dfs(grid, i, j-1) if not grid or len(grid) == 0: return 0 count = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == \u0026#39;1\u0026#39;: dfs(grid, i, j) count += 1 return count   Leetcode 102 Binary Tree Level Order Traversal 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  class Solution: def levelOrder(self, root: Optional[TreeNode]) -\u0026gt; List[List[int]]: def dfs(node, ans, level): if not node: return if level \u0026gt; len(ans) - 1: ans.append([]) ans[level].append(node.val) if node.left: dfs(node.left, ans, level + 1) if node.right: dfs(node.right, ans, level + 1) if not root: return root ans = [] dfs(root, ans, 0) return ans    Reference  手把手带你刷Leetcode力扣 - 深度优先搜索 DFS 手把手带你刷Leetcode力扣 - Leetcode 938 手把手带你刷Leetcode力扣 - Leetcode 200 Depth First Search or DFS for a Graph Depth First Search (DFS) What is Depth First Search?  ","date":"2022-04-05T22:36:36+08:00","permalink":"https://tonyfpy.github.io/p/algorithm-topic-6-depth-first-search/","title":"[Algorithm] Topic 6: Depth-First Search"},{"content":" Authored by Tony Feng\nCreated on April 4th, 2022\nLast Modified on April 4th, 2022\n Understanding Backtracking Intro  A backtracking algorithm is a problem-solving algorithm that uses a brute-force approach for finding the desired output. The term backtracking suggests that if the current solution is not suitable, then go back and try other solutions. Backtracking uses recursion to discover all of the possibilities until we get the best end result for the problem. State Space Tree  A space state tree is a tree representing all the possible states (solution or nonsolution) of the problem from the root as an initial state to the leaf as a terminal state. In combinatorial search problems, search space is in the shape of a tree.    Types of Problems  Decision Problem: Search for a feasible solution Optimization Problem: Search for the best solution Enumeration Problem: Find all feasible soutions   Template 1 2 3 4 5 6 7 8 9 10 11  # Pseudocode function backtracking(node, state): if state is a solution: report(state) # e.g. add state to final result list return for child in children: if child is a part of a potential solution: state.add(child) # make move backtracking(child, state) state.remove(child) # backtrack    Examples Leetcode 46 Permutations 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  class Solution: def permute(self, nums: List[int]) -\u0026gt; List[List[int]]: ans = [] def backtrack(path, cnt): if cnt == 0: ans.append(path[:]) # Copy the content instead of the reference return for item in nums: if not item in path: path.append(item) backtrack(path, cnt-1) path.pop() backtrack([],len(nums)) return ans   Leetcode 77 Combinations 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  class Solution: def combine(self, n: int, k: int) -\u0026gt; List[List[int]]: ans = [] nums = list(range(1, n+1)) def backtrack(path, m): if len(path)==k: ans.append(path[:]) return for i in range(m, len(nums)): path.append(nums[i]) backtrack(path, i+1) path.pop() backtrack([],0) return ans   Leetcode 78 Subsets 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  class Solution: def subsets(self, nums: List[int]) -\u0026gt; List[List[int]]: ans = [[]] def backtrack(path, lmt, index): if len(path) == lmt: ans.append(path[:]) return for id in range(index, len(nums)): path.append(nums[id]) backtrack(path, lmt, id+1) path.pop() for i in range(1, len(nums)+1): backtrack([], i, 0) return ans   Leetcode 22 Generate Parentheses 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  class Solution: def generateParenthesis(self, n: int) -\u0026gt; List[str]: left, right = 0, 0 ans = [] def backtrack(path, l, r): if l == n and r == n: path = (\u0026#34;\u0026#34;).join(path) ans.append(path[:]) return # The number of right bracket cannot exceed that of left bracket. if l \u0026lt; r: return if l \u0026lt;= n: path.append(\u0026#34;(\u0026#34;) backtrack(path, l+1, r) path.pop() if l \u0026gt; r: path.append(\u0026#34;)\u0026#34;) backtrack(path, l, r+1) path.pop() backtrack([], left, right) return ans    Reference  手把手带你刷Leetcode力扣 - 回溯法 Backtracking 手把手带你刷Leetcode力扣 - Leetcode 22 手把手带你刷Leetcode力扣 - Leetcode 78 Backtracking in Python Backtracking Template  ","date":"2022-04-04T22:36:22+08:00","permalink":"https://tonyfpy.github.io/p/algorithm-topic-5-backtracking/","title":"[Algorithm] Topic 5: Backtracking"},{"content":" Authored by Tony Feng\nCreated on April 3rd, 2022\nLast Modified on April 3rd, 2022\n Understanding Divide \u0026amp; Conquer Intro  In computer science, divide and conquer is an algorithm design paradigm. A divide-and-conquer algorithm recursively breaks down a problem into two or more sub-problems of the same or related type, until these become simple enough to be solved directly.  Components  Divide/Break  This involves dividing the problem into smaller sub-problems.   Conquer/Solve  Solve sub-problems by calling recursively until solved.   Combine/Merge  Combine the sub-problems to get the final solution of the whole problem.    Applications  Merge Sort Quick Sort Binary Search Strassen\u0026rsquo;s Matrix Multiplication Closest pair (points)   Examples Tower of Hanoi 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  def TowerOfHanoi(n , source, destination, auxiliary): if n==1: print (\u0026#34;Move disk 1 from source\u0026#34;,source,\u0026#34;to destination\u0026#34;,destination) return TowerOfHanoi(n-1, source, auxiliary, destination) print (\u0026#34;Move disk\u0026#34;,n,\u0026#34;from source\u0026#34;,source,\u0026#34;to destination\u0026#34;,destination) TowerOfHanoi(n-1, auxiliary, destination, source) # Driver code n = 4 TowerOfHanoi(n,\u0026#39;A\u0026#39;,\u0026#39;B\u0026#39;,\u0026#39;C\u0026#39;) # A, C, B are the name of rods \u0026#39;\u0026#39;\u0026#39; Move disk 1 from source A to destination C Move disk 2 from source A to destination B Move disk 1 from source C to destination B Move disk 3 from source A to destination C Move disk 1 from source B to destination A Move disk 2 from source B to destination C Move disk 1 from source A to destination C Move disk 4 from source A to destination B Move disk 1 from source C to destination B Move disk 2 from source C to destination A Move disk 1 from source B to destination A Move disk 3 from source C to destination B Move disk 1 from source A to destination C Move disk 2 from source A to destination B Move disk 1 from source C to destination B \u0026#39;\u0026#39;\u0026#39;   Merge Sort 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49  def mergeSort(arr): if len(arr) \u0026gt; 1: # Finding the mid of the array mid = len(arr)//2 # Dividing the array elements into 2 halves L = arr[:mid] R = arr[mid:] # Sort mergeSort(L) mergeSort(R) i = j = k = 0 # Copy data to temp arrays L[] and R[] while i \u0026lt; len(L) and j \u0026lt; len(R): if L[i] \u0026lt; R[j]: arr[k] = L[i] i += 1 else: arr[k] = R[j] j += 1 k += 1 # Checking if any element was left while i \u0026lt; len(L): arr[k] = L[i] i += 1 k += 1 while j \u0026lt; len(R): arr[k] = R[j] j += 1 k += 1 # Code to print the list def printList(arr): for i in range(len(arr)): print(arr[i], end=\u0026#34; \u0026#34;) print() # Driver Code if __name__ == \u0026#39;__main__\u0026#39;: arr = [12, 11, 13, 5, 6, 7] print(\u0026#34;Given array is\u0026#34;, end=\u0026#34;\\n\u0026#34;) printList(arr) mergeSort(arr) print(\u0026#34;Sorted array is: \u0026#34;, end=\u0026#34;\\n\u0026#34;) printList(arr)    Reference  手把手带你刷Leetcode力扣 - 分治法 Divide \u0026amp; Conquer Programiz - Divide \u0026amp; Conquer GreekforGreek - Merge Sort GreekforGreek - Python Program for Tower of Hanoi  ","date":"2022-04-03T22:30:30+08:00","permalink":"https://tonyfpy.github.io/p/algorithm-topic-4-divide-conquer/","title":"[Algorithm] Topic 4: Divide \u0026 Conquer"},{"content":" Authored by Tony Feng\nCreated on April 2nd, 2022\nLast Modified on April 2nd, 2022\n Understanding Recursion Intro  Recursion is the process of defining a problem (or the solution to a problem) in terms of (a simpler version of) itself. Memoization could be used to save computational time.  Components of Recursion  Base Case  The point where you stop applying the recursive case   Recursive Steps  Divide the problem into one or more simpler or smaller parts of the problem; Call the function (recursively) on each part; Combine the solutions of the parts into a solution for the problem.    Characteristics  Advantages of Recursion  Recursive functions make the code look clean and elegant. A complex task can be broken down into simpler sub-problems using recursion. Sequence generation is easier with recursion than using some nested iteration.   Disadvantages of Recursion  Sometimes the logic behind recursion is hard to follow through. Recursive calls are expensive (inefficient) as they take up a lot of memory and time. Recursive functions are hard to debug.     Examples The Factorial of an Integer 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  term = [0 for i in range(10)] # Memoization # Fibonacci Series using memoized Recursion def fib(n): # base case if n \u0026lt;= 1: return n # if fib(n) has already been computed we do not do further  # recursive calls and hence reduce the number of repeated work; # else store the computed value of fib(n) in an array term at # index n if term[n] != 0: return term[n] else: term[n] = fib(n - 1) + fib(n - 2) return term[n]   Leetcode 509 Fibonacci Number 1 2 3 4 5 6 7 8  # Time: O(N) # Space: O(N) i.e. Recursive Stack class Solution: def fib(self, n: int) -\u0026gt; int: if n \u0026lt;= 1: return n return self.fib(n - 1) + self.fib(n - 2)   Leetcode 206 Reverse Linked List 1 2 3 4 5 6 7 8 9 10  class Solution: def reverseList(self, head: Optional[ListNode]) -\u0026gt; Optional[ListNode]: if not head or not head.next: return head node = self.reverseList(head.next) head.next.next = head head.next = None return node    Reference  手把手带你刷Leetcode力扣 - 递归 Recursion 手把手带你刷Leetcode力扣 - 力扣509 手把手带你刷Leetcode力扣 - 力扣206 Programiz - Python Recursion WTF is Memoization  ","date":"2022-04-02T23:49:58+08:00","permalink":"https://tonyfpy.github.io/p/algorithm-topic-3-recursion/","title":"[Algorithm] Topic 3: Recursion"},{"content":" Authored by Tony Feng\nCreated on April 1st, 2022\nLast Modified on April 1st, 2022\n Understanding Binary Search Intro  Binary search is often used to efficiently locate an item in a sorted sequence of items. It divides the search space in 2 after every comparison. Compared to linear search which requires O(N) running time, binary search only takes O(log N) where n is the size of the sequence.  Main Steps of the Algorithm  Pre-processing  Sort if collection is unsorted.   Binary Search  Using a loop or recursion to divide search space in half after each comparison.   Post-processing  Determine viable candidates in the remaining space    When Do We Use Binary Search?  The array is partially or fully sorted. The upper bound of time complexity is O(N) or O(log N).   Templates  There are many variants of binary search, such as [l, r), [l, r], (l, r], etc. We should be careful of loop condition, mid/left/right update and return value.\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  # The most common case class Solution: def binarySearch(self, nums, target): \u0026#34;\u0026#34;\u0026#34; :type nums: List[int] :type target: int :rtype: int \u0026#34;\u0026#34;\u0026#34; if len(nums) == 0: return -1 left, right = 0, len(nums) - 1 while left \u0026lt;= right: mid = left + (right - left) // 2 # Avoid overflow if nums[mid] \u0026lt; target: left = mid + 1 elif nums[mid] \u0026gt; target: right = mid - 1 else: return mid # End Condition: left \u0026gt; right return -1    Examples Leetcode 704 Binary Search 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  class Solution: def search(self, nums: List[int], target: int) -\u0026gt; int: if not nums or len(nums) == 0: return -1 l, r = 0, len(nums)-1 while l \u0026lt;= r: m = l + (r - l) // 2 if nums[m] \u0026gt; target: r = m - 1 elif nums[m] \u0026lt; target: l = m + 1 else: return m return -1   Leetcode 35 Search Insert Position 1 2 3 4 5 6 7 8 9 10 11 12  class Solution: def searchInsert(self, nums: List[int], target: int) -\u0026gt; int: l, r = 0, len(nums)-1 while l \u0026lt; r: # break if l == r mid = l + (r - l) // 2 if nums[mid] \u0026lt; target: l = mid + 1 elif nums[mid] \u0026gt; target: r = mid - 1 else: return mid return l if target \u0026lt;= nums[l] else l + 1   Leetcode 162 Find Peak Element 1 2 3 4 5 6 7 8 9 10  class Solution: def findPeakElement(self, nums: List[int]) -\u0026gt; int: l, r = 0, len(nums)-1 while l \u0026lt; r: m = l + (r - l) // 2 if nums[m] \u0026gt; nums[m+1]: r = m else: l = m + 1 return l   Leetcode 74 Search a 2D Matrix 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  class Solution: def searchMatrix(self, matrix: List[List[int]], target: int) -\u0026gt; bool: nums = [] for nums in matrix: if nums[-1] \u0026gt;= target: # Find which row the target is in l, r = 0, len(nums)-1 while l \u0026lt;= r: mid = l + (r - l) // 2 if nums[mid] \u0026lt; target: l = mid + 1 elif nums[mid] \u0026gt; target: r = mid - 1 else: return True return False    Reference  手把手带你刷Leetcode力扣 - 二分查找 Binary Search 手把手带你刷Leetcode力扣 - 力扣705 手把手带你刷Leetcode力扣 - 力扣35 手把手带你刷Leetcode力扣 - 力扣162 手把手带你刷Leetcode力扣 - 力扣74 Collection of Binary Search Templates  ","date":"2022-04-01T22:36:50+08:00","permalink":"https://tonyfpy.github.io/p/algorithm-topic-2-binary-search/","title":"[Algorithm] Topic 2: Binary Search"},{"content":" Authored by Tony Feng\nCreated on March 30th, 2022\nLast Modified on March 30th, 2022\n Understanding Two-pointer Algorithm Intro  The approach optimizes the runtime by utilizing some order (not necessarily sorting) of the data. It is generally applied on lists (arrays) and linked lists. Here, pointers represent either index or an iteration attribute like node’s Next.  Main Steps of the Algorithm  Pointer Initialization Pointer Movement Stop Condition  Categories  Old \u0026amp; New State Pointers Slow \u0026amp; Fast Pointers Left \u0026amp; Right Pointers Pointers from Two Sequences Sliding Window   Old \u0026amp; New State Pointers Template 1 2 3 4 5 6 7  class Solution: def old_new_state(self, arr): # initialize states old, new = default_val1, default_val2 for item in arr: # process current element with old state old, new = new, self.some_func(item, old)   Examples Leetcode 509 Fibonacci Number 1 2 3 4 5 6 7  # Each number is the sum of the two preceding ones, starting from 0 and 1. class Solution: def fibonacci(self, n: int) -\u0026gt; int: a, b = 0, 1 for i in range(n + 1): a, b = b, a + b return a   Leetcode 198 House Robber 1 2 3 4 5 6 7 8  # Determine the maximum amount of money you can steal tonight  # without robbing adjacent houses. class Solution: def rob(self, nums: \u0026#39;List[int]\u0026#39;) -\u0026gt; int: last, now = 0, 0 for i in nums: last, now = now, max(last + i, now) return now    Slow \u0026amp; Fast Pointers Template 1 2 3 4 5 6 7 8 9 10 11 12 13  class Solution: def slow_fast_runner(self, arr): # initialize slow runner slow = arr[0] # fast-runner grows each iteration generally for fast in range(arr): #slow-runner grows with some restrictions if self.slow_condition(slow): slow = slow.next # slow += 1 # process logic before or after pointers movement self.some_func(slow, fast)   Examples Leetcode 141 Linked List Cycle 1 2 3 4 5 6 7 8 9 10 11 12  class Solution: def hasCycle(self, head: Optional[ListNode]) -\u0026gt; bool: if not head or not head.next: return False slow, fast = head, head while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: return True return False   Leetcode 881 Boats to Save People 1 2 3 4 5 6 7 8 9 10 11  class Solution: def numRescueBoats(self, people: List[int], limit: int) -\u0026gt; int: people = sorted(people) i, j, res = 0, len(people)-1, 0 while i \u0026lt;= j: if people[i] + people[j] \u0026lt;= limit: i = i + 1 j = j - 1 res += 1 return res   Leetcode 26 Remove Duplicates from Sorted Array 1 2 3 4 5 6 7 8 9 10 11 12 13  # Given a sorted array nums, remove the duplicates in place such that  # each element appear only once and return the new length. class Solution: def removeDuplicates(self, nums: \u0026#39;List[int]\u0026#39;) -\u0026gt; int: if not nums: return 0 slow = 0 for fast in range(1, len(nums)): # if current element is not duplicate,  # slow runner grows one step and copys the current value if nums[slow] != nums[fast]: slow += 1 nums[slow] = nums[fast] return slow + 1    Left \u0026amp; Right Pointers Template 1 2 3 4 5 6 7 8 9 10 11 12  class Solution: def left_right_boundary(self, arr): left, right = 0, len(arr) - 1 while left \u0026lt; right: # left index moves when satisfy the condition if self.left_condition(left): left += 1 # right index move when satisfy the condition if self.right_condition(right): right -= 1 # process logic before or after pointers movement self.some_func(left, right)   Examples Leetcode 167 Two Sum II - Input Array Is Sorted 1 2 3 4 5 6 7 8 9 10 11 12 13  # Given an array of integers that is already sorted in ascending  # order, find two numbers such that they add up to a specific target number. class Solution: def twoSum(self, numbers: \u0026#39;List[int]\u0026#39;, target: \u0026#39;int\u0026#39;) -\u0026gt; \u0026#39;List[int]\u0026#39;: left, right = 0, len(numbers) - 1 while left \u0026lt; right: if numbers[left] + numbers[right] == target: return [left + 1, right + 1] if numbers[left] + numbers[right] \u0026lt; target: left += 1 else: right -= 1 return [0, 0]    Pointers from Two Sequences Template 1 2 3 4 5 6 7 8 9 10 11 12 13 14  class Solution: def pointers_from_two_seq(self, arr1, arr2): # init pointers p1, p2 = 0, 0 # or seq1[0], seq2[0] while p1 \u0026lt; len(arr1) and p2 \u0026lt; len(arr2): # or other condition # p1 index moves when satisfy the condition if self.p1_condition(p1): p1 += 1 # or p1 = next(seq1) # p2 index move when satisfy the condition if self.p2_condition(p2): p2 += 1 # or p2 = next(seq2) # process logic before or after pointers movement self.some_func(p1, p2)   Examples Leetcode 244 Shortest Word Distance II 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  # Design a class which receives a list of words in the constructor  # and implements a method that takes two words, word1 and word2, and  # returns the shortest distance between these two words in the list. class WordDistance: def __init__(self, words: \u0026#39;List[str]\u0026#39;): self.locations = defaultdict(list) # Prepare a mapping from a word to all it\u0026#39;s locations (indices). for i, w in enumerate(words): self.locations[w].append(i) def shortest(self, word1: str, word2: str) -\u0026gt; int: loc1, loc2 = self.locations[word1], self.locations[word2] l1, l2 = 0, 0 min_diff = float(\u0026#34;inf\u0026#34;) # Until the shorter of the two lists is processed while l1 \u0026lt; len(loc1) and l2 \u0026lt; len(loc2): min_diff = min(min_diff, abs(loc1[l1] - loc2[l2])) if loc1[l1] \u0026lt; loc2[l2]: l1 += 1 else: l2 += 1 return min_diff    Sliding Window  There are two types of window\n  The fixed size window can be used for problem where you want to determine whether given string contain a specific substring.\n  The dynamic one can be used to find the longest or shortest substring of the given string.\n   Template 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  class Solution: def sliding_window(self, arr): start, end = 0, 0 while end \u0026lt; len(arr): # end pointer grows in the outer loop end += 1 # start pointer grows with some restrict while self.start_condition(start): # process logic before pointers movement self.some_func(start, end) # start grows in the inner loop start += 1 # or process logic after pointers movement self.some_func(start, end)   Examples Leetcode 209 Minimum Size Subarray Sum 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  # Given an array of positive integers nums and a positive integer  # target, return the minimal length of a contiguous subarray of  # which the sum is greater than or equal to target. class Solution: def minSubArrayLen(self, target: int, nums: List[int]) -\u0026gt; int: if not nums or len(nums) == 0: return 0 l, r = 0, 0 res = len(nums) + 1 add = 0 while r \u0026lt; len(nums): add += nums[r] r += 1 # Upsizing the window while add \u0026gt;= target: # Downsizing the window iteratively res = min(res, r - l) add -= nums[l] l += 1 return res if res != len(nums) + 1 else 0   Leetcode 1456 Maximum Number of Vowels in a Substring of Given Length 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  # Given a string s and an integer k, return the maximum number of vowel  # letters in any substring of s with length k. class Solution: def maxVowels(self, s: str, k: int) -\u0026gt; int: if not s or len(s) == 0 or len(s) \u0026lt; k: return 0 vl = set([\u0026#39;a\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;i\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;u\u0026#39;]) # Quick for search i, j = 0, 0 res, tmp = 0, 0 while j \u0026lt; len(s): if j - i \u0026lt; k: # Get the number of vowel letters in the first sliding window if s[j] in vl: tmp += 1 res = tmp j += 1 else: # Pop the first item if s[i] in vl: tmp -= 1 i += 1 # Add the next item if s[j] in vl: tmp += 1 res = max(tmp, res) j += 1 return res    Reference  手把手带你刷Leetcode力扣 - 双指针 Two Pointers 手把手带你刷Leetcode力扣 - 力扣141 手把手带你刷Leetcode力扣 - 力扣881 手把手带你刷Leetcode力扣 - 滑动窗口 Sliding Window 手把手带你刷Leetcode力扣 - 力扣209 手把手带你刷Leetcode力扣 - 力扣1456 Two Pointers Approach — Python Code Algorithm Templates: Two Pointers - Part 1 Algorithm Templates: Two Pointers - Part 2 Algorithm Templates: Two Pointers - Part 3 Effective LeetCode: Understanding the Sliding Window Pattern  ","date":"2022-03-30T22:59:15+08:00","permalink":"https://tonyfpy.github.io/p/algorithm-topic-1-two-pointers/","title":"[Algorithm] Topic 1: Two Pointers"}]