[{"content":" Authored by Tony Feng\nCreated on May 1st, 2022\nLast Modified on May 1st, 2022\n Task 1 - Q07. 重建二叉树 Question 输入某二叉树的前序遍历和中序遍历的结果，请构建该二叉树并返回其根节点。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。\nSolution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None class Solution: def buildTree(self, preorder: List[int], inorder: List[int]) -\u0026gt; TreeNode: if not preorder or not inorder: return None # Find the root root = TreeNode(preorder[0]) id = inorder.index(root.val) root.left = self.buildTree(preorder[1:id+1], inorder[0:id]) root.right = self.buildTree(preorder[id+1:], inorder[id+1:]) return root   Explanation  Preorder: root | left | right Inorder: left | root | right Root is the first element in preorder list. Root in inorder list separates the left and right sub-trees. Time Complexity: O(N) Space Complexity: O(N)   Task 2 - Q16. 数值的整数次方 Question 实现 pow(x, n) ，即计算 x 的 n 次幂函数（即，xn）。不得使用库函数，同时不需要考虑大数问题。\nSolution 1 2 3 4 5 6 7 8 9 10  class Solution: def myPow(self, x: float, n: int) -\u0026gt; float: if n == 0: return 1 elif n \u0026lt; 0: return 1 / self.myPow(x, -n) # Make n from negative to positive elif n \u0026amp; 1 == 0: # Even or not return self.myPow(x*x, n//2) # n//2 is to make sure the result is an integer.  else: return x * self.myPow(x, n-1)   Explanation  Time Complexity: O(log(N)) Space Complexity: O(log(N))   Task 3 - Q33. 二叉搜索树的后序遍历序列 Question 输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 true，否则返回 false。假设输入的数组的任意两个数字都互不相同。\n1 2 3 4 5 6 7  输入: [1,6,3,2,5], 输出: False 输入: [1,3,2,6,5], 输出: True 5 / \\ 2 6 / \\ 1 3   Solution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  class Solution: def verifyPostorder(self, postorder: [int]) -\u0026gt; bool: def recur(l, r): if l \u0026gt;= r: return True p = l while postorder[p] \u0026lt; postorder[r]: p += 1 m = p while postorder[p] \u0026gt; postorder[r]: p += 1 return p == r and recur(l, m-1) and recur(m, r-1) return recur(0, len(postorder)-1)   Explanation  The leftest node is always the root. We need to find the serparator who divides the left and right sub-trees. Time Complexity: O(N2), i.e., the shape is like a linked list. Space Complexity: O(N), i.e., the shape is like a linked list.   ","date":"2022-05-01T20:51:18+08:00","permalink":"https://tonyfpy.github.io/p/%E5%89%91%E6%8C%87offer-day-20-divide-and-conquer/","title":"[剑指Offer] Day 20: Divide and Conquer"},{"content":" Authored by Tony Feng\nCreated on April 30th, 2022\nLast Modified on May 1st, 2022\n Intro Pandas is great data processing library for table/database-like data. Excellent for things that come in or you wish to output as CSV/Excel. DataFrames make manipulating your data easy, from selecting or replacing columns and indices to reshaping your data.\nData Preprocessing Create a Dataframe 1 2 3 4 5  data = { \u0026#34;Country\u0026#34;: [\u0026#39;China\u0026#39;, \u0026#39;US\u0026#39;, \u0026#39;India\u0026#39;], \u0026#34;Population\u0026#34;: [14, 3, 14] } df = pd.DataFrame(data)   Read data 1 2 3 4 5 6 7 8 9  import pandas as pd df = pd.read_csv(\u0026#39;data.csv\u0026#39;) df.head() # First 5 rows df.tail() # Last 5 rows df.info() # Overview of the data df.describe() # Statistical details df.columns # header df.dtype # Types of each column df.values # Data matrix   Data indexing 1 2 3 4 5 6 7 8 9 10 11 12 13 14  df_age = df[\u0026#39;Age\u0026#39;] # Get a column age = df_age.values # Get a ndarray  df_birthday = df[[\u0026#39;Year\u0026#39;, \u0026#39;Month\u0026#39;, \u0026#39;Day\u0026#39;]] # Get two columns df.iloc[0] # First piece of data df.iloc[0:5] # First 5 rows df.iloc[0:5, 1:3] # First 5 rows with specified features df = df.set_index(\u0026#39;Name\u0026#39;) # Reset index df.loc[\u0026#39;Tony\u0026#39;] df.loc[\u0026#39;Tony\u0026#39;, \u0026#39;Age\u0026#39;] # Use name to find age df[df[\u0026#39;Age\u0026#39;] \u0026gt;= 18][:5] # Find 5 people whose age is over 18 df.loc[df[\u0026#39;Sex\u0026#39;]==\u0026#39;Female\u0026#39;, \u0026#39;Age\u0026#39;].mean() # Calculate the average age of all females   Series 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  # Create val = [1, 10 ,100] id = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;] s = pd.Series(data=val, index=id) # Indexing s.loc[\u0026#39;b\u0026#39;] # 10 s.iloc[1] # 10 # Assignment s1 = s.copy() s1[\u0026#39;a\u0026#39;] = 0 s1.rename(index={\u0026#39;a\u0026#39;:\u0026#39;alpha\u0026#39;}, inplace=True) s1.index # Index([\u0026#39;alpha\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;], dtype=\u0026#39;object\u0026#39;) # Add s2 = pd.Series(data=[1000, 10000], index=[\u0026#39;e\u0026#39;, \u0026#39;f\u0026#39;]) s3 = s1.append(s2) s3[\u0026#39;d\u0026#39;] = 500 # Add an index with a value # Remove del s3[\u0026#39;alpha\u0026#39;] s3.drop([\u0026#39;b\u0026#39; ,\u0026#39;c\u0026#39;], inplace=True)    Data Analysis Statistics 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  df = pd.DataFrame([[1,2,3],[4,5,6]], index=[\u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;], columns=[\u0026#39;A\u0026#39;,\u0026#39;B\u0026#39;,\u0026#39;C\u0026#39;]) df.sum() # axis=0 by default df.mean() df.median() df.max() df.min() df.describe() # Statistical details: cnt, mean, var, max, min, etc. df.cov() # Covariance df.corr() # Correlation coefficient df[\u0026#39;Sex\u0026#39;].value_counts(ascending=True) # Female 314 Male 577 df[\u0026#39;Age\u0026#39;].value_counts(ascending=True, bins=5) # All age values will be separated in to 5 ranges. ages = [15, 18, 20, 21, 26, 33, 45, 66, 75] bins = [10, 30, 50, 80] # (10, 30], (30, 50], (50, 80] Three intervals names = [\u0026#34;Y\u0026#34;, \u0026#34;M\u0026#34;, \u0026#34;O\u0026#34;] res = pd.cut(ages, bins, labels=names) # [\u0026#39;Y\u0026#39;, \u0026#39;Y\u0026#39;, \u0026#39;Y\u0026#39;, \u0026#39;Y\u0026#39;, \u0026#39;Y\u0026#39;, \u0026#39;M\u0026#39;, \u0026#39;M\u0026#39;, \u0026#39;O\u0026#39;, \u0026#39;O\u0026#39;] # Categories (3, object): [\u0026#39;Y\u0026#39; \u0026lt; \u0026#39;M\u0026#39; \u0026lt; \u0026#39;O\u0026#39;]   Pivot Table 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40  # Pivot df = pd.DataFrame({ \u0026#34;Type\u0026#34;: [\u0026#39;Breakfast\u0026#39;, \u0026#39;Lunch\u0026#39;, \u0026#39;Dinner\u0026#39;, \u0026#39;Breakfast\u0026#39;, \u0026#39;Lunch\u0026#39;, \u0026#39;Dinner\u0026#39;, \u0026#39;Breakfast\u0026#39;, \u0026#39;Lunch\u0026#39;, \u0026#39;Dinner\u0026#39;], \u0026#34;Month\u0026#34;: [1, 1, 1, 2, 2, 2, 3, 3, 3], \u0026#34;Cost\u0026#34;: [50, 60, 100, 30, 70, 90, 40, 40, 40] }) pivot = df.pivot(index=\u0026#34;Month\u0026#34;, columns=\u0026#34;Type\u0026#34;, values=\u0026#34;Cost\u0026#34;) \u0026#39;\u0026#39;\u0026#39; Type Breakfast Dinner Lunch Month 1 50 100 60 2 30 90 70 3 40 40 40 \u0026#39;\u0026#39;\u0026#39; pivot.sum(axis=0) \u0026#39;\u0026#39;\u0026#39; Type Breakfast 120 Dinner 230 Lunch 170 dtype: int64 \u0026#39;\u0026#39;\u0026#39; # Pivot Table df = pd.DataFrame({ \u0026#34;A\u0026#34;: [\u0026#34;foo\u0026#34;, \u0026#34;foo\u0026#34;, \u0026#34;foo\u0026#34;, \u0026#34;foo\u0026#34;, \u0026#34;foo\u0026#34;,\u0026#34;bar\u0026#34;, \u0026#34;bar\u0026#34;, \u0026#34;bar\u0026#34;, \u0026#34;bar\u0026#34;], \u0026#34;B\u0026#34;: [\u0026#34;one\u0026#34;, \u0026#34;one\u0026#34;, \u0026#34;one\u0026#34;, \u0026#34;two\u0026#34;, \u0026#34;two\u0026#34;, \u0026#34;one\u0026#34;, \u0026#34;one\u0026#34;, \u0026#34;two\u0026#34;, \u0026#34;two\u0026#34;], \u0026#34;C\u0026#34;: [\u0026#34;small\u0026#34;, \u0026#34;large\u0026#34;, \u0026#34;large\u0026#34;, \u0026#34;small\u0026#34;, \u0026#34;small\u0026#34;, \u0026#34;large\u0026#34;, \u0026#34;small\u0026#34;, \u0026#34;small\u0026#34;, \u0026#34;large\u0026#34;], \u0026#34;D\u0026#34;: [1, 2, 2, 3, 3, 4, 5, 6, 7], \u0026#34;E\u0026#34;: [2, 4, 5, 5, 6, 6, 8, 9, 9] }) pTable = df.pivot_table(index=[\u0026#39;A\u0026#39;, \u0026#39;B\u0026#39;], columns=[\u0026#39;C\u0026#39;], values=\u0026#39;D\u0026#39;, aggfunc=np.sum, fill_value=-1) \u0026#39;\u0026#39;\u0026#39; C large small A B bar one 4 5 two 7 6 foo one 2 1 two -1 3 \u0026#39;\u0026#39;\u0026#39;   Group 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67  df = pd.DataFrame({ \u0026#39;Courses\u0026#39;:[\u0026#34;Spark\u0026#34;,\u0026#34;PySpark\u0026#34;,\u0026#34;Hadoop\u0026#34;,\u0026#34;Python\u0026#34;,\u0026#34;Pandas\u0026#34;,\u0026#34;Hadoop\u0026#34;,\u0026#34;Spark\u0026#34;,\u0026#34;Python\u0026#34;,\u0026#34;R\u0026#34;], \u0026#39;Fee\u0026#39; :[22000,25000,23000,24000,26000,25000,25000,22000,1500], \u0026#39;Duration\u0026#39;:[30,50,55,40,60,35,30,50,40], \u0026#39;Discount\u0026#39;:[1000,2300,1000,1200,2500,None,1400,1600,0] }) # Group by multiple columns df2 = df.groupby([\u0026#39;Courses\u0026#39;, \u0026#39;Duration\u0026#39;]).sum() \u0026#39;\u0026#39;\u0026#39; Fee Discount Courses Duration Hadoop 35 25000 0.0 55 23000 1000.0 Pandas 60 26000 2500.0 PySpark 50 25000 2300.0 Python 40 24000 1200.0 50 22000 1600.0 R 40 1500 0.0 Spark 30 47000 2400.0 \u0026#39;\u0026#39;\u0026#39; # Choose whether to sort df.groupby(\u0026#39;Courses\u0026#39;,sort=True).sum() # not choose ascending ot descending \u0026#39;\u0026#39;\u0026#39; Fee Duration Discount Courses Hadoop 48000 90 1000.0 Pandas 26000 60 2500.0 PySpark 25000 50 2300.0 Python 46000 90 2800.0 R 1500 40 0.0 Spark 47000 60 2400.0 \u0026#39;\u0026#39;\u0026#39; # Sort group key on descending order groupedDF = df.groupby(\u0026#39;Courses\u0026#39;,sort=False).sum() groupedDF.sort_values(\u0026#39;Courses\u0026#39;, ascending=False) \u0026#39;\u0026#39;\u0026#39; Spark 47000 60 2400.0 R 1500 40 0.0 Python 46000 90 2800.0 PySpark 25000 50 2300.0 Pandas 26000 60 2500.0 Hadoop 48000 90 1000.0 \u0026#39;\u0026#39;\u0026#39; # Drop NA and add an index df3 = df.groupby([\u0026#39;Courses\u0026#39;], dropna=False).sum().reset_index() \u0026#39;\u0026#39;\u0026#39; Courses Fee Duration Discount 0 Hadoop 48000 90 1000.0 1 Pandas 26000 60 2500.0 2 PySpark 25000 50 2300.0 3 Python 46000 90 2800.0 4 R 1500 40 0.0 5 Spark 47000 60 2400.0 \u0026#39;\u0026#39;\u0026#39; # Apply aggregations df.groupby(\u0026#39;Courses\u0026#39;).aggregate({\u0026#39;Duration\u0026#39;:\u0026#39;count\u0026#39;,\u0026#39;Fee\u0026#39;:[\u0026#39;min\u0026#39;,\u0026#39;max\u0026#39;]}) \u0026#39;\u0026#39;\u0026#39; Duration Fee count min max Courses Hadoop 2 23000 25000 Pandas 1 26000 26000 PySpark 1 25000 25000 Python 2 22000 24000 R 1 1500 1500 Spark 2 22000 25000 \u0026#39;\u0026#39;\u0026#39;    Usuful Functions Merge 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  df1 = pd.DataFrame({ \u0026#39;name\u0026#39;: [\u0026#39;Foreign Cinema\u0026#39;, \u0026#39;Liho Liho\u0026#39;, \u0026#39;500 Club\u0026#39;, \u0026#39;The Square\u0026#39;, \u0026#39;S86\u0026#39;], \u0026#39;Type\u0026#39;: [\u0026#39;Restaurant\u0026#39;, \u0026#39;Restaurant\u0026#39;, \u0026#39;bar\u0026#39;, \u0026#39;bar\u0026#39;, \u0026#39;bar\u0026#39;] }) df2 = pd.DataFrame({ \u0026#39;name\u0026#39;: [\u0026#39;Foreign Cinema\u0026#39;, \u0026#39;Liho Liho\u0026#39;, \u0026#39;500 Club\u0026#39;, \u0026#39;The Square\u0026#39;], \u0026#39;AvgBill\u0026#39;: [100, 200, 300, 400], \u0026#39;Rating\u0026#39;: [5, 4.2, 4.3, 4.8] }) pd.merge( df1, df2, on = \u0026#39;name\u0026#39;, how = \u0026#39;outer\u0026#39;, # Otherwise, \u0026#39;S86\u0026#39; will be deleted. indicator = True # _merge ) \u0026#39;\u0026#39;\u0026#39; name Type AvgBill Rating _merge 0 Foreign Cinema Restaurant 100.0 5.0 both 1 Liho Liho Restaurant 200.0 4.2 both 2 500 Club bar 300.0 4.3 both 3 The Square bar 400.0 4.8 both 4 S86 bar NaN NaN left_only \u0026#39;\u0026#39;\u0026#39;   Sort 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  df = pd.DataFrame({ \u0026#39;group\u0026#39;: [\u0026#39;a\u0026#39;]*3 + [\u0026#39;b\u0026#39;]*3 + [\u0026#39;c\u0026#39;]*3, \u0026#39;data\u0026#39;: [4,3,2,1,12,3,4,5,7] }) df.sort_values(by=[\u0026#39;data\u0026#39;, \u0026#39;group\u0026#39;], ascending=[False, True], inplace=True) \u0026#39;\u0026#39;\u0026#39; group data 4 b 12 8 c 7 7 c 5 0 a 4 6 c 4 1 a 3 5 b 3 2 a 2 3 b 1 \u0026#39;\u0026#39;\u0026#39;   Data Cleaning 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  # Remove duplicates  df.drop_duplicates() # key-value pairs df.drop_duplicates(subset=\u0026#39;some_feature\u0026#39;) # no duplicates in \u0026#39;some_feature\u0026#39; # NaN import numpy as np df = pd.DataFrame([range(3), [0, np.nan, 0], [0, 0, np.nan], range(3)]) df.isnull() df.isnull().any(axis=1) # Check whether rows have NaN df.fillna(-1) # Fill NaN \u0026#39;\u0026#39;\u0026#39; 0 1 2 | 0 1 2 | 0 False | 0 1 2 0 0 1.0 2.0 | 0 False False False | 1 True | 0 0 1.0 2.0 1 0 NaN 0.0 | 1 False True False | 2 True | 1 0 -1.0 0.0 2 0 0.0 NaN | 2 False False True | 3 False | 2 0 0.0 -1.0 3 0 1.0 2.0 | 3 False False False | dtype: bool | 3 0 1.0 2.0 \u0026#39;\u0026#39;\u0026#39; # apply df[\u0026#39;new_col\u0026#39;] = df.apply(some_func, axis=\u0026#39;columns\u0026#39;) # some_func could be defined somewhere or inline using lambda.   Timestamp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  # Create a timestamp ts = pd.Timestamp(\u0026#39;2022-05-01\u0026#39;) # Timestamp(\u0026#39;2022-05-01 00:00:00\u0026#39;) ts.month # 5 ts.day # 1 ts + pd.Timedelta(\u0026#39;5 days\u0026#39;) # Timestamp(\u0026#39;2022-05-06 00:00:00\u0026#39;) pd.Series(pd.date_range(start=\u0026#39;2022-05-01\u0026#39;, periods=5, freq=\u0026#39;12H\u0026#39;)) \u0026#39;\u0026#39;\u0026#39; 0 2022-05-01 00:00:00 1 2022-05-01 12:00:00 2 2022-05-02 00:00:00 3 2022-05-02 12:00:00 4 2022-05-03 00:00:00 dtype: datetime64[ns] \u0026#39;\u0026#39;\u0026#39; # Reas csv with timestamps df = pd.read_csv(\u0026#39;./data.csv\u0026#39;, index_col=0, parse_dates=True) df[\u0026#39;2022\u0026#39;] df[\u0026#39;2022-01\u0026#39;:\u0026#39;2022-02\u0026#39;] df.resample(\u0026#39;2D\u0026#39;).mean().head() # Two days as a period df.resample(\u0026#39;M\u0026#39;).max().head() # One month as a period    Big Data Techniques Datatype Conversion 1 2 3 4 5  # Assume we want to decrease the data memory space df_float = df.select_dtypes(include=[\u0026#39;float64\u0026#39;]) converted_float = df_float.apply(pd.to_numeric, downcast=\u0026#39;float\u0026#39;) print(mem_usage(df_float)) print(mem_usage(converted_float))   Property Conversion 1 2 3 4 5 6 7 8  # Assuming data contains weekdays, we can set same weekday to share the same memory space. # 70 weekdays may result in 70 memory space. we convert the \u0026#39;object\u0026#39; into \u0026#39;category\u0026#39; for data to share memory space. df_obj = df.select_dtypes(include=[\u0026#39;object\u0026#39;]) dow = df_obj.weekday # Assume there is a column called \u0026#39;weekday\u0026#39; dow_cat = dow.astype(\u0026#39;category\u0026#39;) dow_cat.cat.codes # We can see there are only 7 encoding ways print(mem_usage(df_float)) print(mem_usage(converted_float))    Reference  Pandas Documentation Pandas Tutorial   ","date":"2022-04-30T22:20:26+08:00","permalink":"https://tonyfpy.github.io/p/data-analysis-topic-2-pandas/","title":"[Data Analysis] Topic 2: Pandas"},{"content":" Authored by Tony Feng\nCreated on April 30th, 2022\nLast Modified on April 30th, 2022\n Task 1 - Q64. 求1+2+…+n Question 求 1+2+\u0026hellip;+n ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。\nSolution 1 1 2 3  class Solution: # built-in function def sumNums(self, n: int) -\u0026gt; int: return sum(range(1, n+1))   Solution 2 1 2 3  class Solution: # logical operation def sumNums(self, n: int) -\u0026gt; int: return n and (n + self.sumNums(n-1))   Explanation  Solution 1 \u0026amp; 2  Time Complexity: O(N) Space Complexity: O(N)     Task 2 - Q68,I. 二叉搜索树的最近公共祖先 Question 给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。题目中所有节点的值都是唯一的，p、q 为不同节点且均存在于给定的二叉搜索树中。\n最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”\nSolution 1 1 2 3 4 5 6 7 8 9 10  class Solution: # Iteration def lowestCommonAncestor(self, root: \u0026#39;TreeNode\u0026#39;, p: \u0026#39;TreeNode\u0026#39;, q: \u0026#39;TreeNode\u0026#39;) -\u0026gt; \u0026#39;TreeNode\u0026#39;: while root: if root.val \u0026gt; p.val and root.val \u0026gt; q.val: root = root.left elif root.val \u0026lt; p.val and root.val \u0026lt; q.val: root = root.right else: break return root   Solution 2 1 2 3 4 5 6 7 8  class Solution: # Recursion def lowestCommonAncestor(self, root: \u0026#39;TreeNode\u0026#39;, p: \u0026#39;TreeNode\u0026#39;, q: \u0026#39;TreeNode\u0026#39;) -\u0026gt; \u0026#39;TreeNode\u0026#39;: if root.val \u0026gt; p.val and root.val \u0026gt; q.val: return self.lowestCommonAncestor(root.left, p, q) elif root.val \u0026lt; p.val and root.val \u0026lt; q.val: return self.lowestCommonAncestor(root.right, p, q) else: return root   Explanation  Since it is a binary search tree, we could use its properties to solve the problem. And no duplicate nodes in the tree.  The nodes in the left sub-tree are smaller than the root. The nodes in the right sub-tree are larger than the root.   Solution 1  Time Complexity: O(N) Space Complexity: O(1)   Solution 2  Time Complexity: O(N) Space Complexity: O(N)     Task 3 - Q68,II. 二叉树的最近公共祖先 Question 给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。\nSolution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  class Solution: def lowestCommonAncestor(self, root: TreeNode, p: TreeNode, q: TreeNode) -\u0026gt; TreeNode: if not root or root == p or root == q: return root r = self.lowestCommonAncestor(root.right, p, q) l = self.lowestCommonAncestor(root.left, p, q) if not r and not l: return None elif r and not l: return r elif not r and l: return l else: return root   Explanation  If a node is the p and q\u0026rsquo;s lowest common ancestor:  p, q exist in different sides of the node respectively. p is the node and q is in its sub-tree. q is the node and p is in its sub-tree.   Solution 1 \u0026amp; 2  Time Complexity: O(N) Space Complexity: O(N)     ","date":"2022-04-30T16:26:20+08:00","permalink":"https://tonyfpy.github.io/p/%E5%89%91%E6%8C%87offer-day-19-search-and-backtracking/","title":"[剑指Offer] Day 19: Search and Backtracking"},{"content":" Authored by Tony Feng\nCreated on April 30th, 2022\nLast Modified on April 30th, 2022\n Intro NumPy is the core library for scientific computing in Python. It provides a high-performance multi-dimensional array object, along with a large collection of high-level mathematical tools for working with these arrays.\nBasics of Arrays Array Initilization 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  import numpy as np # Create a rank 1 array a = np.array([1, 2, 3]) # Create a rank 2 array b = np.array([[1,2,3],[4,5,6]]) # Create an array of all zeros c = np.zeros((2,2)) # array([[ 0. 0.][ 0. 0.]])  d = np.zeros_like(b) # array([[0, 0, 0], [0, 0, 0]])  # Create an array of all ones e = np.ones((1,2)) # array([[ 1. 1.]]) # Create a constant array f = np.full((2,2), 7) # array([[ 7. 7.][ 7. 7.]])  # Create a 2x2 identity matrix g = np.eye(2) # array([[ 1. 0.][ 0. 1.]]) h = np.identity(2) # array([[ 1. 0.][ 0. 1.]]) # Create an array filled with random values i = np.random.random((2,2)) # array([[ 0.91940167 0.08143941][ 0.68744134 0.87236687]]) # Create an empty array and fill it with 1 j = np.empty((3,2)) j.fill(1) # array([[1., 1.], [1., 1.], [1., 1.]])   Array Properties 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  # Get the shape of the array a = np.array([1, 2, 3]) b = np.array([[1,2,3],[4,5,6]]) print(a.shape) # (3,) print(b.shape) # (2, 3) # Get the number of elements of the array print(a.size) # 3 print(b.size) # 6 # Get the dimension of the data print(a.ndim) # 1 print(b.ndim) # 2 # Get the type of the array print(type(a)) # \u0026lt;class \u0026#39;numpy.ndarray\u0026#39;\u0026gt; # Get the type of the elements print(a.dtype) # dtype(\u0026#39;int64\u0026#39;) # The type of the elements in ndarray should be the same.  # Otherwise, int -\u0026gt; float -\u0026gt; string a_list = [1, 2, \u0026#39;3\u0026#39;] a_arr = np.array(a_list) # array([\u0026#39;1\u0026#39;, \u0026#39;2\u0026#39;, \u0026#39;3\u0026#39;]) b_list = [1, 2, 3.0] b_arr = np.array(b_list) # array([1., 2., 3.])    Array Indexing and Slicing Integer Array Indexing 1 2 3 4 5 6 7 8 9 10 11 12 13  a = np.array([[1, 2], [3, 4], [5, 6]]) # Two ways are equivalent below. The shape is (3,). print(a[[0, 1, 2], [0, 1, 0]]) # [1 4 5] print(np.array([a[0, 0], a[1, 1], a[2, 0]])) # [1 4 5] # Create an array of indices # Select one element from each row of a using the indices in b b = np.array([0, 1, 1]) print(a[np.arange(3), b]) # [ 1 4 6] # Mutate one element from each row of a using the indices in b a[np.arange(3), b] += 10 # array([[11 2] [ 3 14] [ 5 16]])   Boolean Array Indexing 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  a = np.array([[1,2], [3, 4], [5, 6]]) # We use boolean array indexing to construct a rank 1 array consisting  # of the elements of a corresponding to the True values of bool_idx. bool_idx = (a \u0026gt; 2) # array([[False False] [ True True] [ True True]]) a[bool_idx] # array([3 4 5 6]) # The above operation is equivalent to these. a[a \u0026gt; 2] # array([3 4 5 6]) a[np.where(a \u0026gt; 2)] # array([3 4 5 6]) x = np.array([1, 0, 3, 4]) y = np.array([1, 2, 3, 5]) x == y # array([ True, False, True, False]) np.logical_and(x, y) # array([ True, False, True, True]) np.logical_or(x, y) # array([ True, True, True, True])   Slicing 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  a = np.array([[1,2,3,4], [5,6,7,8], [9,10,11,12]]) b = a[:2, 1:3] # array([[2, 3], [6, 7]]) c = a[:2, 1:3].copy() # array([[2, 3], [6, 7]]) # A slice of an array is a view into the same data,  # so modifying it will modify the original array. print(a[0, 1]) # 2 b[0, 0] = 77 # b[0, 0] is the same piece of data as a[0, 1] print(a[0, 1]) # 77 c[0, 0] = 88 # c is a new array in a different memory space. print(a[0, 1]) # 77 # Two ways of accessing the data in the middle row of the array. # Mixing integer indexing with slices yields an array of lower rank, # while using only slices yields an array of the same rank as the original array: row_r1 = a[1, :] # Rank 1 view of the second row of a row_r2 = a[1:2, :] # Rank 2 view of the second row of a print(row_r1, row_r1.shape) # [5 6 7 8] (4,) print(row_r2, row_r2.shape) # [[5 6 7 8]] (1, 4) # We can make the same distinction when accessing columns of an array: col_r1 = a[:, 1] col_r2 = a[:, 1:2] print(col_r1, col_r1.shape) # [ 2 6 10] (3,) print(col_r2, col_r2.shape) # [[ 2] [ 6] [10]] (3, 1)    Data Calculation Basic Operations 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44  a = np.array([[1, 2, 3], [4, 5, 6]]) # Summation s1 = np.sum(a) # 27 s2 = np.sum(a, axis=0) # array([5, 7, 9]), shape is (3,) s3 = np.sum(a, axis=1) # array([ 6, 15]), shape is (2,) # Product s1 = np.prod(a) # 720 s2 = np.prod(a, axis=0) # array([4, 10, 18]), shape is (3,) s3 = np.prod(a, axis=1) # array([ 6, 120]), shape is (2,) # Minimum s1 = a.min() # 0 s2 = a.min(axis=0) # array([0, 0, 0]), shape is (3,) s3 = a.min(axis=1) # array([0, 0]), shape is (2,) # The index of the minimum s1 = a.argmin() # 1 s2 = a.argmin(axis=0) # array([1, 2, 3]), shape is (3,) s3 = a.argmin(axis=1) # array([1, 4]), shape is (2,) # Mean s1 = a.mean() # 3.5 s2 = a.mean(axis=0) # array([2.5, 3.5, 4.5]), shape is (3,) s3 = a.mean(axis=1) # array([2., 5.]), shape is (2,) # Standard Deviation s1 = a.std() s2 = a.std(axis=0) s3 = a.std(axis=1) # Variance s1 = a.var() s2 = a.var(axis=0) s3 = a.var(axis=1) # Clip a.clip(2, 4) # array([[2, 2, 3], [4, 4, 4]]),  # i.e., num -\u0026gt; 2 if num \u0026lt; 2; num -\u0026gt; 4 if num \u0026gt; 4 # Round a = np.array([1.1, 2.5, 3.8]) a.round(decimals=0) # array([1., 2., 4.])   Matrix Operation 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47  x = np.array([[1,2],[3,4]], dtype=np.float64) y = np.array([[5,6],[7,8]], dtype=np.float64) # Elementwise sum; both produce the array x + y np.add(x, y) # Elementwise difference; both produce the array x - y np.subtract(x, y) # Elementwise product; both produce the array x * y np.multiply(x, y) # Elementwise division; both produce the array x / y np.divide(x, y) # Elementwise square root; produces the array np.sqrt(x) v = np.array([9,10]) w = np.array([11, 12]) # Inner product of vectors; both produce 219 v.dot(w)) np.dot(v, w) # Matrix - Vector product; both produce the rank 1 array [29 67] x.dot(v) np.dot(x, v) # Matrix - Matrix product; both produce the rank 2 array x.dot(y) np.dot(x, y) # Transposing x = np.array([[1,2], [3,4]]) x # array([[1 2][3 4]]) x.T # array([[1 3][2 4]]) x.transpose() # array([[1 3][2 4]]) v = np.array([1,2,3]) # Note that taking the transpose of a rank 1 array does nothing v # array([1 2 3]) v.T # array([1 2 3])    Useful Modules Sorting 1 2 3 4 5 6 7  a = np.array([[1, 5, 3], [4, 2, 6]]) # Sort np.sort(a, axis=0) # array([[1 2 3] [4 5 6]]), axis = 0 by default  np.sort(a, axis=1) # array([[1 3 5] [2 4 6]]) # Sort and get index np.argsort(a) # array([[0 2 1] [1 0 2]])   Reshaping 1 2 3 4 5 6 7 8 9 10  a = np.arange(6) # array([0, 1, 2, 3, 4, 5]) # Change the shape a.shape = 2,3 # array([[0, 1, 2], [3, 4, 5]]) # Dimensionality Manipulation a = np.arange(10) a = a[np.newaxis,:] # shape is (1, 10) a = a.squeeze() # shape is (10, )  a = a[:, np.newaxis] # shape is (10, 1)   Concatenation 1 2 3 4 5 6 7 8 9 10  a = np.array([[1, 2, 3], [4, 5, 6]]) b = np.array([[7, 8, 9], [10, 11, 12]]) c = np.concatenate((a, b), axis=0) # array([[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12]]) # np.vstack((a, b)) d = np.concatenate((a, b), axis=1) # array([[1, 2, 3, 7, 8, 9], [4, 5, 6, 10, 11, 12]]) # np.hstack((a, b)) # Flatten c.flatten() # array([ 1, 2, 3, 7, 8, 9, 4, 5, 6, 10, 11, 12]), i.e. shape is (12,) d.flatten() # array([ 1, 2, 3, 7, 8, 9, 4, 5, 6, 10, 11, 12]), i.e. shape is (12,)   Randomization 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  # Create a random matrix a = np.random.rand(3,4) # Create a matrix whose range is specified b = np.random.randint(10, size=(3,2)) # Get an random number c = np.random.rand() # Create an 10-elements array in Gaussian distribution, whose mean is 1 and var is 0.1 np.set_printoptions(precision=2) # Global setup d = np.random.normal(1, 0.1, 10) # Shuffle np.random.shuffle(a) # Specify a seed so that the random results keep same. for i in range(0, 5): init = np.array([1, 2, 3, 4, 5, 6]) np.random.seed(100) for j in range(0, 3): np.random.shuffle(init) print(init)   File Operation 1 2 3 4 5 6 7  \u0026#39;\u0026#39;\u0026#39; If the data produced in execution is massive, it could be stored in .npy to avoid repeated use. ndarray is much efficient than list in computation. \u0026#39;\u0026#39;\u0026#39; a = np.array([[1, 2, 3], [4, 5, 6]]) np.save(\u0026#39;data.npy\u0026#39;, a) np.load(\u0026#39;data.npy\u0026#39;) # array([[1, 2, 3], [4, 5, 6]])    Reference  NumPy Official Website Numpy Tutorial (with Jupyter and Colab)   ","date":"2022-04-30T10:30:44+08:00","permalink":"https://tonyfpy.github.io/p/data-analysis-topic-1-numpy/","title":"[Data Analysis] Topic 1: NumPy"},{"content":" Authored by Tony Feng\nCreated on April 29th, 2022\nLast Modified on April 29th, 2022\n Task 1 - Q55,I. 二叉树的深度 Question 输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。\nSolution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None class Solution: def maxDepth(self, root: TreeNode) -\u0026gt; int: if not root: return 0 depthL = self.maxDepth(root.left) depthR = self.maxDepth(root.right) return 1 + max(depthL, depthR)   Explanation  Time Complexity: O(N) Space Complexity: O(N)   Task 2 - Q55,II. 平衡二叉树 Question Solution 1 1 2 3 4 5 6 7 8 9 10 11 12 13 14  class Solution: def isBalanced(self, root: TreeNode) -\u0026gt; bool: if not root: return True elif abs(self.getDepth(root.left) - self.getDepth(root.right)) \u0026lt;= 1: return self.isBalanced(root.left) and self.isBalanced(root.right) else: return False def getDepth(self, node): # A self-defined function to get the depth if not node: return 0 else: return 1 + max(self.getDepth(node.left), self.getDepth(node.right))   Solution 2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  class Solution: def isBalanced(self, root: TreeNode) -\u0026gt; bool: def recur(root): if not root: return 0 left = recur(root.left) if left == -1: return -1 # -1 means the tree is imbalanced right = recur(root.right) if right == -1: return -1 return max(left, right) + 1 if abs(left - right) \u0026lt;= 1 else -1 return recur(root) != -1   Explanation  Solution 1  Time Complexity: O(N * log(N))  I believe the worst case is when the tree is balanced, so the depth of the tree is log(N) If the tree is like a linked list, the algorihtm will stop once the height difference exceeds 1 and will not go through the rest nodes of the tree. getDepth: O(log(N)) isBalanced: O(N)   Space Complexity: O(N)   Solution 2  Time Complexity: O(N) Space Complexity: O(N)     ","date":"2022-04-29T16:22:29+08:00","permalink":"https://tonyfpy.github.io/p/%E5%89%91%E6%8C%87offer-day-18-search-and-backtracking/","title":"[剑指Offer] Day 18: Search and Backtracking"},{"content":" Authored by Tony Feng\nCreated on April 28th, 2022\nLast Modified on April 28th, 2022\n Task 1 - Q40. 最小的k个数 Question 输入整数数组 arr ，找出其中最小的 k 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。\nSolution 1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  class Solution: def getLeastNumbers(self, arr: List[int], k: int) -\u0026gt; List[int]: def quickSort(arr, l, r): if l \u0026gt;= r: # len(subarray) == 1 return i, j = l, r while i \u0026lt; j: while i \u0026lt; j and arr[j] \u0026gt;= arr[l]: j -= 1 while i \u0026lt; j and arr[i] \u0026lt;= arr[l]: i += 1 arr[i], arr[j] = arr[j], arr[i] arr[l], arr[i] = arr[i], arr[l] # arr[l] is the base number and needs to separate two sub-arrays quickSort(arr, l, i - 1) quickSort(arr, i + 1, r) quickSort(arr, 0, len(arr)-1) return arr[:k]   Solution 2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  class Solution: def getLeastNumbers(self, arr: List[int], k: int) -\u0026gt; List[int]: if k \u0026gt;= len(arr): return arr def quickSort(l, r): i, j = l, r while i \u0026lt; j: while i \u0026lt; j and arr[j] \u0026gt;= arr[l]: j -= 1 while i \u0026lt; j and arr[i] \u0026lt;= arr[l]: i += 1 arr[i], arr[j] = arr[j], arr[i] arr[l], arr[i] = arr[i], arr[l] if k \u0026lt; i: return quickSort(l, i - 1) elif k \u0026gt; i: return quickSort(i + 1, r) else: return arr[:k] return quickSort(0, len(arr) - 1)   Explanation  Solution 1  Time Complexity: O(N * log(N)), i.e., quick sort Space Complexity: O(N), i.e., the worst case is the input array is in descending order.   Solution 2  Time Complexity: O(N), i.e., Every time only one side will be processed, N + N/2 + N/4 + N/8 + \u0026hellip; Space Complexity: O(log(N)), i.e., Average recursion depth is log(N).     Task 2 - Q41. 数据流中的中位数 Question 如何得到一个数据流中的中位数？设计一个支持以下两种操作的数据结构：\n void addNum(int num): 从数据流中添加一个整数到数据结构中。 double findMedian(): 返回目前所有元素的中位数。  Solution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  import heapq class MedianFinder: def __init__(self): self.large = [] # A half of larger elements and the top is the smallest in the heap self.small = [] # A half of smaller elements and the top is the bigest in the heap heapq.heapify(self.large) heapq.heapify(self.small) def addNum(self, num: int) -\u0026gt; None: if len(self.large) == len(self.small): # Even number of elements heapq.heappush(self.small, -num) n = -heapq.heappop(self.small) heapq.heappush(self.large, n) else: # Odd number of elements heapq.heappush(self.large, num) n = heapq.heappop(self.large) heapq.heappush(self.small, -n) def findMedian(self) -\u0026gt; float: if len(self.large) == len(self.small): return (self.large[0] - self.small[0])/2 # Find the top elements of two heaps else: return self.large[0]   Explanation  heapq pops only smallest number, so number should be inversed before stored into self.small. Time Complexity  findMedian: O(1) addNum: O(log(N))   Space Complexity: O(N)   ","date":"2022-04-28T20:45:44+08:00","permalink":"https://tonyfpy.github.io/p/%E5%89%91%E6%8C%87offer-day-17-sorting/","title":"[剑指Offer] Day 17: Sorting"},{"content":" Authored by Tony Feng\nCreated on April 27th, 2022\nLast Modified on April 27th, 2022\n Task 1 - Q61. 扑克牌中的顺子 Question 从若干副扑克牌中随机抽 5 张牌，判断是不是一个顺子，即这5张牌是不是连续的。2～10为数字本身，A为1，J为11，Q为12，K为13，而大、小王为 0 ，但可以看成任意数字。A 不能视为 14。\ne.g. 输入: [0,0,1,2,5]; 输出: True\nSolution 1 1 2 3 4 5 6 7 8 9 10 11 12 13 14  class Solution: def isStraight(self, nums: List[int]) -\u0026gt; bool: repeat = set() nMax, nMin = 0, 14 # The range of the Poker cards for num in nums: if num in repeat: return False # If repeated elements exist, return False elif num == 0: continue else: nMax = max(num, nMax) nMin = max(num. nMin) repeat.add(num) return nMax - nMin \u0026lt; 5   Solution 2 1 2 3 4 5 6 7 8 9 10 11  class Solution: def isStraight(self, nums: List[int]) -\u0026gt; bool: joker = 0 nums.sort() for i in range(0, 4): if nums[i] == 0: joker += 1 elif nums[i] == nums[i+1]: return False return nums[4] - nums[joker] \u0026lt; 5   Explanation  Solution 1  Time Complexity: O(N) or O(1), i.e., N = 5 accroding to the questions Space Complexity: O(N) or O(1), i.e., the length of the set is 5   Solution 2  Time Complexity: O(N * log(N)) or O(1) Space Complexity: O(1), i.e., only variable joker is used     Task 2 - Q45. 把数组排成最小的数 Question 输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。\nSolution 1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  class Solution: # Quick Sort def minNumber(self, nums: List[int]) -\u0026gt; str: def quickSort(l , r): if l \u0026gt;= r: return i, j = l, r while i \u0026lt; j: while strs[j] + strs[l] \u0026gt;= strs[l] + strs[j] and i \u0026lt; j: j -= 1 while strs[i] + strs[l] \u0026lt;= strs[l] + strs[i] and i \u0026lt; j: i += 1 strs[i], strs[j] = strs[j], strs[i] strs[i], strs[l] = strs[l], strs[i] quickSort(l, i - 1) quickSort(i + 1, r) strs = list(map(str, nums)) quickSort(0, len(strs) - 1) return \u0026#39;\u0026#39;.join(strs)   Solution 2 1 2 3 4 5 6 7 8 9 10 11 12 13  class Solution: # Built-in sort func def minNumber(self, nums: List[int]) -\u0026gt; str: def sortRule(x, y): if x + y \u0026gt; y + x: return 1 elif x + y \u0026lt; y + x: return -1 else: return 0 strs = list(map(str, nums)) strs.sort(key = functools.cmp_to_key(sortRule)) return \u0026#39;\u0026#39;.join(strs)   Explanation  The problem requires us to sort based on new rules  if int(str(x) + str(y)) \u0026gt; int(str(y) + str(x)), str(x) should be behind str(y). else str(y) should be behind str(x)      Solution 1 \u0026amp; 2  Time Complexity: O(N * log(N)) Space Complexity: O(N)     ","date":"2022-04-27T14:09:46+08:00","permalink":"https://tonyfpy.github.io/p/%E5%89%91%E6%8C%87offer-day-16-sorting/","title":"[剑指Offer] Day 16: Sorting"},{"content":" Authored by Tony Feng\nCreated on April 26th, 2022\nLast Modified on April 28th, 2022\n Intro Recently, I am preparing for the application of 2023 summer intership in US. Since it might be my last industrial internship, this experience would influence my career path to a large extent and pave the way to my future career development. It\u0026rsquo;s time to conisder it comprehensively.\nI would like to consider myself as a freshman in job hunting, because it\u0026rsquo;s my first time to seek employment in another country. In order to find a desirable job placement, I\u0026rsquo;ve gone through many related materials online. In this post, I\u0026rsquo;m gonna talk about Software Devlopment(SD) and Data Science(DS), two popular job directions most CS graduates will choose.\nSD V.S. DS Number of Job Opportunities In general, companies offers more job positions for SD than DS evidently. The ratio is about 10 : 1 in average. SD is more friendly to new graduates than DS in that companies provides more SD placements for them. DS requires the candidates to earn a high education degree or have past working experience.\nJob Categories SD:\n Software Development Engineer Application Developer Full-stack Web Developer Frontend Developer Backend Developer \u0026hellip;  DS:\n Data Scientist Applied Scientist Statistician Business Intelligence Engineer Data/Product/Business Analyst \u0026hellip;  Cross Domain:\n Machine Learning Engineer Deep Learning Engineer Data Engineer \u0026hellip;  Salary The salary may vary depending on your experience, skills, training, certifications and your employer. In general, SD-related professionals are paid higher than DS-related professionals. Reasearch-oriented DS jobs have higher salaries than other kinds of DS jobs, because they are usually demanding and only open for PhDs.\nDegree Requirements SD: Bachlor\u0026rsquo;s degree or higher  DS: Master\u0026rsquo;s degree or higher. Many positions even require a Doctoral degree. \nHard Skills SD:\n Algorithm and Data Structure Programming Paradigms System Design Testing  DS:\n Statistics and Machien Learning Data Manipulation and Modeling Data Visualization Experiemnts Design and Analysis Business Case  Soft Skills Common soft skills are indispensable for SD and DS in your long-term career development.\nBesides, DS requires the candidates to have strong communications skills, data-driven decision making, product sense, etc.\n Job Descriptions  Job responsibilities vary based on employers\u0026rsquo; requirements and should be learned case by case.\n SD  Full-Stack Engineer  Front-End + Back-End UI + Server + Database Configuration   Mobile App Developer  Android / IOS Memory + Computational Power   Graphics Engineer  2D and 3D Digital Platforms for Gaming and Video Production Math + CS Unity, OpenGL   Embedded Systems Engineer  Control of machines   Software Development Engineer in Test(SDET)  Dev + Automated Testing   DevOps Engineer  Dev + Operations + Deployment Network or Sys Admin Source Control / Infrastructure Automation / Cloud    DS  Data Analysts  Datasets -\u0026gt; Analysis -\u0026gt; Visulization(Reports / Resentations / \u0026hellip;) Experiment (A/B testing) + Statistic + SQL / R / Python Product Interpretation + Actionable Insights + Communication   Data Scientist  Data Manipulation + Statistical Modeling + Machine Learning Product Improvement   Applied Scientist / Research Scientist  Independent Research + Literature Review Model Design + Implementation + Optimization Long-term Research   Quant Researcher  Finance + Statistics + Coding Time Series    Cross Domain  Data Engineer  Data Pipeline Data Infrastructure   Machine Learning Engineer  Mathematics + Statistics + Probability Data Modeling and Evaluation ML System Design     Reference  SDE and DS 的求职难度和就业现状 一个典型北美DS master的求职全过程回顾 疫情下我是如何拿到FB DS offer 的？ An introduction to data science careers Data Science vs Software Engineering 数据岗位大合集｜DS、DA、BA和DE的区别及求职面试重点 你为什么不该选择DS - 可能是2022年最详细的劝退贴 Data Science相关岗位全面解析(DS vs DA vs MLE vs DE) DS找工回顾及资料总结 A Complete Guide To Data Science Career Path – By Great Learning \u0026amp; AIM Software Engineer Career Path Career Paths For Software Developers and Programmers   ","date":"2022-04-26T22:57:49+08:00","permalink":"https://tonyfpy.github.io/p/career-talk-topic-1-sde-or-ds-how-can-i-choose/","title":"[Career Talk] Topic 1: SDE or DS, How Can I Choose?"},{"content":" Authored by Tony Feng\nCreated on April 26th, 2022\nLast Modified on April 26th, 2022\n Task 1 - Q54. 二叉搜索树的第k大节点 Question 给定一棵二叉搜索树，请找出其中第 k 大的节点的值。 e.g. 输入: [5,3,6,2,4,null,null,1], k = 3; 输出: 4 \n1 2 3 4 5 6 7  5 / \\ 3 6 / \\ 2 4 / 1   Solution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None class Solution: def kthLargest(self, root: TreeNode, k: int) -\u0026gt; int: nums = [] def dfs(node): if len(nums) \u0026gt;= k or not node: return dfs(node.right) nums.append(node.val) dfs(node.left) dfs(root) return nums[k-1]   Explanation  We can adopt the properties of binary tree by traversing the tree from the rightest node, which is a reversed version of inorder traverse. Time Complexity: O(N) Space Complexity: O(N)   Task 2 - Q36. 二叉搜索树与双向链表 Question 输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。链表中的每个节点都有一个前驱和后继指针。对于双向循环链表，第一个节点的前驱是最后一个节点，最后一个节点的后继是第一个节点。head 表示指向链表中有最小元素的节点。\n Solution 1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  class Solution: # Use a tmp list def treeToDoublyList(self, root: TreeNode) -\u0026gt; TreeNode: if not root: return None s = [] def dfs(node: TreeNode): # Inorder traverse if node: dfs(node.left) s.append(node) dfs(node.right) # All nodes are stored in a list temporarily dfs(root) # Build doubly list n = len(s) for i in range(1, n - 1): s[i].left = s[i - 1] s[i].right = s[i + 1] # Handle the first and last elements head = s[0] head.left = s[-1] head.right = s[1] if n \u0026gt; 1 else head if n \u0026gt; 1: head.left.left = s[-2] head.left.right = head return head   Solution 2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  class Solution: # DFS def treeToDoublyList(self, root: TreeNode) -\u0026gt; TreeNode: if not root: return None def dfs(cur: TreeNode): # Inorder traverse if cur: dfs(cur.left) if self.pre: self.pre.right, cur.left = cur, self.pre else: self.head = cur # head points to the leftest node self.pre = cur dfs(cur.right) self.pre = None # global var dfs(root) self.head.left, self.pre.right = self.pre, self.head return self.head   Explanation  Solution 1 \u0026amp; 2:  Time Complexity: O(N) Space Complexity: O(N)     Task 3 - Q34. 二叉树中和为某一值的路径 Question 给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径。\nSolution 1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class Solution: # DFS def pathSum(self, root: TreeNode, target: int) -\u0026gt; List[List[int]]: if not root: return [] res = [] def dfs(node, curSum, tmp): curSum += node.val tmp.append(node.val) if not node.left and not node.right: if curSum == target: res.append(tmp[:]) return if node.left: dfs(node.left, curSum, tmp) tmp.pop() if node.right: dfs(node.right, curSum, tmp) tmp.pop() dfs(root, 0, []) return res   Solution 2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  class Solution: # DFS def pathSum(self, root: TreeNode, sum: int) -\u0026gt; List[List[int]]: res, path = [], [] def dfs(root, cnt): if not root: return path.append(root.val) cnt -= root.val if cnt == 0 and not root.left and not root.right: res.append(path[:]) dfs(root.left, cnt) dfs(root.right, cnt) path.pop() dfs(root, sum) return res   Explanation  Solution 1 is my solution and Solution 2 is from others. Both of them adopt DFS, but they are slightly different. Time Complexity: O(N) Space Complexity: O(N)   ","date":"2022-04-26T17:28:50+08:00","permalink":"https://tonyfpy.github.io/p/%E5%89%91%E6%8C%87offer-day-15-searching-and-backtracking/","title":"[剑指Offer] Day 15: Searching and Backtracking"},{"content":" Authored by Tony Feng\nCreated on April 25th, 2022\nLast Modified on April 25th, 2022\n Task 1 - Q13. 机器人的运动范围 Question 地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？\nSolution 1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  class Solution: # BFS def movingCount(self, m: int, n: int, k: int) -\u0026gt; int: grid = [[0 for _ in range(n)] for _ in range(m)] q, cnt = [], 0 def sumCoord(i, j): total = 0 while i \u0026gt; 0: total += i % 10 i = i // 10 while j \u0026gt; 0: total += j % 10 j = j // 10 return total if k \u0026gt;= 0: q.append([0,0]) grid[0][0] = 1 # Mark as visited cnt += 1 while q: [x,y] = q.pop(0) if x+1 \u0026lt; m and grid[x+1][y] == 0 and sumCoord(x+1, y) \u0026lt;= k: q.append([x+1,y]) grid[x+1][y] = 1 cnt += 1 if y+1 \u0026lt; n and grid[x][y+1] == 0 and sumCoord(x, y+1) \u0026lt;= k: q.append([x,y+1]) grid[x][y+1] = 1 cnt += 1 return cnt   Solution 2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  class Solution: # DFS def movingCount(self, m: int, n: int, k: int) -\u0026gt; int: grid = [[0] * n for _ in range(m)] def sumCoord(i, j): total = 0 while i \u0026gt; 0: total += i % 10 i = i // 10 while j \u0026gt; 0: total += j % 10 j = j // 10 return total def dfs(x, y): if x \u0026lt; 0 or x \u0026gt;= m or y \u0026lt; 0 or y \u0026gt;= n or grid[x][y] == 1 or sumCoord(x, y) \u0026gt; k: return 0 grid[x][y] = 1 # Mark as visited return 1 + dfs(x + 1, y) + dfs(x, y + 1) return dfs(0, 0)   Explanation  This question is similar to the Leetcode 200, Number of Islands. Because of the properties of position indexes, we only need to check the right and down directions instead of all directions. Solution 1 \u0026amp; 2  Time Complexity: O(M * N) Space Complexity: O(M * N)     Task 2 - Q12. 矩阵中的路径 Question 给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。\n单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。\nSolution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  class Solution: # DFS def exist(self, board: List[List[str]], word: str) -\u0026gt; bool: def dfs(x, y, id): if x \u0026lt; 0 or y \u0026lt; 0 or x \u0026gt;= len(board) or y \u0026gt;= len(board[0]) or board[x][y] != word[id]: return False elif id == len(word)-1: # Tracking which character is being tracked return True else: board[x][y] = \u0026#34;\u0026#34; # Mark as visited so that same elements won\u0026#39;t be used multiple times res = dfs(x-1, y, id+1) or dfs(x, y-1, id+1) or dfs(x+1, y, id+1) or dfs(x, y+1, id+1) board[x][y] = word[id] # Put the original value back return res m, n = len(board), len(board[0]) for i in range(0, m): for j in range(0, n): if dfs(i, j, 0): return True return False   Explanation  Time Complexity: O(3K * M * N)  The length of the string is K and there are 4-1 options each time. The time would be O(3K) There are M * N grids in total   Space Complexity: O(K)  The depth of recursion is no longer than K. In the worst case, K = MN.     ","date":"2022-04-25T20:17:54+08:00","permalink":"https://tonyfpy.github.io/p/%E5%89%91%E6%8C%87offer-day-14-searching-and-backtracking/","title":"[剑指Offer] Day 14: Searching and Backtracking"},{"content":" Authored by Tony Feng\nCreated on April 24th, 2022\nLast Modified on April 24th, 2022\n Task 1 - Q21. 调整数组顺序使奇数位于偶数前面 Question 输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数在数组的前半部分，所有偶数在数组的后半部分。\nSolution 1 1 2 3 4 5 6 7 8 9 10 11 12 13  class Solution: # Head \u0026amp; Tail def exchange(self, nums: List[int]) -\u0026gt; List[int]: i, j = 0, len(nums) - 1 while i \u0026lt; j: # Traverse the array from two sides if nums[i] % 2 == 1: i += 1 elif nums[j] % 2 == 0: j -= 1 else: nums[i], nums[j] = nums[j], nums[i] i += 1 j -= 1 return nums   Solution 2 1 2 3 4 5 6 7 8 9  class Solution: # Fast \u0026amp; Slow def exchange(self, nums: List[int]) -\u0026gt; List[int]: slow = fast = 0 while fast \u0026lt; len(nums): if nums[fast] % 2 == 1: # Find odd number and swap no matter what slow points to nums[slow], nums[fast] = nums[fast], nums[slow] slow += 1 fast += 1 return nums   Explanation  Solution 1 \u0026amp; 2  Time Complexity: O(N) Space Complexity: O(1)     Task 2 - Q57. 和为s的两个数字 Question 输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，则输出任意一对即可。\nSolution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  class Solution: def twoSum(self, nums: List[int], target: int) -\u0026gt; List[int]: if len(nums) \u0026lt;= 1: return None l, r = 0, len(nums)-1 # Head \u0026amp; Tail while nums[r] \u0026gt; target: # Ignore the number who\u0026#39;s larger than the target r -= 1 while l \u0026lt; r: if nums[l] + nums[r] \u0026gt; target: r -= 1 elif nums[l] + nums[r] \u0026lt; target: l += 1 else: return [nums[l], nums[r]] return None   Explanation  Time Complexity: O(N) Space Complexity: O(1)   Task 3 - Q58,I. 翻转单词顺序 Question 输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。 要求：\n 为简单起见，标点符号和普通字母一样处理。 \u0026ldquo;I am a student. \u0026quot; -\u0026gt;\u0026ldquo;student. a am I\u0026rdquo;。 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。  \u0026quot; hello world! \u0026quot; -\u0026gt; \u0026ldquo;world! hello\u0026rdquo;  如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。 \u0026ldquo;a good example\u0026rdquo; -\u0026gt; \u0026ldquo;example good a\u0026rdquo;   Solution 1 2 3 4  class Solution: def reverseWords(self, s: str) -\u0026gt; str: # Use the built-in function of Python return (\u0026#34; \u0026#34;).join(s.split()[::-1])   Explanation  Time Complexity: O(N) Space Complexity: O(1)   ","date":"2022-04-24T17:27:01+08:00","permalink":"https://tonyfpy.github.io/p/%E5%89%91%E6%8C%87offer-day-13-two-pointers/","title":"[剑指Offer] Day 13: Two Pointers"},{"content":" Authored by Tony Feng\nCreated on April 23rd, 2022\nLast Modified on April 23rd, 2022\n Task 1 - Q25. 合并两个排序的链表 Question 输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。\nSolution 1 1 2 3 4 5 6 7 8 9 10 11  class Solution: # Recursion def mergeTwoLists(self, l1: ListNode, l2: ListNode) -\u0026gt; ListNode: if not l1 or not l2: return l2 or l1 if l1.val \u0026lt;= l2.val: l1.next = self.mergeTwoLists(l1.next, l2) return l1 else: l2.next = self.mergeTwoLists(l1, l2.next) return l2   Solution 2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  class Solution: # Iteration def mergeTwoLists(self, l1: ListNode, l2: ListNode) -\u0026gt; ListNode: dummy = ListNode(0) pre = dummy while l1 and l2: if l1.val \u0026lt;= l2.val: pre.next = l1 l1 = l1.next else: pre.next = l2 l2 = l2.next pre = pre.next pre.next = l1 if l1 else l2 return dummy.next   Explanation  Solution 1  Time Complexity: O(M+N) Space Complexity: O(M+N)   Solution 2  Time Complexity: O(M+N) Space Complexity: O(1)     Task 2 - Q52. 两个链表的第一个公共节点 Question 输入两个链表，找出它们的第一个公共节点。如果两个链表没有交点，返回 null。 要求： - 在返回结果后，两个链表仍须保持原有的结构。 - 程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。\nSolution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  class ListNode: def __init__(self, x): self.val = x self.next = None class Solution: def getIntersectionNode(self, headA: ListNode, headB: ListNode) -\u0026gt; ListNode: if not headA or not headB: return None \u0026#39;\u0026#39;\u0026#39; 1 -\u0026gt; 2 -\u0026gt; 3 -\u0026gt; 4 | 6 -\u0026gt; 3 -\u0026gt; 4 6 -\u0026gt; 3 -\u0026gt; 4 | 1 -\u0026gt; 2 -\u0026gt; 3 -\u0026gt; 4 \u0026#39;\u0026#39;\u0026#39; tmpA, tmpB = headA, headB while tmpA != tmpB: tmpA = tmpA.next if tmpA else headB tmpB = tmpB.next if tmpB else headA return tmpA   Explanation  Time Complexity: O(M+N) Space Complexity: O(1)   ","date":"2022-04-23T16:20:30+08:00","permalink":"https://tonyfpy.github.io/p/%E5%89%91%E6%8C%87offer-day-12-two-pointers/","title":"[剑指Offer] Day 12: Two Pointers"},{"content":" Authored by Tony Feng\nCreated on April 22nd, 2022\nLast Modified on April 22nd, 2022\n Task 1 - Q18. 删除链表的节点 Question 给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。返回删除后的链表的头节点。\nSolution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  class ListNode: def __init__(self, x): self.val = x self.next = None class Solution: def deleteNode(self, head: ListNode, val: int) -\u0026gt; ListNode: if not head: return head node = ListNode(0) # dummy node node.next = head pre = node while head: if head.val != val: pre = pre.next head = head.next else: pre.next = head.next return node.next return node.next   Explanation  Time Complexity: O(N) Space Complexity: O(1)   Task 2 - Q22. 链表中倒数第k个节点 Question 输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。 例如，一个链表有 6 个节点，从头节点开始，它们的值依次是 1、2、3、4、5、6。这个链表的倒数第 3 个节点是值为 4 的节点。\nSolution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  class ListNode: def __init__(self, x): self.val = x self.next = None class Solution: # Fast \u0026amp; Slow Pointers def getKthFromEnd(self, head: ListNode, k: int) -\u0026gt; ListNode: fast, slow = head, head # Let the Fast go through k nodes  while fast and k \u0026gt; 0: fast = fast.next k = k - 1 while fast: fast = fast.next slow = slow.next return slow   Explanation  Time Complexity: O(N) Space Complexity: O(1)   ","date":"2022-04-22T16:48:56+08:00","permalink":"https://tonyfpy.github.io/p/%E5%89%91%E6%8C%87offer-day-11-linked-list/","title":"[剑指Offer] Day 11: Linked List"},{"content":" Authored by Tony Feng\nCreated on April 21st, 2022\nLast Modified on April 21st, 2022\n Task 1 - Q48. 最长不含重复字符的子字符串 Question 请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。 e.g.  输入: \u0026ldquo;abcabcbb\u0026rdquo;, 输出: 3  解释: 因为无重复字符的最长子串是 \u0026ldquo;abc\u0026rdquo;，所以其长度为 3。\nSolution 1 2 3 4 5 6 7 8 9 10  class Solution: def lengthOfLongestSubstring(self, s: str) -\u0026gt; int: dict = {} res = tmp = 0 for j in range(0, len(s)): i = dict.get(s[j], -1) # get index i, the position where s[j] exists dict[s[j]] = j # update the hash map tmp = tmp + 1 if tmp \u0026lt; j - i else j - i # dp[j - 1] -\u0026gt; dp[j] res = max(res, tmp) # max(dp[j - 1], dp[j]) return res   Explanation  tmp records the length of the unrepeated substring ending with s[j]. ```dict`` records the last position where each key exists. Time Complexity: O(N) Space Complexity: O(1)   Task 2 - Q46. 把数字翻译成字符串 Question 给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。 e.g.  输入: 12258, 输出: 5  解释: 12258有5种不同的翻译，分别是\u0026quot;bccfi\u0026quot;, \u0026ldquo;bwfi\u0026rdquo;, \u0026ldquo;bczi\u0026rdquo;, \u0026ldquo;mcfi\u0026quot;和\u0026quot;mzi\u0026rdquo; \nSolution 1 1 2 3 4 5 6 7 8 9 10 11 12 13 14  class Solution: # dp def translateNum(self, num: int) -\u0026gt; int: num = list(str(num)) dp = [1 for _ in range(0, len(num)+1)] # dp[0] == dp[1] == 1 for i in range(2, len(num)+1): # dp[i] means the sum of the approaches before num[i] (i.e., num[0] ... num[i-1]) # Be careful with the index here if int(num[i-2] + num[i-1]) \u0026lt; 26 and int(num[i-2]) != 0: dp[i] = dp[i-1] + dp[i-2] else: dp[i] = dp[i-1] return dp[-1]   Solution 2 1 2 3 4 5 6 7 8 9 10 11 12 13 14  class Solution: # Recursion def translateNum(self, num: int) -\u0026gt; int: def recur(arr): if len(arr) \u0026lt;= 1: # base case return 1 # no need to count on \u0026#34;01\u0026#34;, \u0026#34;02\u0026#34;, ..., \u0026#34;09\u0026#34;  # no need to count on num \u0026gt;= 26 if int(arr[0] + arr[1]) \u0026lt; 26 and int(arr[0]) != 0: return recur(arr[1:]) + recur(arr[2:]) else: return recur(arr[1:]) return recur(str(num))   Explanation  Solution 1  Time Complexity: O(N) Space Complexity: O(N)   Solution 2  Time Complexity: O(2N) Space Complexity: O(N)     ","date":"2022-04-21T20:31:37+08:00","permalink":"https://tonyfpy.github.io/p/%E5%89%91%E6%8C%87offer-day-10-dynamic-programming/","title":"[剑指Offer] Day 10: Dynamic Programming"},{"content":" Authored by Tony Feng\nCreated on April 20th, 2022\nLast Modified on April 20th, 2022\n Task 1 - Q42. 连续子数组的最大和 Question 输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。要求时间复杂度为 O(n)。\nSolution 1 2 3 4 5 6 7 8 9  class Solution: def maxSubArray(self, nums: List[int]) -\u0026gt; int: tmp = float(\u0026#39;-inf\u0026#39;) maxSum = float(\u0026#39;-inf\u0026#39;) for num in nums: tmp = max(tmp + num, num) # It chooses whether to extend the sub-array or restart from the new item. maxSum = max(maxSum, tmp) # It records the max value after an array has been updated. return maxSum   Explanation  Time Complexity: O(N) Space Complexity: O(1)   Task 2 - Q47. 礼物的最大价值 Question 在一个 m * n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？\nSolution 1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  class Solution: def maxValue(self, grid: List[List[int]]) -\u0026gt; int: if not grid: return 0 dp = [[0 for _ in range(len(grid[0]))] for _ in range(len(grid))] for i in range(0, len(grid)): for j in range(0, len(grid[0])): if i == j == 0: dp[i][j] = grid[i][j] elif i - 1 \u0026lt; 0: dp[i][j] = dp[i][j-1] + grid[i][j] elif j - 1 \u0026lt; 0: dp[i][j] = dp[i-1][j] + grid[i][j] else: dp[i][j] = grid[i][j] + max(dp[i][j-1], dp[i-1][j]) return dp[-1][-1]   Solution 2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  class Solution: # Space Optimization def maxValue(self, grid: List[List[int]]) -\u0026gt; int: if not grid: return 0 for i in range(0, len(grid)): for j in range(0, len(grid[0])): if i == j == 0: continue elif i - 1 \u0026lt; 0: grid[i][j] += grid[i][j-1] elif j - 1 \u0026lt; 0: grid[i][j] += grid[i-1][j] else: grid[i][j] += max(grid[i][j-1], grid[i-1][j]) return grid[-1][-1]   Explanation  Solution 2 is an optimized version of solution 1 in the spatial dimension. Time Complexity: O(N) Space Complexity  Solution 1: O(N) Solution 2: O(1)     ","date":"2022-04-20T22:13:36+08:00","permalink":"https://tonyfpy.github.io/p/%E5%89%91%E6%8C%87offer-day-9-dynamic-programming/","title":"[剑指Offer] Day 9: Dynamic Programming"},{"content":" Authored by Tony Feng\nCreated on April 19th, 2022\nLast Modified on April 19th, 2022\n Task 1 - Q10,I. 斐波那契数列 Question 写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项。 斐波那契数列的定义如下： F(0) = 0, F(1) = 1 F(N) = F(N - 1) + F(N - 2), N \u0026gt; 1 答案需要取模 1e9+7（1000000007）\nSolution 1 1 2 3 4 5 6 7 8 9 10 11  class Solution: def fib(self, n: int) -\u0026gt; int: MOD = 10 ** 9 + 7 if n \u0026lt;= 1 : return n dp = [0] * (n+1) dp[1] = 1 for i in range(2, n+1): dp[i] = (dp[i-1] + dp[i-2]) % MOD return dp[n]   Solution 2 1 2 3 4 5 6 7 8 9 10  class Solution: def fib(self, n: int) -\u0026gt; int: MOD = 10 ** 9 + 7 if n \u0026lt;= 1: return n p, q, r = 0, 0, 1 for i in range(2, n + 1): p = q q = r r = (p + q) % MOD return r   Explanation  Solution 1 \u0026amp; 2 use the same idea, dynamic programming. However, solution 2 is more spatially-efficient. Time Complexity: O(N) Space Complexity  Solution 1: O(N) Solution 2: O(1)     Task 2 - Q10,II. 青蛙跳台阶问题 Question 一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法? 答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。\nSolution 1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  class Solution: # Recursion def numWays(self, n: int) -\u0026gt; int: if n \u0026lt;= 1: return 1 MOD = 10 ** 9 + 7 buffer = [-1] * (n+1) # Avoid repeated calculation buffer[0], buffer[1] = 1, 1 def recur(num): if buffer[num] != -1: return buffer[num] else: res = (recur(num-1) + recur(num-2)) % MOD buffer[num] = res return res return recur(n)   Solution 2 1 2 3 4 5 6 7  class Solution: # DP def numWays(self, n: int) -\u0026gt; int: a, b = 1, 1 MOD = 10 ** 9 + 7 for _ in range(n): a, b = b, (a + b) % MOD return a   Explanation  Solution1  Time Complexity: O(N) Space Complexity: O(N)   Solution2  Time Complexity: O(N) Space Complexity: O(1)     Task 3 - Q63. 股票的最大利润 Question 假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？ 输入: [7,1,5,3,6,4], 输出: 5  解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5。注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。\nSolution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  class Solution1: def maxProfit(self, prices: List[int]) -\u0026gt; int: if len(prices) \u0026lt;= 1: return 0 dp = [0] * len(prices) minP = prices[0] for i in range(1, len(prices)): dp[i] = max(dp[i-1], prices[i]-minP) minP = min(minP, prices[i]) return dp[-1] class Solution2: def maxProfit(self, prices: List[int]) -\u0026gt; int: if len(prices) \u0026lt;= 1: return 0 minPrice, maxProfit = float(\u0026#34;+inf\u0026#34;), 0 for price in prices: minPrice = min(minPrice, price) maxProfit = max(maxProfit, price - minPrice) return maxProfit   Explanation  Time Complexity: O(N) Space Complexity  Solution 1: O(N) Solution 2: O(1)     ","date":"2022-04-19T22:13:32+08:00","permalink":"https://tonyfpy.github.io/p/%E5%89%91%E6%8C%87offer-day-8-dynamic-programming/","title":"[剑指Offer] Day 8: Dynamic Programming"},{"content":" Authored by Tony Feng\nCreated on April 18th, 2022\nLast Modified on April 18th, 2022\n Task 1 - Q26. 树的子结构 Question 输入两棵二叉树A和B，判断B是不是A的子结构。若B是A的子结构，即A中有出现和B相同的结构和节点值。(约定空树不是任意一个树的子结构)\nSolution 1 2 3 4 5 6 7 8 9 10 11 12 13  class Solution: def isSubStructure(self, A: TreeNode, B: TreeNode) -\u0026gt; bool: if not B or not A: return False def compare(nodeA, nodeB): if not nodeB: # Finish checking all nodes in B return True if not nodeA: # nodeA is empty but nodeB not return False return nodeA.val == nodeB.val and compare(nodeA.left, nodeB.left) and compare(nodeA.right, nodeB.right) return (compare(A, B) or self.isSubStructure(A.left, B) or self.isSubStructure(A.right, B))   Explanation  N = # of nodes in tree A; M = # of nodes in tree B Time Complexity: O(N*M) Space Complexity: O(N)  The worst case is traversing the whole tree A.     Task 2 - Q27. 二叉树的镜像 Question 请完成一个函数，输入一个二叉树，该函数输出它的镜像。(类似于水平翻转)\nSolution 1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  class MySolution: # BFS def mirrorTree(self, root: TreeNode) -\u0026gt; TreeNode: if not root: return None mRoot = TreeNode(root.val) que = [root] mQue = [mRoot] while que: node = que.pop(0) mNode = mQue.pop(0) if node.left: mNode.right = TreeNode(node.left.val) mQue.append(mNode.right) que.append(node.left) if node.right: mNode.left = TreeNode(node.right.val) mQue.append(mNode.left) que.append(node.right) return mRoot class Solution: # BFS def mirrorTree(self, root: TreeNode) -\u0026gt; TreeNode: if not root: return stack = [root] # FILO while stack: node = stack.pop() if node.left: stack.append(node.left) if node.right: stack.append(node.right) node.left, node.right = node.right, node.left return root   Solution 2 1 2 3 4 5 6 7  class Solution: # Recursion def mirrorTree(self, root: TreeNode) -\u0026gt; TreeNode: if not root: return root.left = self.mirrorTree(root.right) root.right = self.mirrorTree(root.left) return root   Explanation  My solution and solution 1 have the same idea, but the latter is more tricky. Solution1 \u0026amp; 2  Time Complexity: O(N) Space Complexity: O(N)     Task 3 - Q28. 对称的二叉树 Question 请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。\nSolution 1 2 3 4 5 6 7 8 9 10  class Solution: def isSymmetric(self, root: TreeNode) -\u0026gt; bool: def recur(L, R): if not L and not R: return True if not L or not R: return False return L.val == R.val and recur(L.left, R.right) and recur(L.right, R.left) return recur(root.left, root.right) if root else True   Explanation  Time Complexity: O(N)  The algorithm calls the recur() for N/2 times at most.   Space Complexity: O(N)   ","date":"2022-04-18T22:13:27+08:00","permalink":"https://tonyfpy.github.io/p/%E5%89%91%E6%8C%87offer-day-7-searching-and-backtracking/","title":"[剑指Offer] Day 7: Searching and Backtracking"},{"content":" Authored by Tony Feng\nCreated on April 17th, 2022\nLast Modified on April 17th, 2022\n Task 1 - Q32 - I. 从上到下打印二叉树 Question 从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。\nSolution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None class Solution: # BFS def levelOrder(self, root: TreeNode) -\u0026gt; List[int]: if not root: return [] res, tmp = [], [] tmp.append(root) while tmp: # Break until the queue is empty node = tmp.pop(0) res.append(node.val) if node.left: tmp.append(node.left) if node.right: tmp.append(node.right) return res   Explanation  Time Complexity: O(N)  The algorithm needs to go through every node.   Space Complexity: O(N)  At most N/2 nodes are in the queue at the same time.     Task 2 - Q32 - II. 从上到下打印二叉树 II Question 从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。\nSolution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None class Solution: def levelOrder(self, root: TreeNode) -\u0026gt; List[List[int]]: if not root: return [] res, tmp = [], [root] while tmp: level = [] for _ in range(0, len(tmp)): # Tracing the number of nodes on each level node = tmp.pop(0) if node.left: tmp.append(node.left) if node.right: tmp.append(node.right) level.append(node.val) res.append(level) return res   Explanation  Time Complexity: O(N) Space Complexity: O(N)   Task 3 - Q32 - III. 从上到下打印二叉树 III Question 请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。\nSolution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None from collections import deque class Solution: def levelOrder(self, root: TreeNode) -\u0026gt; List[List[int]]: if not root: return [] res, tmp = [], [root] while tmp: level = deque() for _ in range(len(tmp)): node = tmp.pop(0) if len(res) % 2 == 0: # res contains the traversed nodes level.append(node.val) # level will contain the next level of nodes else: level.appendleft(node.val) if node.left: tmp.append(node.left) if node.right: tmp.append(node.right) res.append(list(level)) return res   Explanation  Time Complexity: O(N) Space Complexity: O(N)   ","date":"2022-04-17T22:13:20+08:00","permalink":"https://tonyfpy.github.io/p/%E5%89%91%E6%8C%87offer-day-6-searching-and-backtracking/","title":"[剑指Offer] Day 6: Searching and Backtracking"},{"content":" Authored by Tony Feng\nCreated on April 16th, 2022\nLast Modified on April 16th, 2022\n Task 1 - Q04. 二维数组中的查找 Question 在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 e.g.  [1, 4, 7, 11, 15],  [2, 5, 8, 12, 19],  [3, 6, 9, 16, 22],  [10, 13, 14, 17, 24],  [18, 21, 23, 26, 30]\nSolution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  class Solution: def findNumberIn2DArray(self, matrix: List[List[int]], target: int) -\u0026gt; bool: if matrix == [] or matrix == [[]]: return False n, m = len(matrix), len(matrix[0]) i, j = 0, m-1 while i \u0026lt;= n-1 and j \u0026gt;= 0: if matrix[i][j] \u0026gt; target: j -= 1 elif matrix[i][j] \u0026lt; target: i += 1 else: return True return False   Explanation  Using the properties of the matrix properly is a trick.  The top-right item is the largest number in its row; The top-right item is the smallest number in its column;   Time Complexity: O(N+M) Space Complexity: O(1)   Task 2 - Q50. 第一个只出现一次的字符 Question 在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。 s 只包含小写字母。\nSolution 1 2 3 4 5 6 7 8 9  class Solution: def firstUniqChar(self, s: str) -\u0026gt; str: dict = {} for c in s: dict[c] = not c in dict for c in s: if dict[c]: return c return \u0026#39; \u0026#39;   Explanation  Time Complexity: O(N) Space Complexity: O(1)  At most 26 keys are in the dictionary.     ","date":"2022-04-16T22:13:16+08:00","permalink":"https://tonyfpy.github.io/p/%E5%89%91%E6%8C%87offer-day-5-searching/","title":"[剑指Offer] Day 5: Searching"},{"content":" Authored by Tony Feng\nCreated on April 15th, 2022\nLast Modified on April 15th, 2022\n Task 1 - Q03. 数组中重复的数字 Question 在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。\nSolution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  class Solution1: # Hash Map def findRepeatNumber(self, nums: List[int]) -\u0026gt; int: dict = {} for n in nums: if n in dict: return n dict[n] = 1 return -1 class Solutio2: # Set def findRepeatNumber(self, nums: [int]) -\u0026gt; int: s = set() for num in nums: if num in s: return num s.add(num) return -1   Explanation  Solution1 and 2 use the same idea but different data structures. Time Complexity: O(N) Space Complexity: O(N)   Task 2 - Q53,I. 在排序数组中查找数字 I Question 统计一个数字在排序数组中出现的次数。\nSolution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  class Solution: # Bianry Search \u0026#39;\u0026#39;\u0026#39; Find the right bound of target and target-1 \u0026#39;\u0026#39;\u0026#39; def search(self, nums: [int], target: int) -\u0026gt; int: def findR(tar): i, j = 0, len(nums) - 1 while i \u0026lt;= j: m = i + (j - i) // 2 if nums[m] \u0026lt;= tar: i = m + 1 else: j = m - 1 return i return findR(target) - findR(target - 1)   Explanation  Time Complexity: O(log N) Space Complexity: O(1)   Task 3 - Q53,II. 0～n-1中缺失的数字 Question 一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。\nSolution 1 2 3 4 5 6 7 8 9 10 11 12 13 14  \u0026#39;\u0026#39;\u0026#39; Find the rightest index that is not equal to its element \u0026#39;\u0026#39;\u0026#39; class Solution: def missingNumber(self, nums: List[int]) -\u0026gt; int: i, j = 0, len(nums)-1 while i \u0026lt;= j: m = i + (j - i) // 2 if m == nums[m]: i = m + 1 else: j = m - 1 return i   Explanation  Time Complexity: O(log N) Space Complexity: O(1)   ","date":"2022-04-15T22:13:09+08:00","permalink":"https://tonyfpy.github.io/p/%E5%89%91%E6%8C%87offer-day-4-searching/","title":"[剑指Offer] Day 4: Searching"},{"content":" Authored by Tony Feng\nCreated on April 14th, 2022\nLast Modified on April 14th, 2022\n Task 1 - Q05. 替换空格 Question 请实现一个函数，把字符串 s 中的每个空格替换成 \u0026quot;%20\u0026quot;。\nSolution 1 2 3 4 5 6 7  class Solution1: def replaceSpace(self, s: str) -\u0026gt; str: return s.replace(\u0026#34; \u0026#34;, \u0026#34;%20\u0026#34;) class Solution2: def replaceSpace(self, s: str) -\u0026gt; str: return \u0026#34;%20\u0026#34;.join(s.split(\u0026#34; \u0026#34;))   Explanation  Time Complexity: O(N) Space Complexity: O(N)   Task 2 - Q58,II. 左旋转字符串 Question 字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串\u0026quot;abcdefg\u0026quot;和数字2，该函数将返回左旋转两位得到的结果\u0026quot;cdefgab\u0026quot;。\nSolution 1 2 3 4 5  class Solution: def reverseLeftWords(self, s: str, n: int) -\u0026gt; str: s1 = s[0:n] s2 = s[n:] return s2 + s1   Explanation  Time Complexity: O(N) Space Complexity: O(N)   ","date":"2022-04-14T22:13:03+08:00","permalink":"https://tonyfpy.github.io/p/%E5%89%91%E6%8C%87offer-day-3-string/","title":"[剑指Offer] Day 3: String"},{"content":" Authored by Tony Feng\nCreated on April 13th, 2022\nLast Modified on April 13th, 2022\n Task 1 - Q06. 从尾到头打印链表 Question 输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。\nSolution 1 1 2 3 4 5 6 7 8 9 10 11  class Solution: # Iteration def reversePrint(self, head: ListNode) -\u0026gt; List[int]: if not head: return [] res = [] while head: res.append(head.val) head = head.next return res[::-1]   Solution 2 1 2 3 4 5 6  class Solution: # Recursion def reversePrint(self, head: ListNode) -\u0026gt; List[int]: if not head: return [] else: return self.reversePrint(head.next) + [head.val]   Explanation  Solution1 \u0026amp; Solution2  Time Complexity: O(N) Space Complexity: O(N)     Task 2 - Q24. 反转链表 Question 定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。\nSolution 1 1 2 3 4 5 6 7 8 9  class Solution: # Two Pointers def reverseList(self, head: ListNode) -\u0026gt; ListNode: cur, pre = head, None while cur: tmp = cur.next # 暂存后继节点 cur.next cur.next = pre # 修改 next 引用指向 pre = cur # pre 暂存 cur cur = tmp # cur 访问下一节点 return pre   Solution 2 1 2 3 4 5 6 7 8 9 10 11  class Solution: # Recursion def reverseList(self, head: ListNode) -\u0026gt; ListNode: if not head or not head.next: return head node = self.reverseList(head.next) head.next.next = head head.next = None return node   Explanation  Solution1  Time Complexity: O(N) Space Complexity: O(1)   Solution2  Time Complexity: O(N) Space Complexity: O(N)     Task 3 - Q35. 复杂链表的复制 Question 请实现 copyRandomList 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 next 指针指向下一个节点，还有一个 random 指针指向链表中的任意节点或者 null。\nSolution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  class Node: def __init__(self, x: int, next: \u0026#39;Node\u0026#39; = None, random: \u0026#39;Node\u0026#39; = None): self.val = int(x) self.next = next self.random = random class Solution: def copyRandomList(self, head: \u0026#39;Node\u0026#39;) -\u0026gt; \u0026#39;Node\u0026#39;: if not head: return head node_dict = {} cur = head # Traverse the origin nodes and put them in a dictionary while cur: # Mapping the original node to a new node # Only val is updated here node_dict[cur] = Node(x=cur.val) cur = cur.next node_dict[cur] = None # Traverse the dictionary and update the next and random pointer cur = head while cur: node_dict[cur].next = node_dict[cur.next] node_dict[cur].random = node_dict[cur.random] cur = cur.next # Return the head of the new linked list return node_dict[head]   Explanation  Steps  Use a dictionary to record the position of the original nodes Update the next and random pointer in reference to the original nodes   Time Complexity: O(N) Space Complexity: O(N)   ","date":"2022-04-13T22:12:58+08:00","permalink":"https://tonyfpy.github.io/p/%E5%89%91%E6%8C%87offer-day-2-linked-list/","title":"[剑指Offer] Day 2: Linked List"},{"content":" Authored by Tony Feng\nCreated on April 12th, 2022\nLast Modified on April 12th, 2022\n Task 1 - Q09. 用两个栈实现队列 Question 用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )\nSolution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  class CQueue: def __init__(self): self.que = [] self.tmp = [] # Buffer def appendTail(self, value: int) -\u0026gt; None: self.que.append(value) def deleteHead(self) -\u0026gt; int: # Reverse the order while self.que: self.tmp.append(self.que.pop()) head = self.tmp.pop() if self.tmp else -1 while self.tmp: self.que.append(self.tmp.pop()) return head   Explanation  Two Stacks: One is for storage and the other is for buffering. Time Complexity  appendTail: O(1) deleteHead: O(N)   Space Complexity  appendTail: O(N) deleteHead: O(N)     Task 2 - Q30. 包含min函数的栈 Question 定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。\nSolution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  class MinStack: def __init__(self): self.stack = [] self.minVal = [] def push(self, x: int) -\u0026gt; None: self.stack.append(x) if self.minVal: self.minVal.append(min(x, self.minVal[-1])) else: self.minVal.append(x) def pop(self) -\u0026gt; None: if self.stack: self.stack.pop() if self.minVal: self.minVal.pop() def top(self) -\u0026gt; int: if self.stack: return self.stack[-1] if self.minVal: return self.minVal[-1] def min(self) -\u0026gt; int: return self.minVal[-1]   Explanation  Two Stacks: One is for storage and the other is for tracing the minimum value. Time Complexity: O(1) Space Complexity: O(N)   ","date":"2022-04-12T22:12:52+08:00","permalink":"https://tonyfpy.github.io/p/%E5%89%91%E6%8C%87offer-day-1-stack-and-queue/","title":"[剑指Offer] Day 1: Stack and Queue"},{"content":" Authored by Tony Feng\nCreated on April 10th, 2022\nLast Modified on April 10th, 2022\n Understanding Trie Main Concepts  A trie is a special tree that can compactly store strings. Tries are based on the prefix of a string. They are used to represent the \u0026ldquo;Retrieval\u0026rdquo; of data and thus the name Trie.  Charateristics  Strengths  Sometimes Space-Efficient. If you\u0026rsquo;re storing lots of words that start with similar patterns, tries may reduce the overall storage cost by storing shared prefixes once. Efficient Prefix Queries. Tries can quickly answer queries about words with shared prefixes   Weakness  Usually Space-Inefficient. Tries rarely save space when compared to storing strings in a set. Not Standard. Most languages don\u0026rsquo;t come with a built-in trie implementation.     Example Leetcode 208 Implement Trie (Prefix Tree) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41  class TrieNode: def __init__(self, char = \u0026#34;\u0026#34;): self.char = char self.children = {} self.is_end = False # self.counter = 0 class Trie: def __init__(self): self.root = TrieNode() def insert(self, word: str) -\u0026gt; None: node = self.root for char in word: if char in node.children: node = node.children[char] else: new_node = TrieNode(char) node.children[char] = new_node node = new_node node.is_end = True # node.counter += 1 def search(self, word: str) -\u0026gt; bool: node = self.root for char in word: if char not in node.children: return False node = node.children[char] # Reached at the end of word # return True if word is present, i.e is_end = True else False return node.is_end def startsWith(self, prefix: str) -\u0026gt; bool: node = self.root for char in prefix: if char not in node.children: return False node = node.children[char] return True   Leetcode 720 Longest Word in Dictionary 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  class TrieNode: def __init__(self, val): self.children = {} self.value = val self.endOfWord = False class Solution: def longestWord(self, words: List[str]) -\u0026gt; str: root = TrieNode(0) maxLen = 0 res = \u0026#34;\u0026#34; for word in sorted(words): cur = root count = 0 for letter in word: if letter not in cur.children: cur.children[letter] = TrieNode(count) cur = cur.children[letter] if cur.endOfWord: count += 1 cur.endOfWord = True cur.value += 1 if cur.value == len(word) and cur.value \u0026gt; maxLen: maxLen = cur.value res = word return res    Reference  Trie (Keyword Tree) InterviewCake - Trie 手把手带你刷Leetcode力扣 - 前缀树 Trie 手把手带你刷Leetcode力扣 - Leetcode 720   ","date":"2022-04-10T22:38:44+08:00","permalink":"https://tonyfpy.github.io/p/data-structure-topic-11-trie/","title":"[Data Structure] Topic 11: Trie"},{"content":" Authored by Tony Feng\nCreated on April 10th, 2022\nLast Modified on April 10th, 2022\n Understanding Dynamic Programming Intro  Dynamic Programming helps to efficiently solve a class of problems that have overlapping subproblems and optimal substructure property. Key elements  Initialization State-transition Equation Termination    Characteristics  Overlapping Subproblems  Any problem has overlapping sub-problems if finding its solution involves solving the same subproblem multiple times.   Optimal Substructure Property  Any problem has optimal substructure property if its overall optimal solution can be constructed from the optimal solutions of its subproblems.    Dynamic Programming Methods  Top-down with Memoization  In this approach, we try to solve the bigger problem by recursively finding the solution to smaller sub-problems. Whenever we solve a sub-problem, we cache its result so that we can just return the saved result if it’s called multiple times.   Bottom-up with Tabulation  Tabulation is the opposite of the top-down approach and avoids recursion. In this approach, we solve the problem “bottom-up” (i.e. by solving all the related sub-problems first). This is typically done by filling up an n-dimensional table. Based on the results in the table, the solution to the top/original problem is then computed.     Examples Leetcode 509 Fibonacci Number 1 2 3 4 5 6 7 8 9 10 11 12  class Solution: def fib(self, n: int) -\u0026gt; int: if n == 0: return 0 if n == 1: return 1 dp = [0] * (n + 1) dp[0], dp[1] = 0, 1 for i in range(2, n+1): dp[i] = dp[i-1] + dp[i-2] # State-transition Equation return dp[n]   Leetcode 62 Unique Paths 1 2 3 4 5 6 7 8 9 10 11 12 13 14  class Solution: def uniquePaths(self, m: int, n: int) -\u0026gt; int: dp = [[1 for _ in range(n)] for _ in range(m)] for i in range(0, m): for j in range(0, n): if i - 1 \u0026lt; 0: dp[i][j] = dp[i][j-1] elif j - 1 \u0026lt; 0: dp[i][j] = dp[i-1][j] else: dp[i][j] = dp[i-1][j] + dp[i][j-1] return dp[m - 1][n - 1]    Reference  手把手带你刷Leetcode力扣 - 动态规划 Dynamic Programming 手把手带你刷Leetcode力扣 - Leetcode 509 手把手带你刷Leetcode力扣 - Leetcode 62 What is Dynamic Programming? Programiz - Dynamic Programming   ","date":"2022-04-10T22:37:31+08:00","permalink":"https://tonyfpy.github.io/p/algorithm-topic-10-dynamic-programming/","title":"[Algorithm] Topic 10: Dynamic Programming"},{"content":" Authored by Tony Feng\nCreated on April 9th, 2022\nLast Modified on April 9th, 2022\n Understanding Greedy Search Intro  A greedy algorithm is an approach for solving a problem by selecting the best option available at the moment. It works in a top-down approach. It doesn\u0026rsquo;t guarantee whether the current best result will bring the overall optimal result. We can determine if the algorithm can be used with any problem if the problem has the following properties:  Greedy Choice Property Optimal Substructure    Characteristics  Advantages of Greedy Approach  The algorithm is easier to describe.   Drawback of Greedy Approach  The greedy algorithm doesn\u0026rsquo;t always produce the optimal solution. The difficult part is that for greedy algorithms you have to work much harder to understand correctness issues. Optimization problems (Dijkstra’s Algorithm) with negative graph edges cannot be solved using a greedy algorithm.    Steps  To begin with, the solution set (containing answers) is empty. At each step, an item is added to the solution set until a solution is reached. If the solution set is feasible, the current item is kept. Else, the item is rejected and never considered again.   Template 1 2 3 4 5 6 7 8 9 10  # Pseudocode Greedy(input I): begin while (solution is not complete) do Select the best element x in the remaining input I; Put x next in the output; Remove x from the remaining input; endwhile end    Examples Leetcode 55 Jump Game 1 2 3 4 5 6 7 8 9 10 11 12  class Solution: def canJump(self, nums): \u0026#34;\u0026#34;\u0026#34; :type nums: List[int] :rtype: bool \u0026#34;\u0026#34;\u0026#34; reach = 0 for i, num in enumerate(nums): if i \u0026gt; reach: return False reach = max(reach, i + num) return True    Reference  手把手带你刷Leetcode力扣 - 贪心算法 Greedy Search Greedy Algorithms Explained with Examples   ","date":"2022-04-09T22:37:19+08:00","permalink":"https://tonyfpy.github.io/p/algorithm-topic-9-greedy-search/","title":"[Algorithm] Topic 9: Greedy Search"},{"content":" Authored by Tony Feng\nCreated on April 7th, 2022\nLast Modified on April 9th, 2022\n Understanding Union Find Intro  A disjoint-set data structure keeps track of a set of elements partitioned into a number of disjoint (non-overlapping) subsets. A union-find algorithm performs union and find operation on those subsets. Union-Find Algorithm can be used to check whether an undirected graph contains cycle or not.  Union \u0026amp; Find  Find  It determines in which subset a particular element is in and returns the representative of that particular set.   Union  It merges two different subsets into a single subset, and the representative of one set becomes representative of another.     Template Common Union Find 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  class UnionFind: def __init__(self, n): # Initialization.  # The parent of each node is itself. self.root = list(range(0,n)) def find(self, x): if x == self.root[x]: return self.root[x] else: return self.find(self.root[x]) def union(self, x, y): rootX = self.root[x] rootY = self.root[y] if rootX != rootY: self.root[rootX] = rootY   Union Find Improvement 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  class UnionFind: def __init__(self, n): # Initialization.  # The parent of each node is itself. self.root = list(range(0,n)) self.rank = [0] * n def find(self, x): if x != self.root[x]: # Use recursion to assign the root value self.root[x] = self.find(self.root[x]) return self.root[x] # Avoid the tree to be too high def union(self, x, y): rootX = self.root[x] rootY = self.root[y] if rootX != rootY: if self.rank[rootX] \u0026gt; self.rank[rootY]: self.root[rootY] = rootX elif self.rank[rootX] \u0026lt; self.rank[rootY]: self.root[rootX] = rootY else: self.root[rootY] = rootX self.rank[rootX] += 1    Examples Leetcode 200 Number of Islands 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48  # Time Complexity: O(MN) # Space Complexity: O(MN) class Solution: def numIslands(self, grid: List[List[str]]) -\u0026gt; int: if grid is None or len(grid) == 0: return 0 row = len(grid) col = len(grid[0]) waters = 0 uf = UnionFind(grid) for i in range(0, row): for j in range(0, col): if grid[i][j] == \u0026#39;0\u0026#39;: waters += 1 else: directions = [(0,1), (0,-1), (-1,0), (1,0)] for x, y in directions: x = x + i y = y + j if x\u0026gt;=0 and y\u0026gt;=0 and x\u0026lt;row and y\u0026lt;col and grid[x][y] == \u0026#39;1\u0026#39;: uf.union(x*col+y, i*col+j) return uf.getCount() - waters class UnionFind: def __init__(self, grid): row = len(grid) col = len(grid[0]) self.root = [-1]*(row*col) self.count = row*col for i in range(0, row*col): self.root[i] = i def find(self, x): if x == self.root[x]: return self.root[x] else: self.root[x] = self.find(self.root[x]) return self.root[x] def union(self, x, y): rootX = self.find(x) rootY = self.find(y) if rootX != rootY: self.root[rootX] = rootY self.count -= 1 def getCount(self): return self.count    Reference  手把手带你刷Leetcode力扣 - 并查集 Union Find 手把手带你刷Leetcode力扣 - 并查集优化 Union Find Optimization 手把手带你刷Leetcode力扣 - Leetcode 200 Disjoint Set (Or Union-Find) Disjoint–Set Data Structure (Union–Find Algorithm)   ","date":"2022-04-07T22:37:04+08:00","permalink":"https://tonyfpy.github.io/p/algorithm-topic-8-union-find/","title":"[Algorithm] Topic 8: Union Find"},{"content":" Authored by Tony Feng\nCreated on April 6th, 2022\nLast Modified on April 6th, 2022\n Understanding BFS Intro  Breadth-First Search (BFS) is an algorithm used for traversing graphs or trees. Breadth-First Search is a recursive algorithm to search all the vertices of a graph or a tree. BFS starts from a node, then it checks all the nodes at distance I from the beginning node, then it checks all the nodes at distance II, and so on. In order to re-collect the nodes to be visited, BFS uses a queue. The time complexity of DFS if the entire tree is traversed is O(V), where V is the number of nodes. In the case of a graph, the time complexity is O(V + E), where V is the number of vertexes and E is the number of edges.  Please note that O(E) may vary between O(1) and O(V2), depending on how dense the graph is.    Steps of BFS  Add the root/start node to the Queue. For every node, set that they don\u0026rsquo;t have a defined parent node. Until the Queue is empty:  Extract the node from the beginning of the Queue. Perform output processing. For every neighbor of the current node that doesn\u0026rsquo;t have a defined parent (is not visited), add it to the Queue, and set the current node as their parent.     Template 1 2 3 4 5 6 7 8 9 10 11 12  def bfs(visited, graph, node): #function for BFS visited.append(node) queue.append(node) while queue: # Creating loop to visit each node m = queue.pop(0) print (m, end = \u0026#34; \u0026#34;) for neighbour in graph[m]: if neighbour not in visited: visited.append(neighbour) queue.append(neighbour)    Examples Leetcode 102 Binary Tree Level Order Traversal 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  from collections import deque class Solution: def levelOrder(self, root: Optional[TreeNode]) -\u0026gt; List[List[int]]: if not root: return [] ans = [] q = deque() # Store nodes q.append(root) while len(q) \u0026gt; 0: size = len(q) # Get how many nodes are in current level tmp = [] # Store nodes in the current level while size \u0026gt; 0: node = q.popleft() tmp.append(node.val) if node.left: q.append(node.left) if node.right: q.append(node.right) size -= 1 ans.append(tmp[:]) return ans   Leetcode 200 Number of Islands 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  class Solution: def numIslands(self, grid: List[List[str]]) -\u0026gt; int: if not grid or len(grid) == 0: return 0 res = 0 q = deque() for i in range(0, len(grid)): for j in range(0, len(grid[0])): if grid[i][j] == \u0026#34;1\u0026#34;: res += 1 q.append([i,j]) grid[i][j] = \u0026#34;2\u0026#34; while len(q) \u0026gt; 0: [x,y] = q.popleft() if x-1 \u0026gt;= 0 and grid[x-1][y] == \u0026#34;1\u0026#34;: q.append([x-1,y]) grid[x-1][y] = \u0026#34;2\u0026#34; if x+1 \u0026lt; len(grid) and grid[x+1][y] == \u0026#34;1\u0026#34;: q.append([x+1,y]) grid[x+1][y] = \u0026#34;2\u0026#34; if y-1 \u0026gt;= 0 and grid[x][y-1] == \u0026#34;1\u0026#34;: q.append([x, y-1]) grid[x][y-1] = \u0026#34;2\u0026#34; if y+1 \u0026lt; len(grid[0]) and grid[x][y+1] == \u0026#34;1\u0026#34;: q.append([x, y+1]) grid[x][y+1] = \u0026#34;2\u0026#34; return res    Reference  手把手带你刷Leetcode力扣 - 广度优先搜索 BFS 手把手带你刷Leetcode力扣 - Leetcode 102 手把手带你刷Leetcode力扣 - Leetcode 107 手把手带你刷Leetcode力扣 - Leetcode 200 Breadth First Search in Python (with Code) | BFS Algorithm Graphs in Python: Breadth-First Search (BFS) Algorithm What is Breadth First Search?   ","date":"2022-04-06T22:36:48+08:00","permalink":"https://tonyfpy.github.io/p/algorithm-topic-7-breadth-first-search/","title":"[Algorithm] Topic 7: Breadth-First Search"},{"content":" Authored by Tony Feng\nCreated on April 5th, 2022\nLast Modified on April 5th, 2022\n Understanding DFS Intro  Depth-first search is an algorithm for traversing or searching tree or graph data structures. The algorithm starts at the root node (selecting some arbitrary node as the root node in the case of a graph) and explores as far as possible along each branch before backtracking. The time complexity of DFS if the entire tree is traversed is O(V), where V is the number of nodes; In the case of a graph, the time complexity is O(V + E), where V is the number of vertexes and E is the number of edges.  Steps of DFS  Create a recursive function that takes the index of the node and a visited array. Mark the current node as visited and print the node. Traverse all the adjacent and unmarked nodes and call the recursive function with the index of the adjacent node.   Template 1 2 3 4 5 6  def dfs(visited, graph, node): if node not in visited: print (node) visited.add(node) for neighbour in graph[node]: dfs(visited, graph, neighbour)    Examples Leetcode 78 Subsets 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  class Solution: def subsets(self, nums: List[int]) -\u0026gt; List[List[int]]: ans = [] def dfs(nums, res, index, subset): res.append(subset[:]) if index == len(nums): return for id in range(index, len(nums)): subset.append(nums[id]) dfs(nums, res, id+1, subset) subset.pop() dfs(nums, ans, 0, []) return ans   Leetcode 200 Number of Islands 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  class Solution: def numIslands(self, grid: List[List[str]]) -\u0026gt; int: def dfs(grid, i, j): if i \u0026lt; 0 or j \u0026lt; 0 or i \u0026gt;= len(grid) or j \u0026gt;= len(grid[0]) or grid[i][j] != \u0026#39;1\u0026#39;: return grid[i][j] = \u0026#39;2\u0026#39; dfs(grid, i+1, j) dfs(grid, i-1, j) dfs(grid, i, j+1) dfs(grid, i, j-1) if not grid or len(grid) == 0: return 0 count = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == \u0026#39;1\u0026#39;: dfs(grid, i, j) count += 1 return count   Leetcode 102 Binary Tree Level Order Traversal 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  class Solution: def levelOrder(self, root: Optional[TreeNode]) -\u0026gt; List[List[int]]: def dfs(node, ans, level): if not node: return if level \u0026gt; len(ans) - 1: ans.append([]) ans[level].append(node.val) if node.left: dfs(node.left, ans, level + 1) if node.right: dfs(node.right, ans, level + 1) if not root: return root ans = [] dfs(root, ans, 0) return ans    Reference  手把手带你刷Leetcode力扣 - 深度优先搜索 DFS 手把手带你刷Leetcode力扣 - Leetcode 938 手把手带你刷Leetcode力扣 - Leetcode 200 Depth First Search or DFS for a Graph Depth First Search (DFS) What is Depth First Search?   ","date":"2022-04-05T22:36:36+08:00","permalink":"https://tonyfpy.github.io/p/algorithm-topic-6-depth-first-search/","title":"[Algorithm] Topic 6: Depth-First Search"},{"content":" Authored by Tony Feng\nCreated on April 4th, 2022\nLast Modified on April 4th, 2022\n Understanding Backtracking Intro  A backtracking algorithm is a problem-solving algorithm that uses a brute-force approach for finding the desired output. The term backtracking suggests that if the current solution is not suitable, then go back and try other solutions. Backtracking uses recursion to discover all of the possibilities until we get the best end result for the problem. State Space Tree  A space state tree is a tree representing all the possible states (solution or nonsolution) of the problem from the root as an initial state to the leaf as a terminal state. In combinatorial search problems, search space is in the shape of a tree.    Types of Problems  Decision Problem: Search for a feasible solution Optimization Problem: Search for the best solution Enumeration Problem: Find all feasible soutions   Template 1 2 3 4 5 6 7 8 9 10 11  # Pseudocode function backtracking(node, state): if state is a solution: report(state) # e.g. add state to final result list return for child in children: if child is a part of a potential solution: state.add(child) # make move backtracking(child, state) state.remove(child) # backtrack    Examples Leetcode 46 Permutations 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  class Solution: def permute(self, nums: List[int]) -\u0026gt; List[List[int]]: ans = [] def backtrack(path, cnt): if cnt == 0: ans.append(path[:]) # Copy the content instead of the reference return for item in nums: if not item in path: path.append(item) backtrack(path, cnt-1) path.pop() backtrack([],len(nums)) return ans   Leetcode 77 Combinations 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  class Solution: def combine(self, n: int, k: int) -\u0026gt; List[List[int]]: ans = [] nums = list(range(1, n+1)) def backtrack(path, m): if len(path)==k: ans.append(path[:]) return for i in range(m, len(nums)): path.append(nums[i]) backtrack(path, i+1) path.pop() backtrack([],0) return ans   Leetcode 78 Subsets 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  class Solution: def subsets(self, nums: List[int]) -\u0026gt; List[List[int]]: ans = [[]] def backtrack(path, lmt, index): if len(path) == lmt: ans.append(path[:]) return for id in range(index, len(nums)): path.append(nums[id]) backtrack(path, lmt, id+1) path.pop() for i in range(1, len(nums)+1): backtrack([], i, 0) return ans   Leetcode 22 Generate Parentheses 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  class Solution: def generateParenthesis(self, n: int) -\u0026gt; List[str]: left, right = 0, 0 ans = [] def backtrack(path, l, r): if l == n and r == n: path = (\u0026#34;\u0026#34;).join(path) ans.append(path[:]) return # The number of right bracket cannot exceed that of left bracket. if l \u0026lt; r: return if l \u0026lt;= n: path.append(\u0026#34;(\u0026#34;) backtrack(path, l+1, r) path.pop() if l \u0026gt; r: path.append(\u0026#34;)\u0026#34;) backtrack(path, l, r+1) path.pop() backtrack([], left, right) return ans    Reference  手把手带你刷Leetcode力扣 - 回溯法 Backtracking 手把手带你刷Leetcode力扣 - Leetcode 22 手把手带你刷Leetcode力扣 - Leetcode 78 Backtracking in Python Backtracking Template   ","date":"2022-04-04T22:36:22+08:00","permalink":"https://tonyfpy.github.io/p/algorithm-topic-5-backtracking/","title":"[Algorithm] Topic 5: Backtracking"},{"content":" Authored by Tony Feng\nCreated on April 3rd, 2022\nLast Modified on April 3rd, 2022\n Understanding Divide \u0026amp; Conquer Intro  In computer science, divide and conquer is an algorithm design paradigm. A divide-and-conquer algorithm recursively breaks down a problem into two or more sub-problems of the same or related type, until these become simple enough to be solved directly.  Components  Divide/Break  This involves dividing the problem into smaller sub-problems.   Conquer/Solve  Solve sub-problems by calling recursively until solved.   Combine/Merge  Combine the sub-problems to get the final solution of the whole problem.    Applications  Merge Sort Quick Sort Binary Search Strassen\u0026rsquo;s Matrix Multiplication Closest pair (points)   Examples Tower of Hanoi 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  def TowerOfHanoi(n , source, destination, auxiliary): if n==1: print (\u0026#34;Move disk 1 from source\u0026#34;,source,\u0026#34;to destination\u0026#34;,destination) return TowerOfHanoi(n-1, source, auxiliary, destination) print (\u0026#34;Move disk\u0026#34;,n,\u0026#34;from source\u0026#34;,source,\u0026#34;to destination\u0026#34;,destination) TowerOfHanoi(n-1, auxiliary, destination, source) # Driver code n = 4 TowerOfHanoi(n,\u0026#39;A\u0026#39;,\u0026#39;B\u0026#39;,\u0026#39;C\u0026#39;) # A, C, B are the name of rods \u0026#39;\u0026#39;\u0026#39; Move disk 1 from source A to destination C Move disk 2 from source A to destination B Move disk 1 from source C to destination B Move disk 3 from source A to destination C Move disk 1 from source B to destination A Move disk 2 from source B to destination C Move disk 1 from source A to destination C Move disk 4 from source A to destination B Move disk 1 from source C to destination B Move disk 2 from source C to destination A Move disk 1 from source B to destination A Move disk 3 from source C to destination B Move disk 1 from source A to destination C Move disk 2 from source A to destination B Move disk 1 from source C to destination B \u0026#39;\u0026#39;\u0026#39;   Merge Sort 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49  def mergeSort(arr): if len(arr) \u0026gt; 1: # Finding the mid of the array mid = len(arr)//2 # Dividing the array elements into 2 halves L = arr[:mid] R = arr[mid:] # Sort mergeSort(L) mergeSort(R) i = j = k = 0 # Copy data to temp arrays L[] and R[] while i \u0026lt; len(L) and j \u0026lt; len(R): if L[i] \u0026lt; R[j]: arr[k] = L[i] i += 1 else: arr[k] = R[j] j += 1 k += 1 # Checking if any element was left while i \u0026lt; len(L): arr[k] = L[i] i += 1 k += 1 while j \u0026lt; len(R): arr[k] = R[j] j += 1 k += 1 # Code to print the list def printList(arr): for i in range(len(arr)): print(arr[i], end=\u0026#34; \u0026#34;) print() # Driver Code if __name__ == \u0026#39;__main__\u0026#39;: arr = [12, 11, 13, 5, 6, 7] print(\u0026#34;Given array is\u0026#34;, end=\u0026#34;\\n\u0026#34;) printList(arr) mergeSort(arr) print(\u0026#34;Sorted array is: \u0026#34;, end=\u0026#34;\\n\u0026#34;) printList(arr)    Reference  手把手带你刷Leetcode力扣 - 分治法 Divide \u0026amp; Conquer Programiz - Divide \u0026amp; Conquer GreekforGreek - Merge Sort GreekforGreek - Python Program for Tower of Hanoi   ","date":"2022-04-03T22:30:30+08:00","permalink":"https://tonyfpy.github.io/p/algorithm-topic-4-divide-conquer/","title":"[Algorithm] Topic 4: Divide \u0026 Conquer"},{"content":" Authored by Tony Feng\nCreated on April 2nd, 2022\nLast Modified on April 2nd, 2022\n Understanding Recursion Intro  Recursion is the process of defining a problem (or the solution to a problem) in terms of (a simpler version of) itself. Memoization could be used to save computational time.  Components of Recursion  Base Case  The point where you stop applying the recursive case   Recursive Steps  Divide the problem into one or more simpler or smaller parts of the problem; Call the function (recursively) on each part; Combine the solutions of the parts into a solution for the problem.    Characteristics  Advantages of Recursion  Recursive functions make the code look clean and elegant. A complex task can be broken down into simpler sub-problems using recursion. Sequence generation is easier with recursion than using some nested iteration.   Disadvantages of Recursion  Sometimes the logic behind recursion is hard to follow through. Recursive calls are expensive (inefficient) as they take up a lot of memory and time. Recursive functions are hard to debug.     Examples The Factorial of an Integer 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  term = [0 for i in range(10)] # Memoization # Fibonacci Series using memoized Recursion def fib(n): # base case if n \u0026lt;= 1: return n # if fib(n) has already been computed we do not do further  # recursive calls and hence reduce the number of repeated work; # else store the computed value of fib(n) in an array term at # index n if term[n] != 0: return term[n] else: term[n] = fib(n - 1) + fib(n - 2) return term[n]   Leetcode 509 Fibonacci Number 1 2 3 4 5 6 7 8  # Time: O(N) # Space: O(N) i.e. Recursive Stack class Solution: def fib(self, n: int) -\u0026gt; int: if n \u0026lt;= 1: return n return self.fib(n - 1) + self.fib(n - 2)   Leetcode 206 Reverse Linked List 1 2 3 4 5 6 7 8 9 10  class Solution: def reverseList(self, head: Optional[ListNode]) -\u0026gt; Optional[ListNode]: if not head or not head.next: return head node = self.reverseList(head.next) head.next.next = head head.next = None return node    Reference  手把手带你刷Leetcode力扣 - 递归 Recursion 手把手带你刷Leetcode力扣 - 力扣509 手把手带你刷Leetcode力扣 - 力扣206 Programiz - Python Recursion WTF is Memoization   ","date":"2022-04-02T23:49:58+08:00","permalink":"https://tonyfpy.github.io/p/algorithm-topic-3-recursion/","title":"[Algorithm] Topic 3: Recursion"},{"content":" Authored by Tony Feng\nCreated on April 1st, 2022\nLast Modified on April 1st, 2022\n Understanding Binary Search Intro  Binary search is often used to efficiently locate an item in a sorted sequence of items. It divides the search space in 2 after every comparison. Compared to linear search which requires O(N) running time, binary search only takes O(log N) where n is the size of the sequence.  Main Steps of the Algorithm  Pre-processing  Sort if collection is unsorted.   Binary Search  Using a loop or recursion to divide search space in half after each comparison.   Post-processing  Determine viable candidates in the remaining space    When Do We Use Binary Search?  The array is partially or fully sorted. The upper bound of time complexity is O(N) or O(log N).   Templates  There are many variants of binary search, such as [l, r), [l, r], (l, r], etc. We should be careful of loop condition, mid/left/right update and return value.\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  # The most common case class Solution: def binarySearch(self, nums, target): \u0026#34;\u0026#34;\u0026#34; :type nums: List[int] :type target: int :rtype: int \u0026#34;\u0026#34;\u0026#34; if len(nums) == 0: return -1 left, right = 0, len(nums) - 1 while left \u0026lt;= right: mid = left + (right - left) // 2 # Avoid overflow if nums[mid] \u0026lt; target: left = mid + 1 elif nums[mid] \u0026gt; target: right = mid - 1 else: return mid # End Condition: left \u0026gt; right return -1    Examples Leetcode 704 Binary Search 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  class Solution: def search(self, nums: List[int], target: int) -\u0026gt; int: if not nums or len(nums) == 0: return -1 l, r = 0, len(nums)-1 while l \u0026lt;= r: m = l + (r - l) // 2 if nums[m] \u0026gt; target: r = m - 1 elif nums[m] \u0026lt; target: l = m + 1 else: return m return -1   Leetcode 35 Search Insert Position 1 2 3 4 5 6 7 8 9 10 11 12  class Solution: def searchInsert(self, nums: List[int], target: int) -\u0026gt; int: l, r = 0, len(nums)-1 while l \u0026lt; r: # break if l == r mid = l + (r - l) // 2 if nums[mid] \u0026lt; target: l = mid + 1 elif nums[mid] \u0026gt; target: r = mid - 1 else: return mid return l if target \u0026lt;= nums[l] else l + 1   Leetcode 162 Find Peak Element 1 2 3 4 5 6 7 8 9 10  class Solution: def findPeakElement(self, nums: List[int]) -\u0026gt; int: l, r = 0, len(nums)-1 while l \u0026lt; r: m = l + (r - l) // 2 if nums[m] \u0026gt; nums[m+1]: r = m else: l = m + 1 return l   Leetcode 74 Search a 2D Matrix 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  class Solution: def searchMatrix(self, matrix: List[List[int]], target: int) -\u0026gt; bool: nums = [] for nums in matrix: if nums[-1] \u0026gt;= target: # Find which row the target is in l, r = 0, len(nums)-1 while l \u0026lt;= r: mid = l + (r - l) // 2 if nums[mid] \u0026lt; target: l = mid + 1 elif nums[mid] \u0026gt; target: r = mid - 1 else: return True return False    Reference  手把手带你刷Leetcode力扣 - 二分查找 Binary Search 手把手带你刷Leetcode力扣 - 力扣705 手把手带你刷Leetcode力扣 - 力扣35 手把手带你刷Leetcode力扣 - 力扣162 手把手带你刷Leetcode力扣 - 力扣74 Collection of Binary Search Templates   ","date":"2022-04-01T22:36:50+08:00","permalink":"https://tonyfpy.github.io/p/algorithm-topic-2-binary-search/","title":"[Algorithm] Topic 2: Binary Search"},{"content":" Authored by Tony Feng\nCreated on March 30th, 2022\nLast Modified on March 30th, 2022\n Understanding Two-pointer Algorithm Intro  The approach optimizes the runtime by utilizing some order (not necessarily sorting) of the data. It is generally applied on lists (arrays) and linked lists. Here, pointers represent either index or an iteration attribute like node’s Next.  Main Steps of the Algorithm  Pointer Initialization Pointer Movement Stop Condition  Categories  Old \u0026amp; New State Pointers Slow \u0026amp; Fast Pointers Left \u0026amp; Right Pointers Pointers from Two Sequences Sliding Window   Old \u0026amp; New State Pointers Template 1 2 3 4 5 6 7  class Solution: def old_new_state(self, arr): # initialize states old, new = default_val1, default_val2 for item in arr: # process current element with old state old, new = new, self.some_func(item, old)   Examples Leetcode 509 Fibonacci Number 1 2 3 4 5 6 7  # Each number is the sum of the two preceding ones, starting from 0 and 1. class Solution: def fibonacci(self, n: int) -\u0026gt; int: a, b = 0, 1 for i in range(n + 1): a, b = b, a + b return a   Leetcode 198 House Robber 1 2 3 4 5 6 7 8  # Determine the maximum amount of money you can steal tonight  # without robbing adjacent houses. class Solution: def rob(self, nums: \u0026#39;List[int]\u0026#39;) -\u0026gt; int: last, now = 0, 0 for i in nums: last, now = now, max(last + i, now) return now    Slow \u0026amp; Fast Pointers Template 1 2 3 4 5 6 7 8 9 10 11 12 13  class Solution: def slow_fast_runner(self, arr): # initialize slow runner slow = arr[0] # fast-runner grows each iteration generally for fast in range(arr): #slow-runner grows with some restrictions if self.slow_condition(slow): slow = slow.next # slow += 1 # process logic before or after pointers movement self.some_func(slow, fast)   Examples Leetcode 141 Linked List Cycle 1 2 3 4 5 6 7 8 9 10 11 12  class Solution: def hasCycle(self, head: Optional[ListNode]) -\u0026gt; bool: if not head or not head.next: return False slow, fast = head, head while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: return True return False   Leetcode 881 Boats to Save People 1 2 3 4 5 6 7 8 9 10 11  class Solution: def numRescueBoats(self, people: List[int], limit: int) -\u0026gt; int: people = sorted(people) i, j, res = 0, len(people)-1, 0 while i \u0026lt;= j: if people[i] + people[j] \u0026lt;= limit: i = i + 1 j = j - 1 res += 1 return res   Leetcode 26 Remove Duplicates from Sorted Array 1 2 3 4 5 6 7 8 9 10 11 12 13  # Given a sorted array nums, remove the duplicates in place such that  # each element appear only once and return the new length. class Solution: def removeDuplicates(self, nums: \u0026#39;List[int]\u0026#39;) -\u0026gt; int: if not nums: return 0 slow = 0 for fast in range(1, len(nums)): # if current element is not duplicate,  # slow runner grows one step and copys the current value if nums[slow] != nums[fast]: slow += 1 nums[slow] = nums[fast] return slow + 1    Left \u0026amp; Right Pointers Template 1 2 3 4 5 6 7 8 9 10 11 12  class Solution: def left_right_boundary(self, arr): left, right = 0, len(arr) - 1 while left \u0026lt; right: # left index moves when satisfy the condition if self.left_condition(left): left += 1 # right index move when satisfy the condition if self.right_condition(right): right -= 1 # process logic before or after pointers movement self.some_func(left, right)   Examples Leetcode 167 Two Sum II - Input Array Is Sorted 1 2 3 4 5 6 7 8 9 10 11 12 13  # Given an array of integers that is already sorted in ascending  # order, find two numbers such that they add up to a specific target number. class Solution: def twoSum(self, numbers: \u0026#39;List[int]\u0026#39;, target: \u0026#39;int\u0026#39;) -\u0026gt; \u0026#39;List[int]\u0026#39;: left, right = 0, len(numbers) - 1 while left \u0026lt; right: if numbers[left] + numbers[right] == target: return [left + 1, right + 1] if numbers[left] + numbers[right] \u0026lt; target: left += 1 else: right -= 1 return [0, 0]    Pointers from Two Sequences Template 1 2 3 4 5 6 7 8 9 10 11 12 13 14  class Solution: def pointers_from_two_seq(self, arr1, arr2): # init pointers p1, p2 = 0, 0 # or seq1[0], seq2[0] while p1 \u0026lt; len(arr1) and p2 \u0026lt; len(arr2): # or other condition # p1 index moves when satisfy the condition if self.p1_condition(p1): p1 += 1 # or p1 = next(seq1) # p2 index move when satisfy the condition if self.p2_condition(p2): p2 += 1 # or p2 = next(seq2) # process logic before or after pointers movement self.some_func(p1, p2)   Examples Leetcode 244 Shortest Word Distance II 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  # Design a class which receives a list of words in the constructor  # and implements a method that takes two words, word1 and word2, and  # returns the shortest distance between these two words in the list. class WordDistance: def __init__(self, words: \u0026#39;List[str]\u0026#39;): self.locations = defaultdict(list) # Prepare a mapping from a word to all it\u0026#39;s locations (indices). for i, w in enumerate(words): self.locations[w].append(i) def shortest(self, word1: str, word2: str) -\u0026gt; int: loc1, loc2 = self.locations[word1], self.locations[word2] l1, l2 = 0, 0 min_diff = float(\u0026#34;inf\u0026#34;) # Until the shorter of the two lists is processed while l1 \u0026lt; len(loc1) and l2 \u0026lt; len(loc2): min_diff = min(min_diff, abs(loc1[l1] - loc2[l2])) if loc1[l1] \u0026lt; loc2[l2]: l1 += 1 else: l2 += 1 return min_diff    Sliding Window  There are two types of window\n  The fixed size window can be used for problem where you want to determine whether given string contain a specific substring.\n  The dynamic one can be used to find the longest or shortest substring of the given string.\n   Template 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  class Solution: def sliding_window(self, arr): start, end = 0, 0 while end \u0026lt; len(arr): # end pointer grows in the outer loop end += 1 # start pointer grows with some restrict while self.start_condition(start): # process logic before pointers movement self.some_func(start, end) # start grows in the inner loop start += 1 # or process logic after pointers movement self.some_func(start, end)   Examples Leetcode 209 Minimum Size Subarray Sum 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  # Given an array of positive integers nums and a positive integer  # target, return the minimal length of a contiguous subarray of  # which the sum is greater than or equal to target. class Solution: def minSubArrayLen(self, target: int, nums: List[int]) -\u0026gt; int: if not nums or len(nums) == 0: return 0 l, r = 0, 0 res = len(nums) + 1 add = 0 while r \u0026lt; len(nums): add += nums[r] r += 1 # Upsizing the window while add \u0026gt;= target: # Downsizing the window iteratively res = min(res, r - l) add -= nums[l] l += 1 return res if res != len(nums) + 1 else 0   Leetcode 1456 Maximum Number of Vowels in a Substring of Given Length 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  # Given a string s and an integer k, return the maximum number of vowel  # letters in any substring of s with length k. class Solution: def maxVowels(self, s: str, k: int) -\u0026gt; int: if not s or len(s) == 0 or len(s) \u0026lt; k: return 0 vl = set([\u0026#39;a\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;i\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;u\u0026#39;]) # Quick for search i, j = 0, 0 res, tmp = 0, 0 while j \u0026lt; len(s): if j - i \u0026lt; k: # Get the number of vowel letters in the first sliding window if s[j] in vl: tmp += 1 res = tmp j += 1 else: # Pop the first item if s[i] in vl: tmp -= 1 i += 1 # Add the next item if s[j] in vl: tmp += 1 res = max(tmp, res) j += 1 return res    Reference  手把手带你刷Leetcode力扣 - 双指针 Two Pointers 手把手带你刷Leetcode力扣 - 力扣141 手把手带你刷Leetcode力扣 - 力扣881 手把手带你刷Leetcode力扣 - 滑动窗口 Sliding Window 手把手带你刷Leetcode力扣 - 力扣209 手把手带你刷Leetcode力扣 - 力扣1456 Two Pointers Approach — Python Code Algorithm Templates: Two Pointers - Part 1 Algorithm Templates: Two Pointers - Part 2 Algorithm Templates: Two Pointers - Part 3 Effective LeetCode: Understanding the Sliding Window Pattern   ","date":"2022-03-30T22:59:15+08:00","permalink":"https://tonyfpy.github.io/p/algorithm-topic-1-two-pointers/","title":"[Algorithm] Topic 1: Two Pointers"},{"content":" Authored by Tony Feng\nCreated on March 29th, 2022\nLast Modified on March 29th, 2022\n Understanding Graphs Main Concepts  A Graph is a non-linear data structure consisting of nodes and edges. The nodes are sometimes also referred to as vertices. The edges are lines or arcs that connect any two nodes in the graph. Representations of Graphs G(V,E)  A collection of vertices V A collection of edges E, represented as ordered pairs of vertices (p,q)    Graph Classifications  Directed Graphs Undirected Graphs Weighted Graphs  Graph Terminology  Adjacency  A vertex is said to be adjacent to another vertex if there is an edge connecting them.   Path  A sequence of edges that allows you to go from vertex A to vertex B is called a path.    Operations  Check if the element is present in the graph Graph Traversal Add elements(vertex, edges) to graph Finding the path from one vertex to another   Implementations  This part will be dicussed when solving the problem.\n  Reference  GreeksforGreeks - Graph Data Structure And Algorithms Graph Data Stucture 手把手带你刷Leetcode力扣 - 图 Graph   ","date":"2022-03-29T22:38:32+08:00","permalink":"https://tonyfpy.github.io/p/data-structure-topic-10-graph/","title":"[Data Structure] Topic 10: Graph"},{"content":" Authored by Tony Feng\nCreated on March 28th, 2022\nLast Modified on March 28th, 2022\n Understanding Heaps Main Concepts  Heaps are complete binary trees. Complete binary trees satisfy the following conditions:  All levels are filled, except the last. All the nodes are as far left as possible.   The root of every subtree should be the greatest or smallest element in the subtree, recursively.  Minheap: The root of every subtree is the smallest element. Maxheap: The root of every subtree is the largest element.   Heapify: From an array to a heap, the solution is unique and the time complexity is O(N). (Formal Proof)  Applications of Heaps  Priority Queues  The root of a heap always contains the maximum or the minimum value, based on the heap type. The element with the highest/lowest priority can be retrieved in O(1) time.   Statistics  If we want the kth smallest or largest element, we can pop the heap k times to retrieve them.   Graph Algorithms  e.g. Dijkstra’s algorithm, Prim’s algorithm.    Operations  Search  For the top of heap, it\u0026rsquo;s O(1) The rest are O(N)   Insert - O(log(N)) Delete - O(log(N))  Explanations     Set Implementation in Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  import heapq # Create a minheap minheap = [] heapq.heapify(minheap) # In Python, there is no maxheap. If maxheap is required,  # try to multiply each element with -1 and then heapify it. # In the operations, the value should be converted back. # Add elements heapq.heappush(minheap, 10) heapq.heappush(minheap, 8) heapq.heappush(minheap, 9) heapq.heappush(minheap, 2) heapq.heappush(minheap, 1) heapq.heappush(minheap, 11) # [1,2,9,10,8,11] # Peek print(minheap[0]) # Delete heapq.heappop(minheap) # Size len(minheap) # Iteration while len(minheap) != 0: print(heapq.heappop(minheap))    Set Implementation in Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  // Create PriorityQueue\u0026lt;Integer\u0026gt; minheap = new PriorityQueue\u0026lt;\u0026gt;(); PriorityQueue\u0026lt;Integer\u0026gt; maxheap = new PriorityQueue\u0026lt;\u0026gt;(Collections.reverseOrder()); // Add minheap.add(2); maxheap.add(3); // Peek int mi = minheap.peek(); int ma = maxheap.peek(); // Remove the top element int mi = minheap.poll(); int ma = maxheap.poll(); // Get the size of the heap int lenMin = minheap.size(); int lenMax = maxheap.size(); // Iteration while (!minheap.isEmpty()) { System.out.println(minheap.poll()); }    Reference  Using the Heap Data Structure in Python 堆删除操作逻辑 GreeksforGreeks - Time Complexity of building a heap 手把手带你刷Leetcode力扣 - 集合 Set 手把手带你刷Leetcode力扣 - Python3集合常用操作 手把手带你刷Leetcode力扣 - Java集合常用操作   ","date":"2022-03-28T22:38:21+08:00","permalink":"https://tonyfpy.github.io/p/data-structure-topic-9-heap/","title":"[Data Structure] Topic 9: Heap"},{"content":" Authored by Tony Feng\nCreated on March 27th, 2022\nLast Modified on March 28th, 2022\n Understanding Trees Main Concepts  A tree is non-linear and a hierarchical data structure. It consists of a collection of nodes such that each node of the tree stores a value and a list of references to their children. Different tree data structures allow quicker and easier access to the data as it is a non-linear data structure.  Tree Terminologies    Term Explanation     Node 1. A node is an entity that contains a key or value and pointers to its child nodes.  2. Root is the topmost node of a tree.  3. The last nodes of each path are called leaf nodes or external nodes that do not contain a link/pointer to child nodes.  4. The node having at least a child node is called an internal node.  5. The node which is a predecessor of a node is called the parent node of that node.  6. The node which is the immediate successor of a node is called the child node of that node.  7. Any predecessor nodes on the path of the root to that node are called Ancestors of that node.  8. Any successor node on the path from the leaf node to that node are the descendants of the node.  9. Children of the same parent node are called siblings.   Edge It is the link between any two nodes.   Depth of a Node The depth of a node is the number of edges from the node to the tree\u0026rsquo;s root node (from bottom to top).   Height of a Node 1. The number of edges on the longest path from that node to a leaf (from top to bottom).  2. The height of a Tree is the height of the root node or the depth of the deepest node.   Level of a node 1. The level of a node is defined by 1 + the number of connections between the node and the root.  2. The level of the root is 1.   Degree of a Node It is the total count of subtrees attached to that node.    Binary Trees  Classifications  Full/ proper/ strict Binary tree  It can be defined as the tree in which each node must contain 2 children except the leaf nodes.   Complete Binary tree  It is a tree in which all the nodes are completely filled except the last level. In the last level, all the nodes must be as left as possible.   Perfect Binary tree  A tree is a perfect binary tree if all the internal nodes have 2 children. All the leaf nodes are at the same level.   Degenerate Binary tree  It is a tree in which all the internal nodes have only one children.   Balanced Binary tree  The tree, also referred to as a height-balanced binary tree, is defined as a binary tree in which the height of the left and right subtree of any node differ by not more than 1.     Traverse  Preorder traverse  Visit root node Visit all the nodes in the left subtree Visit all the nodes in the right subtree   Inorder traverse  First, visit all the nodes in the left subtree Then the root node Visit all the nodes in the right subtree   Postorder traverse  Visit all the nodes in the left subtree Visit all the nodes in the right subtree Visit the root node       Set Implementation in Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179  # Binary search tree class binarySearchTree: def __init__(self,val=None): self.val = val self.left = None self.right = None def insert(self,val): # check if there is no root if (self.val == None): self.val = val # check where to insert else: # check for duplicate then stop and return if val == self.val: return \u0026#39;no duplicates allowed in binary search tree\u0026#39; # check if value to be inserted \u0026lt; currentNode\u0026#39;s value if (val \u0026lt; self.val): # check if there is a left node to currentNode if true then recurse if(self.left): self.left.insert(val) # insert where left of currentNode when currentNode.left=None else: self.left = binarySearchTree(val) # same steps as above here the condition we check is value to be inserted \u0026gt; currentNode\u0026#39;s value else: if(self.right): self.right.insert(val) else: self.right = binarySearchTree(val) def breadthFirstSearch(self): currentNode = self bfs_list = [] queue = [] queue.insert(0,currentNode) while(len(queue) \u0026gt; 0): currentNode = queue.pop() bfs_list.append(currentNode.val) if(currentNode.left): queue.insert(0,currentNode.left) if(currentNode.right): queue.insert(0,currentNode.right) return bfs_list # In order means first left child, then parent, at last right child def depthFirstSearch_INorder(self): return self.traverseInOrder([]) # Pre order means first parent, then left child, at last right child def depthFirstSearch_PREorder(self): return self.traversePreOrder([]) # Post order means first left child, then right child , at last parent def depthFirstSearch_POSTorder(self): return self.traversePostOrder([]) def traverseInOrder(self, lst): if (self.left): self.left.traverseInOrder(lst) lst.append(self.val) if (self.right): self.right.traverseInOrder(lst) return lst def traversePreOrder(self, lst): lst.append(self.val) if (self.left): self.left.traversePreOrder(lst) if (self.right): self.right.traversePreOrder(lst) return lst def traversePostOrder(self, lst): if (self.left): self.left.traversePostOrder(lst) if (self.right): self.right.traversePostOrder(lst) lst.append(self.val) return lst def findNodeAndItsParent(self,val, parent = None): # returning the node and its parent so we can delete the node and reconstruct the tree from its parent if val == self.val: return self, parent if (val \u0026lt; self.val): if (self.left): return self.left.findNodeAndItsParent(val, self) else: return \u0026#39;Not found\u0026#39; else: if (self.right): return self.right.findNodeAndItsParent(val, self) else: return \u0026#39;Not found\u0026#39; # deleteing a node means we have to rearrange some part of the tree def delete(self,val): # check if the value we want to delete is in the tree if(self.findNodeAndItsParent(val)==\u0026#39;Not found\u0026#39;): return \u0026#39;Node is not in tree\u0026#39; # we get the node we want to delete and its parent-node from findNodeAndItsParent method deleteing_node, parent_node = self.findNodeAndItsParent(val) # check how many children nodes does the node we are going to delete have by traversePreOrder from the deleteing_node nodes_effected = deleteing_node.traversePreOrder([]) # if len(nodes_effected)==1 means, the node to be deleted doesn\u0026#39;t have any children # so we can just check from its parent node the position(left or right) of node we want to delete # and point the position to \u0026#39;None\u0026#39; i.e node is deleted if (len(nodes_effected)==1): if (parent_node.left.val == deleteing_node.val) : parent_node.left = None else: parent_node.right = None return \u0026#39;Succesfully deleted\u0026#39; # if len(nodes_effected) \u0026gt; 1 which means the node we are going to delete has \u0026#39;children\u0026#39;, # so the tree must be rearranged from the deleteing_node else: # if the node we want to delete doesn\u0026#39;t have any parent means the node to be deleted is \u0026#39;root\u0026#39; node if (parent_node == None): nodes_effected.remove(deleteing_node.val) # make the \u0026#39;root\u0026#39; nodee i.e self value,left,right to None, # this means we need to implement a new tree again without the delted node self.left = None self.right = None self.val = None # construction of new tree for node in nodes_effected: self.insert(node) return \u0026#39;Succesfully deleted\u0026#39; # if the node we want to delete has a parent # traverse from parent_node nodes_effected = parent_node.traversePreOrder([]) # deleting the node if (parent_node.left == deleteing_node) : parent_node.left = None else: parent_node.right = None # removeing the parent_node, deleteing_node and inserting the nodes_effected in the tree nodes_effected.remove(deleteing_node.val) nodes_effected.remove(parent_node.val) for node in nodes_effected: self.insert(node) return \u0026#39;Successfully deleted\u0026#39; bst = binarySearchTree() bst.insert(7) bst.insert(4) bst.insert(9) bst.insert(0) bst.insert(5) bst.insert(8) bst.insert(13) # 7 # / \\ # / \\ # 4 9 # / \\ / \\ # 0 5 8 13 print(\u0026#39;IN order: \u0026#39;,bst.depthFirstSearch_INorder()) # useful in sorting the tree in ascending order print(\u0026#39;PRE order:\u0026#39; ,bst.depthFirstSearch_PREorder()) # pre order is useful in reconstructing a tree print(\u0026#39;POST order:\u0026#39;, bst.depthFirstSearch_POSTorder()) # useful in finding the leaf nodes print(bst.delete(5)) print(bst.delete(9)) print(bst.delete(7)) # after deleting print(\u0026#39;IN order: \u0026#39;,bst.depthFirstSearch_INorder()) \u0026#39;\u0026#39;\u0026#39; Output IN order: [0, 4, 5, 7, 8, 9, 13] PRE order: [7, 4, 0, 5, 9, 8, 13] POST order: [0, 5, 4, 8, 13, 9, 7] Successfully deleted Successfully deleted Successfully deleted IN order: [0, 4, 8, 13] \u0026#39;\u0026#39;\u0026#39;    Reference  GreeksforGreeks - Intro to Tree Data Structure Height, Depth and Level of a Tree Programiz - Balanced Binary Tree Binary tree and BinarySearch tree implementation in Python 手把手带你刷Leetcode力扣 - 树 Tree 手把手带你刷Leetcode力扣 - 树 Tree 补充   ","date":"2022-03-27T22:38:11+08:00","permalink":"https://tonyfpy.github.io/p/data-structure-topic-8-tree/","title":"[Data Structure] Topic 8: Tree"},{"content":" Authored by Tony Feng\nCreated on March 27th, 2022\nLast Modified on March 27th, 2022\n Understanding Sets Main Concepts  A Set is an unordered collection data type that is iterable, mutable and has no duplicate elements. The major advantage of using a set, as opposed to a list, is that it has a highly optimized method for checking whether a specific element is contained in the set or whether some elements are repeated. This is based on a data structure known as hash table. Since sets are unordered, we cannot access items using indexes.  Main Characteristics  Unordered Unchangeable Unindexed  Operations  Search  Collision - O(K) No Collision - O(1)   Insert - O(1)  Collision - O(K) No Collision - O(1)   Delete - O(1)  Collision - O(K) No Collision - O(1)     Set Implementation in Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  # Create a set s = set() # Add an element - O(1) s.add(2) s.add(3) s.add(1) # Remove an element - O(1) s.remove(2) # Check if the value exists - O(1) 1 in s # Get the length of the set len(s)    Set Implementation in Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  // Create HashSet\u0026lt;Integer, String\u0026gt; s = new HashSet\u0026lt;\u0026gt;(); // Add - O(1) s.add(2); s.add(3); s.add(1); // Remove an element - O(1) s.remove(1); // arg is the value  // Check if the value exists - O(1) Boolean check = s.contains(2); // Get the length of the hash table - O(1) int len = s.size()    Reference  GreeksforGreeks - Sets in Python 手把手带你刷Leetcode力扣 - 集合 Set 手把手带你刷Leetcode力扣 - Python3集合常用操作 手把手带你刷Leetcode力扣 - Java集合常用操作   ","date":"2022-03-27T22:38:02+08:00","permalink":"https://tonyfpy.github.io/p/data-structure-topic-7-set/","title":"[Data Structure] Topic 7: Set"},{"content":" Authored by Tony Feng\nCreated on March 26th, 2022\nLast Modified on March 26th, 2022\n Understanding Hash Tables Main Concepts  Hash Table stores data in an associative manner. In programming languages, each key is assigned to a memory address by a hash function. The key-value pair is stored in this memory address. Hashing is a technique to convert a range of key values into a range of indexes of an array. Collision occur when two pieces of data in a hash table share the same hash value. Collisions are pretty difficult to avoid and are bound to happen, so the key to a good hash function is collision resolution. (Linked list could be a good solution.)  Main Characteristics  In a hash table, data is stored using a key-value storage method. Access of data becomes very fast if we know the index of the desired data.  Operations  Search - O(1)  If hash collision happens, O(K), where K is number of collisions.   Insert - O(1) Delete - O(1)   Hash Table Implementation in Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  # Create a hash table by Dictionary D = {} # Add an element - O(1) D[1], D[2], D[3] = \u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;d\u0026#34; # Update an element - O(1) D[3] = \u0026#34;c\u0026#34; # Remove an element - O(1) D.pop(1) # arg is the key # del D[1] # Get the value - O(1) D[2] # Check if the key exists - O(1) b in D # Get the length of the hash table len(D) # Traverse my_dict={\u0026#39;Dave\u0026#39; : \u0026#39;001\u0026#39; , \u0026#39;Ava\u0026#39;: \u0026#39;002\u0026#39; , \u0026#39;Joe\u0026#39;: \u0026#39;003\u0026#39;} for k in my_dict: print(k) #prints the keys for v in my_dict.values(): print(v) #prints values for k,v in my_dict.items(): print(k, \u0026#34;:\u0026#34; , v) #prints keys and values    Hash Table Implementation in Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  // Create HashMap\u0026lt;Integer, String\u0026gt; m = new HashMap\u0026lt;\u0026gt;(); // Add - O(1) m.put(1, \u0026#34;alpha\u0026#34;); m.put(2, \u0026#34;b\u0026#34;); m.put(3, \u0026#34;c\u0026#34;); // Update an element - O(1) m.put(1, \u0026#34;a\u0026#34;); // Remove an element - O(1) m.remove(1); // arg is the key  // Get the value - O(1) String tmp = m.get(2); // arg is the key  // Check if the key exists - O(1) Boolean check = m.containsKey(2); // Get the length of the hash table int s = m.size()    Reference  手把手带你刷Leetcode力扣 - 哈希表 Hash Table 手把手带你刷Leetcode力扣 - Python3哈希表常用操作 手把手带你刷Leetcode力扣 - Java哈希表常用操作   ","date":"2022-03-26T22:37:51+08:00","permalink":"https://tonyfpy.github.io/p/data-structure-topic-6-hash-table/","title":"[Data Structure] Topic 6: Hash Table"},{"content":" Authored by Tony Feng\nCreated on March 24th, 2022\nLast Modified on March 25th, 2022\n Understanding Stacks Main Concepts  Stack is an abstract data structure that is similar to queue. Unlike queues, a stack is open at one end. First In Last Out (FILO) e.g. Back functionanlity of browsers  Operations  Access - O(1)  Access the top of the stack   Search - O(N) Insert - O(1)  A stack can only be inserted from the top.   Delete - O(1)  A stack can only be removed from the top.     Stack Implementation in Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  # Create stack = [] # Add an element - O(1) stack.append(1) stack.append(2) stack.append(3) # [1,2,3] # Get the top of the stack - O(1) top = stack[-1] # Remove the head of the stack - O(1) top = stack.pop() # Get the size of the stack - O(1) length = len(stack) # Traverse the stack - O(N) while len(stack) != 0: tmp = stack.pop() print(tmp)    Stack Implementation in Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  // Create Stack\u0026lt;Integer\u0026gt; s = new Stack\u0026lt;\u0026gt;(); // Add - O(1) s.push(1); s.push(2); s.push(3); // Get the head of the stack - O(1) int elem = s.peek(); // 1  // Remove the head of the stack - O(1) int id = s.pop(); // 1  // Get the size of the stack - O(1) int len = s.size() // Traverse the stack - O(N) while (!s.isEmpty()) { int tmp = s.pop() System.out.println(tmp) }    Reference  手把手带你刷Leetcode力扣 - 栈 Stack 手把手带你刷Leetcode力扣 - Python3栈常用操作 手把手带你刷Leetcode力扣 - Java栈常用操作   ","date":"2022-03-24T22:37:38+08:00","permalink":"https://tonyfpy.github.io/p/data-structure-topic-5-stack/","title":"[Data Structure] Topic 5: Stack"},{"content":" Authored by Tony Feng\nCreated on March 22nd, 2022\nLast Modified on March 23rd, 2022\n Understanding Queues Main Concepts  Queue is an abstract data structure that is similar to stacks. Unlike stacks, a queue is open at both ends. First In First Out (FIFO)  Different Types  Singly-ended Queue (All queues mentioned in this file are this type.) Doubly-ended Queue  Operations  Access - O(N) Search - O(N) Insert - O(1)  A queue can only be inserted from the rear.   Delete - O(1)  A queue can only be removed from the front.     Queue Implementation in Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  # Create queue = deque() # Add an element - O(1) queue.append(1) queue.append(2) queue.append(3) # [1,2,3] # Get the head of the queue - O(1) head = queue[0] # Remove the head of the queue - O(1) head = queue.popleft() # Get the size of the queue - O(1) length = len(queue) # Traverse the queue - O(N) while len(queue) != 0: tmp = queue.popleft() print(tmp)    Queue Implementation in Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  // Create Queue\u0026lt;Integer\u0026gt; q = new LinkedList\u0026lt;\u0026gt;(); // Add - O(1) q.add(1); q.add(2); q.add(3); // Get the head of the queue - O(1) int elem = q.peek(); // 1  // Remove the head of the queue - O(1) int id = q.poll(); // 1  // Get the size of the queue - O(1) int len = q.size() // Traverse the queue - O(N) while (!q.isEmpty()) { int tmp = q.poll() System.out.println(tmp) }    Reference  手把手带你刷Leetcode力扣 - 队列 Queue 手把手带你刷Leetcode力扣 - Python3队列常用操作 手把手带你刷Leetcode力扣 - Java队列常用操作   ","date":"2022-03-22T22:37:28+08:00","permalink":"https://tonyfpy.github.io/p/data-structure-topic-4-queue/","title":"[Data Structure] Topic 4: Queue"},{"content":" Authored by Tony Feng\nCreated on March 20th, 2022\nLast Modified on March 21st, 2022\n Understanding Linked Lists Main Concepts  Linked lists are an ordered collection of objects. While other lists use a contiguous memory block to store references to their data, linked lists store references as part of their elements. Node = Data + Next  A value A reference to the next node   The first node of a linked list is called Head. The last node must have its Next pointing to None.  Different Types  Singly Linked Lists (All linked lists mentioned in this file are this type.) Doubly Linked Lists Circular Linked Lists  Operations  Access - O(N) Search - O(N) Insert - O(1)  Commonly, a function of insertion contains traverse and add, which is O(N).   Delete - O(1)  Applications  Queues - FIFO Stacks - LIFO Graphs  Linked List V.S. Array     Linked List Arrays     Pros 1. Dynamic Size  2. Ease of insertion/deletion 1. Fast access to elements  2. Linear data of similar types could be stored   Cons 1. More memory needed  2. Random access is not allowed  3. Not cache friendly 1. Fixed size  2. Slow insertion/deletion  3. Waste of memory     Linked List Implementation in Python Using collections.deque in Python 1 2 3 4 5 6 7 8 9 10 11  from collections import deque queue = deque() queue.append(\u0026#34;Mary\u0026#34;) # O(1) queue.append(\u0026#34;John\u0026#34;) queue.append(\u0026#34;Susan\u0026#34;) # deque([\u0026#39;Mary\u0026#39;, \u0026#39;John\u0026#39;, \u0026#39;Susan\u0026#39;]) queue.popleft() # deque([\u0026#39;John\u0026#39;, \u0026#39;Susan\u0026#39;]) history = deque() history.appendleft(1) history.appendleft(2) history.appendleft(3) # deque([3,2,1])   Creating a linked list from scratch in Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89  \u0026#39;\u0026#39;\u0026#39; def __init__(self, nodes=None): self.head = None if nodes is not None: node = Node(data=nodes.pop(0)) self.head = node for elem in nodes: node.next = Node(data=elem) node = node.next \u0026#39;\u0026#39;\u0026#39; class Node: def __init__(self, data): self.data = data self.next = None def __repr__(self): return self.data class LinkedList: def __init__(self): self.head = None def __repr__(self): # representation node = self.head nodes = [] while node is not None: nodes.append(node.data) node = node.next nodes.append(\u0026#34;None\u0026#34;) return \u0026#34; -\u0026gt; \u0026#34;.join(nodes) def add_first(self, node): # insert at the front node.next = self.head self.head = node def add_last(self, node): # append at the end if self.head is None: self.head = node return for current_node in self: pass current_node.next = node def add_after(self, target_node_data, new_node): # insert after an existing node if self.head is None: raise Exception(\u0026#34;List is empty\u0026#34;) for node in self: if node.data == target_node_data: new_node.next = node.next node.next = new_node return raise Exception(\u0026#34;Node with data \u0026#39;%s\u0026#39; not found\u0026#34; % target_node_data) def add_before(self, target_node_data, new_node): # insert before an existing node if self.head is None: raise Exception(\u0026#34;List is empty\u0026#34;) if self.head.data == target_node_data: return self.add_first(new_node) prev_node = self.head for node in self: if node.data == target_node_data: prev_node.next = new_node new_node.next = node return prev_node = node raise Exception(\u0026#34;Node with data \u0026#39;%s\u0026#39; not found\u0026#34; % target_node_data) def remove_node(self, target_node_data): # remove if self.head is None: raise Exception(\u0026#34;List is empty\u0026#34;) if self.head.data == target_node_data: self.head = self.head.next return previous_node = self.head for node in self: if node.data == target_node_data: previous_node.next = node.next return previous_node = node raise Exception(\u0026#34;Node with data \u0026#39;%s\u0026#39; not found\u0026#34; % target_node_data)    Linked List Implementation in Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  // Create LinkedList\u0026lt;Integer\u0026gt; ll = new LinkedList\u0026lt;\u0026gt;(); // Add - O(1) ll.add(1); ll.add(2); ll.add(3); // Access - O(N) int elem = ll.get(0); // 1  // Search - O(N) int id = ll.indexOf(3); // 2  // Update - O(N) ll.set(2,100); // [1,2,100]  // Remove - O(N) ll.remove(1); // [1,100]  // size int length = ll.size();    Reference  Linked Lists in Python: An Introduction 手把手带你刷Leetcode力扣 - 链表Linked List 手把手带你刷Leetcode力扣 - Python3链表常用操作 手把手带你刷Leetcode力扣 - Java链表常用操作   ","date":"2022-03-20T22:36:59+08:00","permalink":"https://tonyfpy.github.io/p/data-structure-topic-3-linked-list/","title":"[Data Structure] Topic 3: Linked List"},{"content":" Authored by Tony Feng\nCreated on March 18th, 2022\nLast Modified on March 19th, 2022\n Understanding Arrays Def  An array is a collection of data elements with the same type stored at contiguous memory locations. Index \u0026amp; Elements Note: This is different from the List type in Python  Common Operations  Access - O(1) Search - O(n) Insert - O(n) Delete - O(n)  Characteristics  Easy to read Hard to write   Array Implementation in Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  # Create an array arr = [] # Add an element - O(1) if the position is empty;  # O(N) if the length of the array changes. arr.append(1) arr.append(2) arr.append(3) # [1,2,3] # Insert an element - O(N) arr.insert(2, 100) # [1,2,100,3] # Remove an element arr.remove(100) # case 1: [1,2,3] - O(N), where arg is an element arr.pop(1) # case 2: [1,3] - O(N), where arg is an index arr.pop() # case 3: [1] - O(1), where the last element is removed # Traverse an array - O(N) for item in arr: print(item) for id, item in enumerate(arr): print(\u0026#34;Index at \u0026#34;, id, \u0026#34; is: \u0026#34;, item) for id in range(0, len(arr)): print(arr[id]) # Find an element - O(N) arr[1,2,3] id = arr.index(3) # 2, where arg is an element # Sort an array - O(N*log(N)) arr = [3,1,2] arr.sort() # [1,2,3] a.sort(reverse=True) # [3,2,1]    Array Implementation in Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46  // Create an array int[] a = {1,2,3}; int[] b = new int[]{1,2,3}; int[] c = new int[3]; // The initilization is [0,0,0] for (int i=0, i \u0026lt; c.length; i++){ c[i] = i + 1; } ArrayList\u0026lt;Integer\u0026gt; d = new ArrayList\u0026lt;\u0026gt;(); // Integer is an object for (int i = 0; i \u0026lt; 3; i++){ d.add(i+1) } // Add an element // An addiotnal empty array should be declared for a, b, c. // For ArrayList, the length of the array could be ignored in declaration. d.add(100); // [1,2,3,100] - O(1) d.add(3, 99); // [1,2,3,99,100] - O(N), i.e. 100 should be moved backwards for 99.  // Access an element - O(1) int item1 = a[1]; int item2 = d.get(1); // Update an element - O(1) a[1] = 0; // [1,0,3,100] d.set(1, 0); // [1,0,3,99,100], where the 1st arg is the index; the 2nd arg is the new value.  // Remove an element for ArrayList - O(N) d.remove(99) // [1,2,3,100]  // Get the length of array - O(1), i.e. there is a cnt var inside int aLen = a.length; // String.length(), Array.length int dLen = d.size(); // Traverse an array - O(N) for (int i = 0; i \u0026lt; a.length; i++) { ... } for (int i = 0; i \u0026lt; d.size(); i++) { ... } // Find an element - O(N) // Loop should be adopted for a, b, c; // For ArrayList, use .contains() boolean is100 = d.contains(100) // Sort an array - O(N*log(N)) Array.sort(a) // Read from the last to reverse the array Collections.sort(d) Collections.sort(d, Collections.reverseOrder())    Reference  手把手带你刷Leetcode力扣 - 数组Array 手把手带你刷Leetcode力扣 - Python3数组常用操作 手把手带你刷Leetcode力扣 - Java数组常用操作   ","date":"2022-03-18T22:36:44+08:00","permalink":"https://tonyfpy.github.io/p/data-structure-topic-2-array/","title":"[Data Structure] Topic 2: Array"},{"content":" Authored by Tony Feng\nCreated on March 17th, 2022\nLast Modified on March 18th, 2022\n Time Complexity Def  The efficiency of the algorithm The relationship between the algorithm\u0026rsquo;s input and its execution time  Common Cases  O(1)  1 2 3 4  def O1(num): i = num j = num * 2 return i + j    O(n)  1 2 3 4 5  def ON(num): total = 0 for i in range(0, num): total += i return total    O(m+n)  1 2 3 4 5 6 7  def OMN(num1, num2): total = 0 for i in range(0, num1): total += 1 for j in range(0, num2): total += 1 return total    O(log(n))  1 2 3 4 5  def OlogN(num): i = 1 while i \u0026lt; num: i = i * 2 return i    O(n*log(n))  1 2 3 4 5 6 7 8  def ONlogN(num1, num2): total = 0 tmp = 1 for i in range(0, num1): while tmp \u0026lt; num2: total = i + tmp tmp = tmp * 2 return total    O(n2)  1 2 3 4 5 6  def ON2(num): total = 0 for i in range(0, num): for j in range(0, num): total += 1 return total   Comparison  O(1) \u0026lt; O(log(n)) \u0026lt; O(n) \u0026lt; O(n*log(n)) \u0026lt; O(n2) \u0026lt; O(2n) \u0026lt; O(n!)   Space Complexity Def  The relationship between the algorithm\u0026rsquo;s input and its memory space needed  Common Cases  O(1)  1 2 3 4 5 6  # total is a int variable with a 4-bytes memory def O1(num): total = 0 for i in range(0, num): total += i return total    O(n)  1 2 3 4 5 6  # nodes is a list whose memory depends on the input def On(nums): nodes = [] for num in nums: nodes.append(num) return nodes   Analysis Approches   Check the variable\n  If the variable varies in response to the input, e.g. array, linked list, hash map, etc., the space complexity may be O(n), O(n2) \u0026hellip;\n  If not, it is O(1)\n  Determine the space complexity case-by-case.\n  Be careful with the recursion. Info in each level are stored on a recursive stack.\n   Summary  There is a trade-off between time and space. Time should be considered in the first place.   Reference  手把手带你刷Leetcode力扣 - 算法的时间复杂度 手把手带你刷Leetcode力扣 - 算法的空间复杂度   ","date":"2022-03-17T22:26:52+08:00","permalink":"https://tonyfpy.github.io/p/data-structure-topic-1-time-and-space-complexity/","title":"[Data Structure] Topic 1: Time and Space Complexity"}]